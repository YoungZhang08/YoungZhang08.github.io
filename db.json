{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[],"Cache":[{"_id":"source/.DS_Store","hash":"66533bb495b2d5e8de3a281400d0b5b1d0f7c63b","modified":1550824786612},{"_id":"source/_posts/Webpack VS fis3.md","hash":"9e098ff8ef39076bef0e2f47805fd1d5acf48a30","modified":1550824653716},{"_id":"source/_posts/Vuex源码解读之install.md","hash":"7e866c0e6cf3b94fbc56d6abb101649135f3f1d5","modified":1550824653714},{"_id":"source/_posts/fis3前端工程化工具整理.md","hash":"9471bf78e2e13aa73ad8b95c2db5156799ed2ca9","modified":1550824653716},{"_id":"source/_posts/js深拷贝浅拷贝.md","hash":"ed92b1f0241a248cb5432b476471e82f08558109","modified":1550824653717},{"_id":"source/_posts/Vuex源码解读之store.md","hash":"ebd89448e7634887e3943f67634157c4e6ada12f","modified":1550824653715},{"_id":"source/_posts/git代码回滚.md","hash":"fbc83d6d2e4855582fe42785da71dc36b4ecd550","modified":1550824653717},{"_id":"source/_posts/test.md","hash":"9c91d31716e5641d5305b6234a76db9dd3cb6123","modified":1550826858716},{"_id":"source/_posts/webpack和gulp的区别.md","hash":"b199f93c10595a71a9931d9a570364bdd3964264","modified":1550824653718},{"_id":"source/_posts/从ES5&ES6两方看继承(一).md","hash":"6113fc198349ca7859bf3c24fb76eb78b9b10485","modified":1550824653719},{"_id":"source/_posts/从ES5&ES6两方看继承(二).md","hash":"d7c9d90c1be62595f42edbfe7ac62d8d5f14d265","modified":1550824653719},{"_id":"source/_posts/初试ES6之Class.md","hash":"e1a08378d8075fe5101de847c99ba41b16c7ae6e","modified":1550824653720},{"_id":"source/_posts/深入JS中的作用域和执行上下文.md","hash":"9a8f214aa52691167a920c0d452492b423dc41ed","modified":1550824653721},{"_id":"source/_posts/浅谈Webpack工作流程.md","hash":"bf0d4973ee8685fd18e728f5685605f0ba09bd14","modified":1550824653720},{"_id":"source/_posts/浅谈Webpack模块化实现原理.md","hash":"effca16ca8d217143d5b4be20f49fea9b762c3c1","modified":1550824653721},{"_id":"source/_posts/深入作用域链.md","hash":"a1a4a9071a0394e275b16b6b550496091f57e18c","modified":1550824653722},{"_id":"source/_posts/深入闭包.md","hash":"756becf1f115b300e5395920e031a4a2dd78fc8d","modified":1550824653722},{"_id":"source/_posts/由一道算法带进ES6之SetMap.md","hash":"fe1f2507a306a060baa12b406e5afd2f5807ecb5","modified":1550824653722},{"_id":"source/_posts/腾讯now直播一面笔试题再探.md","hash":"d14c0cf190b29f53bb737916ed9aaea1650e8e11","modified":1550824653728},{"_id":"source/_posts/解锁js数组去重的多种方法.md","hash":"3ef79faf4666d076aacab628599c30117c293cba","modified":1550824653728},{"_id":"source/about/index.md","hash":"27b5c87e595aa7798004bdd6ae759c9ca1b02100","modified":1550824653729},{"_id":"source/categories/index.md","hash":"b1a3bc3ef4420ecbc2089564ea10a4a50fb7f572","modified":1550824653730},{"_id":"source/tags/index.md","hash":"49b55fb45da6462f01709239b15c9efe4a73b296","modified":1550824653731},{"_id":"source/_posts/聊聊Vue的virtual-dom实现原理/0.png","hash":"e816ec488e59b9a68e75f7043145adf9bb969e9a","modified":1550824653723},{"_id":"source/_posts/聊聊Vue的virtual-dom实现原理/3.png","hash":"95e410e9b39853d7c49f4d81126cba496b9056de","modified":1550824653725},{"_id":"source/_posts/聊聊Vue的virtual-dom实现原理/5.png","hash":"760d2cdd661350314f0221b9a3c76497e82353b5","modified":1550824653727},{"_id":"source/_posts/聊聊Vue的virtual-dom实现原理/4.png","hash":"9e33cb496e273eeb94aa096d3812623ccc282816","modified":1550824653726},{"_id":"source/_posts/聊聊Vue的virtual-dom实现原理/2.png","hash":"7e0c08b013b00ea57cc9caa6ed7e751579e0b1da","modified":1550824653725},{"_id":"source/_posts/聊聊Vue的virtual-dom实现原理/1.png","hash":"14764c9a2cffa6b19f29ee04d678e02152f6a064","modified":1550824653724},{"_id":"public/about/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818799},{"_id":"public/categories/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818800},{"_id":"public/tags/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818800},{"_id":"public/2018/06/24/深入闭包/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818801},{"_id":"public/2018/06/24/深入作用域链/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818801},{"_id":"public/2018/06/24/深入JS中的作用域和执行上下文/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818801},{"_id":"public/2018/06/05/Vuex源码解读之store/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818801},{"_id":"public/2018/06/05/Vuex源码解读之install/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818801},{"_id":"public/2018/06/01/解锁js数组去重的多种方法/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818801},{"_id":"public/2018/05/30/Webpack VS fis3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818801},{"_id":"public/2018/05/30/浅谈Webpack工作流程/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818801},{"_id":"public/2018/05/28/fis3前端工程化工具整理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818801},{"_id":"public/2018/05/24/webpack和gulp的区别/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818801},{"_id":"public/2018/05/23/浅谈Webpack模块化实现原理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818801},{"_id":"public/2018/05/18/腾讯now直播一面笔试题再探/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818801},{"_id":"public/2018/05/18/从ES5&ES6两方看继承(二)/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818802},{"_id":"public/2018/05/17/js深拷贝浅拷贝/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818802},{"_id":"public/2018/05/16/git代码回滚/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818802},{"_id":"public/2018/05/10/从ES5&ES6两方看继承(一)/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818802},{"_id":"public/2018/05/09/初试ES6之Class/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818802},{"_id":"public/2018/05/08/由一道算法带进ES6之SetMap/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818802},{"_id":"public/archives/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818802},{"_id":"public/archives/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818802},{"_id":"public/archives/2018/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818803},{"_id":"public/archives/2018/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818803},{"_id":"public/archives/2018/05/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818803},{"_id":"public/archives/2018/05/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818803},{"_id":"public/archives/2018/06/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818803},{"_id":"public/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818802},{"_id":"public/page/2/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818802},{"_id":"public/tags/webpack/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818804},{"_id":"public/tags/fis3/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818804},{"_id":"public/tags/Vuex/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818805},{"_id":"public/tags/代码回滚/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818805},{"_id":"public/tags/gulp/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818805},{"_id":"public/tags/对象/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818805},{"_id":"public/tags/原型/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818805},{"_id":"public/tags/继承/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818805},{"_id":"public/tags/Class/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818805},{"_id":"public/tags/作用域/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818805},{"_id":"public/tags/执行上下文/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818806},{"_id":"public/tags/Webpack/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818806},{"_id":"public/tags/作用域链/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818807},{"_id":"public/tags/闭包/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818807},{"_id":"public/tags/Set/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818807},{"_id":"public/tags/Map/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818807},{"_id":"public/tags/类/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818807},{"_id":"public/tags/数组去重/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818808},{"_id":"public/tags/对象拷贝/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818808},{"_id":"public/categories/前端构建工具/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818803},{"_id":"public/categories/前端框架/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818804},{"_id":"public/categories/git管理/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818804},{"_id":"public/categories/ES5/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818804},{"_id":"public/categories/ES6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818804},{"_id":"public/categories/ES5-ES6/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818804},{"_id":"public/categories/JS手撕/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818804},{"_id":"public/2019/02/22/test/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818800},{"_id":"public/archives/2019/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818803},{"_id":"public/archives/2019/02/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1550831818803}],"Category":[{"name":"前端构建工具","_id":"cjsfugroh0004vrie4v4qgc92"},{"name":"前端框架","_id":"cjsfugrom000avriejr182f7t"},{"name":"git管理","_id":"cjsfugrot000mvriell3gla12"},{"name":"ES5","_id":"cjsfugrow000tvrieisbvkf7y"},{"name":"ES6","_id":"cjsfugroy000zvriea44cszi3"},{"name":"ES5 ES6","_id":"cjsfugrp3001jvriebjsb6zbw"},{"name":"JS手撕","_id":"cjsfugrp4001ovrieuuxxeglc"}],"Data":[],"Page":[{"title":"about","date":"2018-05-08T12:27:11.000Z","_content":"\n### emmmmm······小编前端白白兔^~^欢迎来纺[YoungZhang's github](https://github.com/youngzhang08)","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-05-08 20:27:11\n---\n\n### emmmmm······小编前端白白兔^~^欢迎来纺[YoungZhang's github](https://github.com/youngzhang08)","updated":"2019-02-22T08:37:33.729Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjsfugrod0001vried7px0o3i","content":"<h3 id=\"emmmmm······小编前端白白兔-欢迎来纺YoungZhang’s-github\"><a href=\"#emmmmm······小编前端白白兔-欢迎来纺YoungZhang’s-github\" class=\"headerlink\" title=\"emmmmm······小编前端白白兔^~^欢迎来纺YoungZhang’s github\"></a>emmmmm······小编前端白白兔^~^欢迎来纺<a href=\"https://github.com/youngzhang08\" target=\"_blank\" rel=\"noopener\">YoungZhang’s github</a></h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"emmmmm······小编前端白白兔-欢迎来纺YoungZhang’s-github\"><a href=\"#emmmmm······小编前端白白兔-欢迎来纺YoungZhang’s-github\" class=\"headerlink\" title=\"emmmmm······小编前端白白兔^~^欢迎来纺YoungZhang’s github\"></a>emmmmm······小编前端白白兔^~^欢迎来纺<a href=\"https://github.com/youngzhang08\" target=\"_blank\" rel=\"noopener\">YoungZhang’s github</a></h3>"},{"title":"categories","date":"2018-05-08T12:19:36.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-05-08 20:19:36\ntype: \"categories\"\n---\n","updated":"2019-02-22T08:37:33.730Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjsfugrog0003vriedx7g4xli","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-05-08T12:21:36.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-05-08 20:21:36\ntype: \"tags\"\n---\n","updated":"2019-02-22T08:37:33.731Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjsfugroj0007vrieog3rbdcl","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"layout":"webpack","title":"Webpack VS fis3","date":"2018-05-30T11:29:42.000Z","_content":"\n1. webpack 从 entry 出发，调用loader对模块的原始代码进行编译，接着调用acorn对js进行语法分析、收集其中的依赖关系，每个模块都会记录自己的依赖关系从而形成一颗关系树，最后调用compilation.seal进入render阶段根绝之前收集的依赖决定生成多少文件，每个文件的内容是什么。fis3 扫描项目目录拿到文件并初始化出一个文件对象列表，接着对文件对象中的每一个文件进行单文件编译，然后获取用户设置的package插件，进行打包处理。\n<!--more-->\n2. webpack 以js文件为入口，处理依赖的各种资源。fis3没有所谓的入口文件，所有文件（html，css，js等等）同等对待，自定义输出策略。\n3. webpack 文件产出一般以entry文件为基准。fis3 任何文件可以发布到任何位置，相关引用的路径也自动更新。\n4. webpack 适合类库打包和单页应用。fis3 适合多页应用的按需加载。\n5. webpack 有hot reload功能，fis3内置的server目前不支持。","source":"_posts/Webpack VS fis3.md","raw":"---\nlayout: webpack\ntitle: Webpack VS fis3\ndate: 2018-05-30 19:29:42\ntags: \n- webpack\n- fis3\ncategories: 前端构建工具\n---\n\n1. webpack 从 entry 出发，调用loader对模块的原始代码进行编译，接着调用acorn对js进行语法分析、收集其中的依赖关系，每个模块都会记录自己的依赖关系从而形成一颗关系树，最后调用compilation.seal进入render阶段根绝之前收集的依赖决定生成多少文件，每个文件的内容是什么。fis3 扫描项目目录拿到文件并初始化出一个文件对象列表，接着对文件对象中的每一个文件进行单文件编译，然后获取用户设置的package插件，进行打包处理。\n<!--more-->\n2. webpack 以js文件为入口，处理依赖的各种资源。fis3没有所谓的入口文件，所有文件（html，css，js等等）同等对待，自定义输出策略。\n3. webpack 文件产出一般以entry文件为基准。fis3 任何文件可以发布到任何位置，相关引用的路径也自动更新。\n4. webpack 适合类库打包和单页应用。fis3 适合多页应用的按需加载。\n5. webpack 有hot reload功能，fis3内置的server目前不支持。","slug":"Webpack VS fis3","published":1,"updated":"2019-02-22T08:37:33.716Z","comments":1,"photos":[],"link":"","_id":"cjsfugro90000vrie2xsd98if","content":"<ol>\n<li>webpack 从 entry 出发，调用loader对模块的原始代码进行编译，接着调用acorn对js进行语法分析、收集其中的依赖关系，每个模块都会记录自己的依赖关系从而形成一颗关系树，最后调用compilation.seal进入render阶段根绝之前收集的依赖决定生成多少文件，每个文件的内容是什么。fis3 扫描项目目录拿到文件并初始化出一个文件对象列表，接着对文件对象中的每一个文件进行单文件编译，然后获取用户设置的package插件，进行打包处理。<a id=\"more\"></a></li>\n<li>webpack 以js文件为入口，处理依赖的各种资源。fis3没有所谓的入口文件，所有文件（html，css，js等等）同等对待，自定义输出策略。</li>\n<li>webpack 文件产出一般以entry文件为基准。fis3 任何文件可以发布到任何位置，相关引用的路径也自动更新。</li>\n<li>webpack 适合类库打包和单页应用。fis3 适合多页应用的按需加载。</li>\n<li>webpack 有hot reload功能，fis3内置的server目前不支持。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<ol>\n<li>webpack 从 entry 出发，调用loader对模块的原始代码进行编译，接着调用acorn对js进行语法分析、收集其中的依赖关系，每个模块都会记录自己的依赖关系从而形成一颗关系树，最后调用compilation.seal进入render阶段根绝之前收集的依赖决定生成多少文件，每个文件的内容是什么。fis3 扫描项目目录拿到文件并初始化出一个文件对象列表，接着对文件对象中的每一个文件进行单文件编译，然后获取用户设置的package插件，进行打包处理。","more":"</li>\n<li>webpack 以js文件为入口，处理依赖的各种资源。fis3没有所谓的入口文件，所有文件（html，css，js等等）同等对待，自定义输出策略。</li>\n<li>webpack 文件产出一般以entry文件为基准。fis3 任何文件可以发布到任何位置，相关引用的路径也自动更新。</li>\n<li>webpack 适合类库打包和单页应用。fis3 适合多页应用的按需加载。</li>\n<li>webpack 有hot reload功能，fis3内置的server目前不支持。</li>\n</ol>"},{"title":"Vuex源码解读之install","date":"2018-06-05T13:04:10.000Z","about":null,"_content":"\n#### 解读目标\n> 在根实例中注册store选项，该store实例会注入到格努组件下面的所有子组件中，并且子组件都能通过this.$store访问，那为啥它们都可以通过this.$store就能访问到store选项？从入口文件开始——\n\n<!--more-->\n#### 入口文件，在src/index.js目录下\n```\nimport { Store, install } from './store'\nimport { mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers } from './helpers'\n\nexport default {\n  Store,\n  install,\n  version: '__VERSION__',\n  mapState,\n  mapMutations,\n  mapGetters,\n  mapActions,\n  createNamespacedHelpers\n}\n```\n可以看到这里就是vuex暴露出来的API，首先来看看install这个公开方法，当在vue中使用插件时，必须使用install方法。所以我们一般都是这样使用vuex的：\n\n```\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n...\nVue.use(Vuex)\n```\n因为vuex也可以看成是一个插件，所以在调用vue.use(Vuex)的时候，实际上调用了install的方法并传入了Vue的引用。\n\n#### install方法，在src/store.js目录下\n\n```\nexport function install (_Vue) {\n  if (Vue && _Vue === Vue) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(\n        '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n      )\n    }\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n```\n对Vue的判断主要是保证install方法只执行一次，这里把install方法的参数在最后赋值给了Vue变量，这样的话在index.js文件的其他地方也可以使用Vue这个变量。install方法的最后调用了applyMixin方法：\n\n#### applyMixin方法，在src/mixin.js目录下：\n\n```\nexport default function (Vue) {\n  const version = Number(Vue.version.split('.')[0])\n\n  if (version >= 2) {\n    Vue.mixin({ beforeCreate: vuexInit })\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    const _init = Vue.prototype._init\n    Vue.prototype._init = function (options = {}) {\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit () {\n    const options = this.$options\n    // store injection\n    if (options.store) {\n      this.$store = typeof options.store === 'function'\n        ? options.store()\n        : options.store\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\n```\n这段代码实现了全局注册混合对象。先读取了Vue的版本对其做判断，如果版本是2.x，则在beforeCreate这个生命周期中调用vuexInit方法进行初始化，如果版本是2.x一下，则在init这个生命周期中调用vuexInit方法进行初始化。vuexInit方法中，实际做的事情就是组件取得Vue对象的$options，把$options里的store赋值给$store。如果$options没有store，则向其parent向上查找并赋值。这也就是为什么我们在Vue组件中可以通过this.$store.xxx访问到Vuex的各种数据和状态。\n\n\n\n","source":"_posts/Vuex源码解读之install.md","raw":"---\ntitle: Vuex源码解读之install\ndate: 2018-06-05 21:04:10\ntags:\n- Vuex\ncategories: 前端框架\nabout: \n---\n\n#### 解读目标\n> 在根实例中注册store选项，该store实例会注入到格努组件下面的所有子组件中，并且子组件都能通过this.$store访问，那为啥它们都可以通过this.$store就能访问到store选项？从入口文件开始——\n\n<!--more-->\n#### 入口文件，在src/index.js目录下\n```\nimport { Store, install } from './store'\nimport { mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers } from './helpers'\n\nexport default {\n  Store,\n  install,\n  version: '__VERSION__',\n  mapState,\n  mapMutations,\n  mapGetters,\n  mapActions,\n  createNamespacedHelpers\n}\n```\n可以看到这里就是vuex暴露出来的API，首先来看看install这个公开方法，当在vue中使用插件时，必须使用install方法。所以我们一般都是这样使用vuex的：\n\n```\nimport Vue from 'vue'\nimport Vuex from 'vuex'\n...\nVue.use(Vuex)\n```\n因为vuex也可以看成是一个插件，所以在调用vue.use(Vuex)的时候，实际上调用了install的方法并传入了Vue的引用。\n\n#### install方法，在src/store.js目录下\n\n```\nexport function install (_Vue) {\n  if (Vue && _Vue === Vue) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(\n        '[vuex] already installed. Vue.use(Vuex) should be called only once.'\n      )\n    }\n    return\n  }\n  Vue = _Vue\n  applyMixin(Vue)\n}\n```\n对Vue的判断主要是保证install方法只执行一次，这里把install方法的参数在最后赋值给了Vue变量，这样的话在index.js文件的其他地方也可以使用Vue这个变量。install方法的最后调用了applyMixin方法：\n\n#### applyMixin方法，在src/mixin.js目录下：\n\n```\nexport default function (Vue) {\n  const version = Number(Vue.version.split('.')[0])\n\n  if (version >= 2) {\n    Vue.mixin({ beforeCreate: vuexInit })\n  } else {\n    // override init and inject vuex init procedure\n    // for 1.x backwards compatibility.\n    const _init = Vue.prototype._init\n    Vue.prototype._init = function (options = {}) {\n      options.init = options.init\n        ? [vuexInit].concat(options.init)\n        : vuexInit\n      _init.call(this, options)\n    }\n  }\n\n  /**\n   * Vuex init hook, injected into each instances init hooks list.\n   */\n\n  function vuexInit () {\n    const options = this.$options\n    // store injection\n    if (options.store) {\n      this.$store = typeof options.store === 'function'\n        ? options.store()\n        : options.store\n    } else if (options.parent && options.parent.$store) {\n      this.$store = options.parent.$store\n    }\n  }\n}\n```\n这段代码实现了全局注册混合对象。先读取了Vue的版本对其做判断，如果版本是2.x，则在beforeCreate这个生命周期中调用vuexInit方法进行初始化，如果版本是2.x一下，则在init这个生命周期中调用vuexInit方法进行初始化。vuexInit方法中，实际做的事情就是组件取得Vue对象的$options，把$options里的store赋值给$store。如果$options没有store，则向其parent向上查找并赋值。这也就是为什么我们在Vue组件中可以通过this.$store.xxx访问到Vuex的各种数据和状态。\n\n\n\n","slug":"Vuex源码解读之install","published":1,"updated":"2019-02-22T08:37:33.714Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugroe0002vriewyn6ubg7","content":"<h4 id=\"解读目标\"><a href=\"#解读目标\" class=\"headerlink\" title=\"解读目标\"></a>解读目标</h4><blockquote>\n<p>在根实例中注册store选项，该store实例会注入到格努组件下面的所有子组件中，并且子组件都能通过this.$store访问，那为啥它们都可以通过this.$store就能访问到store选项？从入口文件开始——</p>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"入口文件，在src-index-js目录下\"><a href=\"#入口文件，在src-index-js目录下\" class=\"headerlink\" title=\"入口文件，在src/index.js目录下\"></a>入口文件，在src/index.js目录下</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Store, install &#125; from &apos;./store&apos;</span><br><span class=\"line\">import &#123; mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers &#125; from &apos;./helpers&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  Store,</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  version: &apos;__VERSION__&apos;,</span><br><span class=\"line\">  mapState,</span><br><span class=\"line\">  mapMutations,</span><br><span class=\"line\">  mapGetters,</span><br><span class=\"line\">  mapActions,</span><br><span class=\"line\">  createNamespacedHelpers</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这里就是vuex暴露出来的API，首先来看看install这个公开方法，当在vue中使用插件时，必须使用install方法。所以我们一般都是这样使用vuex的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import Vuex from &apos;vuex&apos;</span><br><span class=\"line\">...</span><br><span class=\"line\">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>\n<p>因为vuex也可以看成是一个插件，所以在调用vue.use(Vuex)的时候，实际上调用了install的方法并传入了Vue的引用。</p>\n<h4 id=\"install方法，在src-store-js目录下\"><a href=\"#install方法，在src-store-js目录下\" class=\"headerlink\" title=\"install方法，在src/store.js目录下\"></a>install方法，在src/store.js目录下</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function install (_Vue) &#123;</span><br><span class=\"line\">  if (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      console.error(</span><br><span class=\"line\">        &apos;[vuex] already installed. Vue.use(Vuex) should be called only once.&apos;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Vue = _Vue</span><br><span class=\"line\">  applyMixin(Vue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对Vue的判断主要是保证install方法只执行一次，这里把install方法的参数在最后赋值给了Vue变量，这样的话在index.js文件的其他地方也可以使用Vue这个变量。install方法的最后调用了applyMixin方法：</p>\n<h4 id=\"applyMixin方法，在src-mixin-js目录下：\"><a href=\"#applyMixin方法，在src-mixin-js目录下：\" class=\"headerlink\" title=\"applyMixin方法，在src/mixin.js目录下：\"></a>applyMixin方法，在src/mixin.js目录下：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default function (Vue) &#123;</span><br><span class=\"line\">  const version = Number(Vue.version.split(&apos;.&apos;)[0])</span><br><span class=\"line\"></span><br><span class=\"line\">  if (version &gt;= 2) &#123;</span><br><span class=\"line\">    Vue.mixin(&#123; beforeCreate: vuexInit &#125;)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // override init and inject vuex init procedure</span><br><span class=\"line\">    // for 1.x backwards compatibility.</span><br><span class=\"line\">    const _init = Vue.prototype._init</span><br><span class=\"line\">    Vue.prototype._init = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">      options.init = options.init</span><br><span class=\"line\">        ? [vuexInit].concat(options.init)</span><br><span class=\"line\">        : vuexInit</span><br><span class=\"line\">      _init.call(this, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Vuex init hook, injected into each instances init hooks list.</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  function vuexInit () &#123;</span><br><span class=\"line\">    const options = this.$options</span><br><span class=\"line\">    // store injection</span><br><span class=\"line\">    if (options.store) &#123;</span><br><span class=\"line\">      this.$store = typeof options.store === &apos;function&apos;</span><br><span class=\"line\">        ? options.store()</span><br><span class=\"line\">        : options.store</span><br><span class=\"line\">    &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class=\"line\">      this.$store = options.parent.$store</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码实现了全局注册混合对象。先读取了Vue的版本对其做判断，如果版本是2.x，则在beforeCreate这个生命周期中调用vuexInit方法进行初始化，如果版本是2.x一下，则在init这个生命周期中调用vuexInit方法进行初始化。vuexInit方法中，实际做的事情就是组件取得Vue对象的$options，把$options里的store赋值给$store。如果$options没有store，则向其parent向上查找并赋值。这也就是为什么我们在Vue组件中可以通过this.$store.xxx访问到Vuex的各种数据和状态。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"解读目标\"><a href=\"#解读目标\" class=\"headerlink\" title=\"解读目标\"></a>解读目标</h4><blockquote>\n<p>在根实例中注册store选项，该store实例会注入到格努组件下面的所有子组件中，并且子组件都能通过this.$store访问，那为啥它们都可以通过this.$store就能访问到store选项？从入口文件开始——</p>\n</blockquote>","more":"<h4 id=\"入口文件，在src-index-js目录下\"><a href=\"#入口文件，在src-index-js目录下\" class=\"headerlink\" title=\"入口文件，在src/index.js目录下\"></a>入口文件，在src/index.js目录下</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; Store, install &#125; from &apos;./store&apos;</span><br><span class=\"line\">import &#123; mapState, mapMutations, mapGetters, mapActions, createNamespacedHelpers &#125; from &apos;./helpers&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  Store,</span><br><span class=\"line\">  install,</span><br><span class=\"line\">  version: &apos;__VERSION__&apos;,</span><br><span class=\"line\">  mapState,</span><br><span class=\"line\">  mapMutations,</span><br><span class=\"line\">  mapGetters,</span><br><span class=\"line\">  mapActions,</span><br><span class=\"line\">  createNamespacedHelpers</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这里就是vuex暴露出来的API，首先来看看install这个公开方法，当在vue中使用插件时，必须使用install方法。所以我们一般都是这样使用vuex的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Vue from &apos;vue&apos;</span><br><span class=\"line\">import Vuex from &apos;vuex&apos;</span><br><span class=\"line\">...</span><br><span class=\"line\">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>\n<p>因为vuex也可以看成是一个插件，所以在调用vue.use(Vuex)的时候，实际上调用了install的方法并传入了Vue的引用。</p>\n<h4 id=\"install方法，在src-store-js目录下\"><a href=\"#install方法，在src-store-js目录下\" class=\"headerlink\" title=\"install方法，在src/store.js目录下\"></a>install方法，在src/store.js目录下</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function install (_Vue) &#123;</span><br><span class=\"line\">  if (Vue &amp;&amp; _Vue === Vue) &#123;</span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      console.error(</span><br><span class=\"line\">        &apos;[vuex] already installed. Vue.use(Vuex) should be called only once.&apos;</span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  Vue = _Vue</span><br><span class=\"line\">  applyMixin(Vue)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对Vue的判断主要是保证install方法只执行一次，这里把install方法的参数在最后赋值给了Vue变量，这样的话在index.js文件的其他地方也可以使用Vue这个变量。install方法的最后调用了applyMixin方法：</p>\n<h4 id=\"applyMixin方法，在src-mixin-js目录下：\"><a href=\"#applyMixin方法，在src-mixin-js目录下：\" class=\"headerlink\" title=\"applyMixin方法，在src/mixin.js目录下：\"></a>applyMixin方法，在src/mixin.js目录下：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default function (Vue) &#123;</span><br><span class=\"line\">  const version = Number(Vue.version.split(&apos;.&apos;)[0])</span><br><span class=\"line\"></span><br><span class=\"line\">  if (version &gt;= 2) &#123;</span><br><span class=\"line\">    Vue.mixin(&#123; beforeCreate: vuexInit &#125;)</span><br><span class=\"line\">  &#125; else &#123;</span><br><span class=\"line\">    // override init and inject vuex init procedure</span><br><span class=\"line\">    // for 1.x backwards compatibility.</span><br><span class=\"line\">    const _init = Vue.prototype._init</span><br><span class=\"line\">    Vue.prototype._init = function (options = &#123;&#125;) &#123;</span><br><span class=\"line\">      options.init = options.init</span><br><span class=\"line\">        ? [vuexInit].concat(options.init)</span><br><span class=\"line\">        : vuexInit</span><br><span class=\"line\">      _init.call(this, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  /**</span><br><span class=\"line\">   * Vuex init hook, injected into each instances init hooks list.</span><br><span class=\"line\">   */</span><br><span class=\"line\"></span><br><span class=\"line\">  function vuexInit () &#123;</span><br><span class=\"line\">    const options = this.$options</span><br><span class=\"line\">    // store injection</span><br><span class=\"line\">    if (options.store) &#123;</span><br><span class=\"line\">      this.$store = typeof options.store === &apos;function&apos;</span><br><span class=\"line\">        ? options.store()</span><br><span class=\"line\">        : options.store</span><br><span class=\"line\">    &#125; else if (options.parent &amp;&amp; options.parent.$store) &#123;</span><br><span class=\"line\">      this.$store = options.parent.$store</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码实现了全局注册混合对象。先读取了Vue的版本对其做判断，如果版本是2.x，则在beforeCreate这个生命周期中调用vuexInit方法进行初始化，如果版本是2.x一下，则在init这个生命周期中调用vuexInit方法进行初始化。vuexInit方法中，实际做的事情就是组件取得Vue对象的$options，把$options里的store赋值给$store。如果$options没有store，则向其parent向上查找并赋值。这也就是为什么我们在Vue组件中可以通过this.$store.xxx访问到Vuex的各种数据和状态。</p>"},{"title":"Vuex源码解读之store","date":"2018-06-05T13:05:37.000Z","about":null,"_content":"#### 解读目标\n> store对象中有个属性叫state，state包含了全部的应用层级状态。应用中的各个组件如果使用了state，则会保持与同步最新的状态。state就像是Vue中的data，但是state其实是整个Vue应用的data。有个例子：比如说现在有两个非父子关系的子组件a和b，a和b中都监听了state.count,如果a中修改了state.count，那么b中的state.count也相应的会改变。接下来想要探究的问题就是Vuex是如何监听各个组件中的state属性的，其实我觉得有可能又是Object.defineProperty在搞事情——\n<!--more-->\n#### store对象，在src/store.js目录下\n先看**Store类的constructor**，代码很长：\n```\nexport class Store {\n    constructor (options = {}) {\n    // Auto install if it is not done yet and `window` has `Vue`.\n    // To allow users to avoid auto-installation in some cases,\n    // this code should be placed here. See #731\n    if (!Vue && typeof window !== 'undefined' && window.Vue) {\n      install(window.Vue)\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n      assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n      assert(this instanceof Store, `store must be called with the new operator.`)\n    }\n\n    const {\n      plugins = [],\n      strict = false\n    } = options\n\n    // store internal state\n    this._committing = false\n    this._actions = Object.create(null)\n    this._actionSubscribers = []\n    this._mutations = Object.create(null)\n    this._wrappedGetters = Object.create(null)\n    this._modules = new ModuleCollection(options)\n    this._modulesNamespaceMap = Object.create(null)\n    this._subscribers = []\n    this._watcherVM = new Vue()\n\n    // bind commit and dispatch to self\n    const store = this\n    const { dispatch, commit } = this\n    this.dispatch = function boundDispatch (type, payload) {\n      return dispatch.call(store, type, payload)\n    }\n    this.commit = function boundCommit (type, payload, options) {\n      return commit.call(store, type, payload, options)\n    }\n\n    // strict mode\n    this.strict = strict\n\n    const state = this._modules.root.state\n\n    // init root module.\n    // this also recursively registers all sub-modules\n    // and collects all module getters inside this._wrappedGetters\n    installModule(this, state, [], this._modules.root)\n\n    // initialize the store vm, which is responsible for the reactivity\n    // (also registers _wrappedGetters as computed properties)\n    resetStoreVM(this, state)\n  }\n}\n```\n从上往下看吧，首先会使用断言函数assert()对一些条件进行检验，assert()的源码在src/util.js下，实现的就是当不满足某些条件时，会抛出错误。\n\n```\nexport function assert (condition, msg) {\n  if (!condition) throw new Error([vuex] ${msg})\n}\n```\nStore类中的断言函数的作用是：\n\n```\nif (process.env.NODE_ENV !== 'production') {\n    assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n    assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n    assert(this instanceof Store, `store must be called with the new operator.`)\n}\n```\n1. 确保创建实例前已经在Vue中注册了Vuex，也就是Vue.use(Vuex)。如果在new Vue()之后再去调用Vue.use(Vuex)的话，初始化函数并没有挂载到Vue上，就会导致$store属性无法添加到Vue实例对象上。\n2. 确保Promise可以使用，因为Vuex的源码是依赖Promise的。注意要使用Promise，需要添加bable-polyfill的依赖编译。\n3. 验证调用方法是否通过new出来的，也就是说判断是否是Store的原型，防止通过直接调用Store()。\n\n接着利用ES6解构赋值拿到的options中的plugins（插件）和strict（是否开启严格模式）。\n```\nconst {\n    plugins = [],\n    strict = false\n} = options\n```\n接下来主要是创建一些内部的属性：\n```\n// store internal state\nthis._committing = false\nthis._actions = Object.create(null)\nthis._actionSubscribers = []\nthis._mutations = Object.create(null)\nthis._wrappedGetters = Object.create(null)\nthis._modules = new ModuleCollection(options)\nthis._modulesNamespaceMap = Object.create(null)\nthis._subscribers = []\nthis._watcherVM = new Vue()\n```\n1. this._committing标志一个提交状态，作用是保证对Vuex中的state的修改只能在mutation的回到函数中，而不能在外部随意修改state\n2. this._actions用来存储用户定义的所有actions\n3. this._actionSubscribers用来存储所有的actions的订阅者\n4. this._mutations用来存储用户定义的所有mutation\n5. this._wrappedGetters用来存储用户定义的所有getters\n6. this._modules用来存储用户定义的module\n7. this._modulesNamespaceMap用来存储用户定义的modules的命名空间\n8. this._subscribers用来存储所有对mutation变化的订阅者\n9. this._watcherVM是一个Vue对象的实例，主要是利用Vue实例方法$watch来监测变化的\n\n接着就是把Store类的dispatch和commit方法的this指针指向当前store的实例上，dispatch和commit之后再分析。\n```\n// bind commit and dispatch to self\nconst store = this\nconst { dispatch, commit } = this\nthis.dispatch = function boundDispatch (type, payload) {\n    return dispatch.call(store, type, payload)\n}\nthis.commit = function boundCommit (type, payload, options) {\n    return commit.call(store, type, payload, options)\n}\n```\n接着往下看，this.strict表示是否开启严格模式，在严格模式下回观测所有的state的变化，建议在开发环境时开启严格模式，线上环境关闭严格模式。\n```\n// strict mode\nthis.strict = strict\n```\n取得当前实例下用户定义的module的根实例下的state，下面就是调用installModule和resetStoreVM这两个方法。\n```\nconst state = this._modules.root.state\n\n// init root module.\n// this also recursively registers all sub-modules\n// and collects all module getters inside this._wrappedGetters\ninstallModule(this, state, [], this._modules.root)\n\n// initialize the store vm, which is responsible for the reactivity\n// (also registers _wrappedGetters as computed properties)\nresetStoreVM(this, state)\n```\n剩下的代码主要是Vuex的初始化的核心。\n\n\n\n\n\n","source":"_posts/Vuex源码解读之store.md","raw":"---\ntitle: Vuex源码解读之store\ndate: 2018-06-05 21:05:37\ntags:\n- Vuex\ncategories: 前端框架\nabout:\n---\n#### 解读目标\n> store对象中有个属性叫state，state包含了全部的应用层级状态。应用中的各个组件如果使用了state，则会保持与同步最新的状态。state就像是Vue中的data，但是state其实是整个Vue应用的data。有个例子：比如说现在有两个非父子关系的子组件a和b，a和b中都监听了state.count,如果a中修改了state.count，那么b中的state.count也相应的会改变。接下来想要探究的问题就是Vuex是如何监听各个组件中的state属性的，其实我觉得有可能又是Object.defineProperty在搞事情——\n<!--more-->\n#### store对象，在src/store.js目录下\n先看**Store类的constructor**，代码很长：\n```\nexport class Store {\n    constructor (options = {}) {\n    // Auto install if it is not done yet and `window` has `Vue`.\n    // To allow users to avoid auto-installation in some cases,\n    // this code should be placed here. See #731\n    if (!Vue && typeof window !== 'undefined' && window.Vue) {\n      install(window.Vue)\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n      assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n      assert(this instanceof Store, `store must be called with the new operator.`)\n    }\n\n    const {\n      plugins = [],\n      strict = false\n    } = options\n\n    // store internal state\n    this._committing = false\n    this._actions = Object.create(null)\n    this._actionSubscribers = []\n    this._mutations = Object.create(null)\n    this._wrappedGetters = Object.create(null)\n    this._modules = new ModuleCollection(options)\n    this._modulesNamespaceMap = Object.create(null)\n    this._subscribers = []\n    this._watcherVM = new Vue()\n\n    // bind commit and dispatch to self\n    const store = this\n    const { dispatch, commit } = this\n    this.dispatch = function boundDispatch (type, payload) {\n      return dispatch.call(store, type, payload)\n    }\n    this.commit = function boundCommit (type, payload, options) {\n      return commit.call(store, type, payload, options)\n    }\n\n    // strict mode\n    this.strict = strict\n\n    const state = this._modules.root.state\n\n    // init root module.\n    // this also recursively registers all sub-modules\n    // and collects all module getters inside this._wrappedGetters\n    installModule(this, state, [], this._modules.root)\n\n    // initialize the store vm, which is responsible for the reactivity\n    // (also registers _wrappedGetters as computed properties)\n    resetStoreVM(this, state)\n  }\n}\n```\n从上往下看吧，首先会使用断言函数assert()对一些条件进行检验，assert()的源码在src/util.js下，实现的就是当不满足某些条件时，会抛出错误。\n\n```\nexport function assert (condition, msg) {\n  if (!condition) throw new Error([vuex] ${msg})\n}\n```\nStore类中的断言函数的作用是：\n\n```\nif (process.env.NODE_ENV !== 'production') {\n    assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)\n    assert(typeof Promise !== 'undefined', `vuex requires a Promise polyfill in this browser.`)\n    assert(this instanceof Store, `store must be called with the new operator.`)\n}\n```\n1. 确保创建实例前已经在Vue中注册了Vuex，也就是Vue.use(Vuex)。如果在new Vue()之后再去调用Vue.use(Vuex)的话，初始化函数并没有挂载到Vue上，就会导致$store属性无法添加到Vue实例对象上。\n2. 确保Promise可以使用，因为Vuex的源码是依赖Promise的。注意要使用Promise，需要添加bable-polyfill的依赖编译。\n3. 验证调用方法是否通过new出来的，也就是说判断是否是Store的原型，防止通过直接调用Store()。\n\n接着利用ES6解构赋值拿到的options中的plugins（插件）和strict（是否开启严格模式）。\n```\nconst {\n    plugins = [],\n    strict = false\n} = options\n```\n接下来主要是创建一些内部的属性：\n```\n// store internal state\nthis._committing = false\nthis._actions = Object.create(null)\nthis._actionSubscribers = []\nthis._mutations = Object.create(null)\nthis._wrappedGetters = Object.create(null)\nthis._modules = new ModuleCollection(options)\nthis._modulesNamespaceMap = Object.create(null)\nthis._subscribers = []\nthis._watcherVM = new Vue()\n```\n1. this._committing标志一个提交状态，作用是保证对Vuex中的state的修改只能在mutation的回到函数中，而不能在外部随意修改state\n2. this._actions用来存储用户定义的所有actions\n3. this._actionSubscribers用来存储所有的actions的订阅者\n4. this._mutations用来存储用户定义的所有mutation\n5. this._wrappedGetters用来存储用户定义的所有getters\n6. this._modules用来存储用户定义的module\n7. this._modulesNamespaceMap用来存储用户定义的modules的命名空间\n8. this._subscribers用来存储所有对mutation变化的订阅者\n9. this._watcherVM是一个Vue对象的实例，主要是利用Vue实例方法$watch来监测变化的\n\n接着就是把Store类的dispatch和commit方法的this指针指向当前store的实例上，dispatch和commit之后再分析。\n```\n// bind commit and dispatch to self\nconst store = this\nconst { dispatch, commit } = this\nthis.dispatch = function boundDispatch (type, payload) {\n    return dispatch.call(store, type, payload)\n}\nthis.commit = function boundCommit (type, payload, options) {\n    return commit.call(store, type, payload, options)\n}\n```\n接着往下看，this.strict表示是否开启严格模式，在严格模式下回观测所有的state的变化，建议在开发环境时开启严格模式，线上环境关闭严格模式。\n```\n// strict mode\nthis.strict = strict\n```\n取得当前实例下用户定义的module的根实例下的state，下面就是调用installModule和resetStoreVM这两个方法。\n```\nconst state = this._modules.root.state\n\n// init root module.\n// this also recursively registers all sub-modules\n// and collects all module getters inside this._wrappedGetters\ninstallModule(this, state, [], this._modules.root)\n\n// initialize the store vm, which is responsible for the reactivity\n// (also registers _wrappedGetters as computed properties)\nresetStoreVM(this, state)\n```\n剩下的代码主要是Vuex的初始化的核心。\n\n\n\n\n\n","slug":"Vuex源码解读之store","published":1,"updated":"2019-02-22T08:37:33.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugroi0006vriel1oii6kg","content":"<h4 id=\"解读目标\"><a href=\"#解读目标\" class=\"headerlink\" title=\"解读目标\"></a>解读目标</h4><blockquote>\n<p>store对象中有个属性叫state，state包含了全部的应用层级状态。应用中的各个组件如果使用了state，则会保持与同步最新的状态。state就像是Vue中的data，但是state其实是整个Vue应用的data。有个例子：比如说现在有两个非父子关系的子组件a和b，a和b中都监听了state.count,如果a中修改了state.count，那么b中的state.count也相应的会改变。接下来想要探究的问题就是Vuex是如何监听各个组件中的state属性的，其实我觉得有可能又是Object.defineProperty在搞事情——<br><a id=\"more\"></a></p>\n</blockquote>\n<h4 id=\"store对象，在src-store-js目录下\"><a href=\"#store对象，在src-store-js目录下\" class=\"headerlink\" title=\"store对象，在src/store.js目录下\"></a>store对象，在src/store.js目录下</h4><p>先看<strong>Store类的constructor</strong>，代码很长：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export class Store &#123;</span><br><span class=\"line\">    constructor (options = &#123;&#125;) &#123;</span><br><span class=\"line\">    // Auto install if it is not done yet and `window` has `Vue`.</span><br><span class=\"line\">    // To allow users to avoid auto-installation in some cases,</span><br><span class=\"line\">    // this code should be placed here. See #731</span><br><span class=\"line\">    if (!Vue &amp;&amp; typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">      install(window.Vue)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)</span><br><span class=\"line\">      assert(typeof Promise !== &apos;undefined&apos;, `vuex requires a Promise polyfill in this browser.`)</span><br><span class=\"line\">      assert(this instanceof Store, `store must be called with the new operator.`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const &#123;</span><br><span class=\"line\">      plugins = [],</span><br><span class=\"line\">      strict = false</span><br><span class=\"line\">    &#125; = options</span><br><span class=\"line\"></span><br><span class=\"line\">    // store internal state</span><br><span class=\"line\">    this._committing = false</span><br><span class=\"line\">    this._actions = Object.create(null)</span><br><span class=\"line\">    this._actionSubscribers = []</span><br><span class=\"line\">    this._mutations = Object.create(null)</span><br><span class=\"line\">    this._wrappedGetters = Object.create(null)</span><br><span class=\"line\">    this._modules = new ModuleCollection(options)</span><br><span class=\"line\">    this._modulesNamespaceMap = Object.create(null)</span><br><span class=\"line\">    this._subscribers = []</span><br><span class=\"line\">    this._watcherVM = new Vue()</span><br><span class=\"line\"></span><br><span class=\"line\">    // bind commit and dispatch to self</span><br><span class=\"line\">    const store = this</span><br><span class=\"line\">    const &#123; dispatch, commit &#125; = this</span><br><span class=\"line\">    this.dispatch = function boundDispatch (type, payload) &#123;</span><br><span class=\"line\">      return dispatch.call(store, type, payload)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.commit = function boundCommit (type, payload, options) &#123;</span><br><span class=\"line\">      return commit.call(store, type, payload, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // strict mode</span><br><span class=\"line\">    this.strict = strict</span><br><span class=\"line\"></span><br><span class=\"line\">    const state = this._modules.root.state</span><br><span class=\"line\"></span><br><span class=\"line\">    // init root module.</span><br><span class=\"line\">    // this also recursively registers all sub-modules</span><br><span class=\"line\">    // and collects all module getters inside this._wrappedGetters</span><br><span class=\"line\">    installModule(this, state, [], this._modules.root)</span><br><span class=\"line\"></span><br><span class=\"line\">    // initialize the store vm, which is responsible for the reactivity</span><br><span class=\"line\">    // (also registers _wrappedGetters as computed properties)</span><br><span class=\"line\">    resetStoreVM(this, state)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从上往下看吧，首先会使用断言函数assert()对一些条件进行检验，assert()的源码在src/util.js下，实现的就是当不满足某些条件时，会抛出错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function assert (condition, msg) &#123;</span><br><span class=\"line\">  if (!condition) throw new Error([vuex] $&#123;msg&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Store类中的断言函数的作用是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">    assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)</span><br><span class=\"line\">    assert(typeof Promise !== &apos;undefined&apos;, `vuex requires a Promise polyfill in this browser.`)</span><br><span class=\"line\">    assert(this instanceof Store, `store must be called with the new operator.`)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>确保创建实例前已经在Vue中注册了Vuex，也就是Vue.use(Vuex)。如果在new Vue()之后再去调用Vue.use(Vuex)的话，初始化函数并没有挂载到Vue上，就会导致$store属性无法添加到Vue实例对象上。</li>\n<li>确保Promise可以使用，因为Vuex的源码是依赖Promise的。注意要使用Promise，需要添加bable-polyfill的依赖编译。</li>\n<li>验证调用方法是否通过new出来的，也就是说判断是否是Store的原型，防止通过直接调用Store()。</li>\n</ol>\n<p>接着利用ES6解构赋值拿到的options中的plugins（插件）和strict（是否开启严格模式）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;</span><br><span class=\"line\">    plugins = [],</span><br><span class=\"line\">    strict = false</span><br><span class=\"line\">&#125; = options</span><br></pre></td></tr></table></figure></p>\n<p>接下来主要是创建一些内部的属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// store internal state</span><br><span class=\"line\">this._committing = false</span><br><span class=\"line\">this._actions = Object.create(null)</span><br><span class=\"line\">this._actionSubscribers = []</span><br><span class=\"line\">this._mutations = Object.create(null)</span><br><span class=\"line\">this._wrappedGetters = Object.create(null)</span><br><span class=\"line\">this._modules = new ModuleCollection(options)</span><br><span class=\"line\">this._modulesNamespaceMap = Object.create(null)</span><br><span class=\"line\">this._subscribers = []</span><br><span class=\"line\">this._watcherVM = new Vue()</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>this._committing标志一个提交状态，作用是保证对Vuex中的state的修改只能在mutation的回到函数中，而不能在外部随意修改state</li>\n<li>this._actions用来存储用户定义的所有actions</li>\n<li>this._actionSubscribers用来存储所有的actions的订阅者</li>\n<li>this._mutations用来存储用户定义的所有mutation</li>\n<li>this._wrappedGetters用来存储用户定义的所有getters</li>\n<li>this._modules用来存储用户定义的module</li>\n<li>this._modulesNamespaceMap用来存储用户定义的modules的命名空间</li>\n<li>this._subscribers用来存储所有对mutation变化的订阅者</li>\n<li>this._watcherVM是一个Vue对象的实例，主要是利用Vue实例方法$watch来监测变化的</li>\n</ol>\n<p>接着就是把Store类的dispatch和commit方法的this指针指向当前store的实例上，dispatch和commit之后再分析。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bind commit and dispatch to self</span><br><span class=\"line\">const store = this</span><br><span class=\"line\">const &#123; dispatch, commit &#125; = this</span><br><span class=\"line\">this.dispatch = function boundDispatch (type, payload) &#123;</span><br><span class=\"line\">    return dispatch.call(store, type, payload)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">this.commit = function boundCommit (type, payload, options) &#123;</span><br><span class=\"line\">    return commit.call(store, type, payload, options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着往下看，this.strict表示是否开启严格模式，在严格模式下回观测所有的state的变化，建议在开发环境时开启严格模式，线上环境关闭严格模式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// strict mode</span><br><span class=\"line\">this.strict = strict</span><br></pre></td></tr></table></figure></p>\n<p>取得当前实例下用户定义的module的根实例下的state，下面就是调用installModule和resetStoreVM这两个方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const state = this._modules.root.state</span><br><span class=\"line\"></span><br><span class=\"line\">// init root module.</span><br><span class=\"line\">// this also recursively registers all sub-modules</span><br><span class=\"line\">// and collects all module getters inside this._wrappedGetters</span><br><span class=\"line\">installModule(this, state, [], this._modules.root)</span><br><span class=\"line\"></span><br><span class=\"line\">// initialize the store vm, which is responsible for the reactivity</span><br><span class=\"line\">// (also registers _wrappedGetters as computed properties)</span><br><span class=\"line\">resetStoreVM(this, state)</span><br></pre></td></tr></table></figure></p>\n<p>剩下的代码主要是Vuex的初始化的核心。</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"解读目标\"><a href=\"#解读目标\" class=\"headerlink\" title=\"解读目标\"></a>解读目标</h4><blockquote>\n<p>store对象中有个属性叫state，state包含了全部的应用层级状态。应用中的各个组件如果使用了state，则会保持与同步最新的状态。state就像是Vue中的data，但是state其实是整个Vue应用的data。有个例子：比如说现在有两个非父子关系的子组件a和b，a和b中都监听了state.count,如果a中修改了state.count，那么b中的state.count也相应的会改变。接下来想要探究的问题就是Vuex是如何监听各个组件中的state属性的，其实我觉得有可能又是Object.defineProperty在搞事情——<br>","more":"</p>\n</blockquote>\n<h4 id=\"store对象，在src-store-js目录下\"><a href=\"#store对象，在src-store-js目录下\" class=\"headerlink\" title=\"store对象，在src/store.js目录下\"></a>store对象，在src/store.js目录下</h4><p>先看<strong>Store类的constructor</strong>，代码很长：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export class Store &#123;</span><br><span class=\"line\">    constructor (options = &#123;&#125;) &#123;</span><br><span class=\"line\">    // Auto install if it is not done yet and `window` has `Vue`.</span><br><span class=\"line\">    // To allow users to avoid auto-installation in some cases,</span><br><span class=\"line\">    // this code should be placed here. See #731</span><br><span class=\"line\">    if (!Vue &amp;&amp; typeof window !== &apos;undefined&apos; &amp;&amp; window.Vue) &#123;</span><br><span class=\"line\">      install(window.Vue)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">      assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)</span><br><span class=\"line\">      assert(typeof Promise !== &apos;undefined&apos;, `vuex requires a Promise polyfill in this browser.`)</span><br><span class=\"line\">      assert(this instanceof Store, `store must be called with the new operator.`)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const &#123;</span><br><span class=\"line\">      plugins = [],</span><br><span class=\"line\">      strict = false</span><br><span class=\"line\">    &#125; = options</span><br><span class=\"line\"></span><br><span class=\"line\">    // store internal state</span><br><span class=\"line\">    this._committing = false</span><br><span class=\"line\">    this._actions = Object.create(null)</span><br><span class=\"line\">    this._actionSubscribers = []</span><br><span class=\"line\">    this._mutations = Object.create(null)</span><br><span class=\"line\">    this._wrappedGetters = Object.create(null)</span><br><span class=\"line\">    this._modules = new ModuleCollection(options)</span><br><span class=\"line\">    this._modulesNamespaceMap = Object.create(null)</span><br><span class=\"line\">    this._subscribers = []</span><br><span class=\"line\">    this._watcherVM = new Vue()</span><br><span class=\"line\"></span><br><span class=\"line\">    // bind commit and dispatch to self</span><br><span class=\"line\">    const store = this</span><br><span class=\"line\">    const &#123; dispatch, commit &#125; = this</span><br><span class=\"line\">    this.dispatch = function boundDispatch (type, payload) &#123;</span><br><span class=\"line\">      return dispatch.call(store, type, payload)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.commit = function boundCommit (type, payload, options) &#123;</span><br><span class=\"line\">      return commit.call(store, type, payload, options)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // strict mode</span><br><span class=\"line\">    this.strict = strict</span><br><span class=\"line\"></span><br><span class=\"line\">    const state = this._modules.root.state</span><br><span class=\"line\"></span><br><span class=\"line\">    // init root module.</span><br><span class=\"line\">    // this also recursively registers all sub-modules</span><br><span class=\"line\">    // and collects all module getters inside this._wrappedGetters</span><br><span class=\"line\">    installModule(this, state, [], this._modules.root)</span><br><span class=\"line\"></span><br><span class=\"line\">    // initialize the store vm, which is responsible for the reactivity</span><br><span class=\"line\">    // (also registers _wrappedGetters as computed properties)</span><br><span class=\"line\">    resetStoreVM(this, state)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>从上往下看吧，首先会使用断言函数assert()对一些条件进行检验，assert()的源码在src/util.js下，实现的就是当不满足某些条件时，会抛出错误。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export function assert (condition, msg) &#123;</span><br><span class=\"line\">  if (!condition) throw new Error([vuex] $&#123;msg&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Store类中的断言函数的作用是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class=\"line\">    assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`)</span><br><span class=\"line\">    assert(typeof Promise !== &apos;undefined&apos;, `vuex requires a Promise polyfill in this browser.`)</span><br><span class=\"line\">    assert(this instanceof Store, `store must be called with the new operator.`)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ol>\n<li>确保创建实例前已经在Vue中注册了Vuex，也就是Vue.use(Vuex)。如果在new Vue()之后再去调用Vue.use(Vuex)的话，初始化函数并没有挂载到Vue上，就会导致$store属性无法添加到Vue实例对象上。</li>\n<li>确保Promise可以使用，因为Vuex的源码是依赖Promise的。注意要使用Promise，需要添加bable-polyfill的依赖编译。</li>\n<li>验证调用方法是否通过new出来的，也就是说判断是否是Store的原型，防止通过直接调用Store()。</li>\n</ol>\n<p>接着利用ES6解构赋值拿到的options中的plugins（插件）和strict（是否开启严格模式）。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const &#123;</span><br><span class=\"line\">    plugins = [],</span><br><span class=\"line\">    strict = false</span><br><span class=\"line\">&#125; = options</span><br></pre></td></tr></table></figure></p>\n<p>接下来主要是创建一些内部的属性：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// store internal state</span><br><span class=\"line\">this._committing = false</span><br><span class=\"line\">this._actions = Object.create(null)</span><br><span class=\"line\">this._actionSubscribers = []</span><br><span class=\"line\">this._mutations = Object.create(null)</span><br><span class=\"line\">this._wrappedGetters = Object.create(null)</span><br><span class=\"line\">this._modules = new ModuleCollection(options)</span><br><span class=\"line\">this._modulesNamespaceMap = Object.create(null)</span><br><span class=\"line\">this._subscribers = []</span><br><span class=\"line\">this._watcherVM = new Vue()</span><br></pre></td></tr></table></figure></p>\n<ol>\n<li>this._committing标志一个提交状态，作用是保证对Vuex中的state的修改只能在mutation的回到函数中，而不能在外部随意修改state</li>\n<li>this._actions用来存储用户定义的所有actions</li>\n<li>this._actionSubscribers用来存储所有的actions的订阅者</li>\n<li>this._mutations用来存储用户定义的所有mutation</li>\n<li>this._wrappedGetters用来存储用户定义的所有getters</li>\n<li>this._modules用来存储用户定义的module</li>\n<li>this._modulesNamespaceMap用来存储用户定义的modules的命名空间</li>\n<li>this._subscribers用来存储所有对mutation变化的订阅者</li>\n<li>this._watcherVM是一个Vue对象的实例，主要是利用Vue实例方法$watch来监测变化的</li>\n</ol>\n<p>接着就是把Store类的dispatch和commit方法的this指针指向当前store的实例上，dispatch和commit之后再分析。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// bind commit and dispatch to self</span><br><span class=\"line\">const store = this</span><br><span class=\"line\">const &#123; dispatch, commit &#125; = this</span><br><span class=\"line\">this.dispatch = function boundDispatch (type, payload) &#123;</span><br><span class=\"line\">    return dispatch.call(store, type, payload)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">this.commit = function boundCommit (type, payload, options) &#123;</span><br><span class=\"line\">    return commit.call(store, type, payload, options)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>接着往下看，this.strict表示是否开启严格模式，在严格模式下回观测所有的state的变化，建议在开发环境时开启严格模式，线上环境关闭严格模式。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// strict mode</span><br><span class=\"line\">this.strict = strict</span><br></pre></td></tr></table></figure></p>\n<p>取得当前实例下用户定义的module的根实例下的state，下面就是调用installModule和resetStoreVM这两个方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const state = this._modules.root.state</span><br><span class=\"line\"></span><br><span class=\"line\">// init root module.</span><br><span class=\"line\">// this also recursively registers all sub-modules</span><br><span class=\"line\">// and collects all module getters inside this._wrappedGetters</span><br><span class=\"line\">installModule(this, state, [], this._modules.root)</span><br><span class=\"line\"></span><br><span class=\"line\">// initialize the store vm, which is responsible for the reactivity</span><br><span class=\"line\">// (also registers _wrappedGetters as computed properties)</span><br><span class=\"line\">resetStoreVM(this, state)</span><br></pre></td></tr></table></figure></p>\n<p>剩下的代码主要是Vuex的初始化的核心。</p>"},{"title":"git代码回滚","date":"2018-05-16T13:09:31.000Z","about":null,"_content":"\n### 好了，记录一下今日的壮举。。。\n坐标：百度大厦C座      时间：2018-05-16      \n事件起因：上次的需求提交多提交了一个不必要的包导师缺陷检测有6个问题不能merge，所以今日在本地删除包之后提交代码，又因为对git操作的不熟悉，对untracked的deleted的文件执行了\"git rm -r .\"，然后就很尴尬了。。。我就看着我的VSCode的资源管理器那一栏噌噌噌地没了。。。但是还有部分没有删除。emmmmm，立即想到git代码回滚。嗯，解决的过程中，导师问我“你是想报复社会嘛”，emmmmm，其实，，，没想报复社会。。。也没想删库跑路。。。哭唧唧········回归正题——\n\n<!--more-->\n  1. 首先，你需要打印出你之前所有的commit-id，选择你要回滚到哪一个版本，命令：git log\n  2. 接下来，执行git reset --soft commit-id，如果出现如下图所示的fatal，那就继续接着搞吧\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE2affa77461fd6eee11c2b4e2c0d25ced/3232)\n3. 上一步的结果说明你还在合并,所以需要把当前目录所有修改的文件从HEAD中迁出并且把它回复称未修改时的样子\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCEeddda71d5ba6de35beebbcc09374979f/3238)\n4.在查看状态git status，可以看到提示你执行下面红框中的命令\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE2fe57c806552e3fc48bf856682d7c1f1/3245)\n5. 执行git revert --abort之后查看状态，没有问题之后就可以回滚了\n6. 执行git reset --soft commit-id，再去查看状态就可以看到自己刚刚都删了哪些内容\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE6e6cb09e30a1465150a6f11f5d707ddb/3251)\n7. 根据提示再执行git reset HEAD .，这一步的意思是可以把暂存区的修改撤销掉（unstage），重新放回工作区\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCEf83a997190a7c97779b7ec8bccde668c/3257)\n8. 继续使用git status查看这些文件处于什么状态，可以看到是not staged，提示我们执行git checkout\n恢复原态\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE1f4ae4ddf5fe7c60e0e8e6d9bdc30e86/3263)\n9. 完了git add将工作区的提到暂存区并且提交commit\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCEabc235dfe557b048f5f728fefe7fb0cb/3276)\n10. 再执行git pull，git push到远程分支，就ok啦~\n","source":"_posts/git代码回滚.md","raw":"---\ntitle: git代码回滚\ndate: 2018-05-16 21:09:31\ntags: \n- 代码回滚\ncategories: git管理\nabout:\n---\n\n### 好了，记录一下今日的壮举。。。\n坐标：百度大厦C座      时间：2018-05-16      \n事件起因：上次的需求提交多提交了一个不必要的包导师缺陷检测有6个问题不能merge，所以今日在本地删除包之后提交代码，又因为对git操作的不熟悉，对untracked的deleted的文件执行了\"git rm -r .\"，然后就很尴尬了。。。我就看着我的VSCode的资源管理器那一栏噌噌噌地没了。。。但是还有部分没有删除。emmmmm，立即想到git代码回滚。嗯，解决的过程中，导师问我“你是想报复社会嘛”，emmmmm，其实，，，没想报复社会。。。也没想删库跑路。。。哭唧唧········回归正题——\n\n<!--more-->\n  1. 首先，你需要打印出你之前所有的commit-id，选择你要回滚到哪一个版本，命令：git log\n  2. 接下来，执行git reset --soft commit-id，如果出现如下图所示的fatal，那就继续接着搞吧\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE2affa77461fd6eee11c2b4e2c0d25ced/3232)\n3. 上一步的结果说明你还在合并,所以需要把当前目录所有修改的文件从HEAD中迁出并且把它回复称未修改时的样子\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCEeddda71d5ba6de35beebbcc09374979f/3238)\n4.在查看状态git status，可以看到提示你执行下面红框中的命令\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE2fe57c806552e3fc48bf856682d7c1f1/3245)\n5. 执行git revert --abort之后查看状态，没有问题之后就可以回滚了\n6. 执行git reset --soft commit-id，再去查看状态就可以看到自己刚刚都删了哪些内容\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE6e6cb09e30a1465150a6f11f5d707ddb/3251)\n7. 根据提示再执行git reset HEAD .，这一步的意思是可以把暂存区的修改撤销掉（unstage），重新放回工作区\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCEf83a997190a7c97779b7ec8bccde668c/3257)\n8. 继续使用git status查看这些文件处于什么状态，可以看到是not staged，提示我们执行git checkout\n恢复原态\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE1f4ae4ddf5fe7c60e0e8e6d9bdc30e86/3263)\n9. 完了git add将工作区的提到暂存区并且提交commit\n![](https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCEabc235dfe557b048f5f728fefe7fb0cb/3276)\n10. 再执行git pull，git push到远程分支，就ok啦~\n","slug":"git代码回滚","published":1,"updated":"2019-02-22T08:37:33.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugrok0008vrietsij4wt5","content":"<h3 id=\"好了，记录一下今日的壮举。。。\"><a href=\"#好了，记录一下今日的壮举。。。\" class=\"headerlink\" title=\"好了，记录一下今日的壮举。。。\"></a>好了，记录一下今日的壮举。。。</h3><p>坐标：百度大厦C座      时间：2018-05-16<br>事件起因：上次的需求提交多提交了一个不必要的包导师缺陷检测有6个问题不能merge，所以今日在本地删除包之后提交代码，又因为对git操作的不熟悉，对untracked的deleted的文件执行了”git rm -r .”，然后就很尴尬了。。。我就看着我的VSCode的资源管理器那一栏噌噌噌地没了。。。但是还有部分没有删除。emmmmm，立即想到git代码回滚。嗯，解决的过程中，导师问我“你是想报复社会嘛”，emmmmm，其实，，，没想报复社会。。。也没想删库跑路。。。哭唧唧········回归正题——</p>\n<a id=\"more\"></a>\n<ol>\n<li>首先，你需要打印出你之前所有的commit-id，选择你要回滚到哪一个版本，命令：git log</li>\n<li>接下来，执行git reset –soft commit-id，如果出现如下图所示的fatal，那就继续接着搞吧<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE2affa77461fd6eee11c2b4e2c0d25ced/3232\" alt><ol start=\"3\">\n<li>上一步的结果说明你还在合并,所以需要把当前目录所有修改的文件从HEAD中迁出并且把它回复称未修改时的样子<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCEeddda71d5ba6de35beebbcc09374979f/3238\" alt><br>4.在查看状态git status，可以看到提示你执行下面红框中的命令<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE2fe57c806552e3fc48bf856682d7c1f1/3245\" alt></li>\n<li>执行git revert –abort之后查看状态，没有问题之后就可以回滚了</li>\n<li>执行git reset –soft commit-id，再去查看状态就可以看到自己刚刚都删了哪些内容<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE6e6cb09e30a1465150a6f11f5d707ddb/3251\" alt></li>\n<li>根据提示再执行git reset HEAD .，这一步的意思是可以把暂存区的修改撤销掉（unstage），重新放回工作区<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCEf83a997190a7c97779b7ec8bccde668c/3257\" alt></li>\n<li>继续使用git status查看这些文件处于什么状态，可以看到是not staged，提示我们执行git checkout<br>恢复原态<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE1f4ae4ddf5fe7c60e0e8e6d9bdc30e86/3263\" alt></li>\n<li>完了git add将工作区的提到暂存区并且提交commit<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCEabc235dfe557b048f5f728fefe7fb0cb/3276\" alt></li>\n<li>再执行git pull，git push到远程分支，就ok啦~</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"好了，记录一下今日的壮举。。。\"><a href=\"#好了，记录一下今日的壮举。。。\" class=\"headerlink\" title=\"好了，记录一下今日的壮举。。。\"></a>好了，记录一下今日的壮举。。。</h3><p>坐标：百度大厦C座      时间：2018-05-16<br>事件起因：上次的需求提交多提交了一个不必要的包导师缺陷检测有6个问题不能merge，所以今日在本地删除包之后提交代码，又因为对git操作的不熟悉，对untracked的deleted的文件执行了”git rm -r .”，然后就很尴尬了。。。我就看着我的VSCode的资源管理器那一栏噌噌噌地没了。。。但是还有部分没有删除。emmmmm，立即想到git代码回滚。嗯，解决的过程中，导师问我“你是想报复社会嘛”，emmmmm，其实，，，没想报复社会。。。也没想删库跑路。。。哭唧唧········回归正题——</p>","more":"<ol>\n<li>首先，你需要打印出你之前所有的commit-id，选择你要回滚到哪一个版本，命令：git log</li>\n<li>接下来，执行git reset –soft commit-id，如果出现如下图所示的fatal，那就继续接着搞吧<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE2affa77461fd6eee11c2b4e2c0d25ced/3232\" alt><ol start=\"3\">\n<li>上一步的结果说明你还在合并,所以需要把当前目录所有修改的文件从HEAD中迁出并且把它回复称未修改时的样子<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCEeddda71d5ba6de35beebbcc09374979f/3238\" alt><br>4.在查看状态git status，可以看到提示你执行下面红框中的命令<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE2fe57c806552e3fc48bf856682d7c1f1/3245\" alt></li>\n<li>执行git revert –abort之后查看状态，没有问题之后就可以回滚了</li>\n<li>执行git reset –soft commit-id，再去查看状态就可以看到自己刚刚都删了哪些内容<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE6e6cb09e30a1465150a6f11f5d707ddb/3251\" alt></li>\n<li>根据提示再执行git reset HEAD .，这一步的意思是可以把暂存区的修改撤销掉（unstage），重新放回工作区<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCEf83a997190a7c97779b7ec8bccde668c/3257\" alt></li>\n<li>继续使用git status查看这些文件处于什么状态，可以看到是not staged，提示我们执行git checkout<br>恢复原态<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCE1f4ae4ddf5fe7c60e0e8e6d9bdc30e86/3263\" alt></li>\n<li>完了git add将工作区的提到暂存区并且提交commit<br><img src=\"https://note.youdao.com/yws/public/resource/3960d39c9b71e504ffd66863a26cdcc9/xmlnote/WEBRESOURCEabc235dfe557b048f5f728fefe7fb0cb/3276\" alt></li>\n<li>再执行git pull，git push到远程分支，就ok啦~</li>\n</ol>\n</li>\n</ol>"},{"title":"test","date":"2019-02-22T09:14:18.000Z","about":null,"_content":"","source":"_posts/test.md","raw":"---\ntitle: test\ndate: 2019-02-22 17:14:18\ntags:\ncategories:\nabout:\n---\n","slug":"test","published":1,"updated":"2019-02-22T09:14:18.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugrol0009vrie89ljvabc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"webpack和gulp的区别","date":"2018-05-24T07:18:49.000Z","about":null,"_content":"webpack和gulp的区别的话，我是这么理解的：\n> gulp是个自动化构建的工具，gulp所做的工作就是对指定文件的代码进行压缩合并或者资源打包，所以我一般会在自己的个人项目规模不是很大的时候使用gulp来构建，完了在页面中引用就行了，这样子的目的就是单纯的减小文件体积；\n\n而webpack我觉得就拿我们这个SPA项目来看的话：\n<!--more-->\n\n> 1. 我们需要配置一个entry指明执行入口，找到每个文件所依赖的文件，递归下去，在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换，并将最后递归得到的结果根据entry配置生成代码块chunk，然后输出chunk到文件系统\n> 2. 我们引用了比较多的第三方库，那如果将这些类库在页面中分别引用，请求页面的时候，可能浏览器要发起多次请求，但是可能每一次的请求都是一小段的js代码或者很小的图片，本身可能才几k左右，下载可能只要1秒，但是http请求发送之前我们得先建立tcp连接，tcp的三握四挥消耗的时间比下载资源本身还要长，所以如果我们把这些文件都打包成一个文件，那么只进行一次tcp握手和挥手的过程，但是相应的结果是下载了多个资源，他们共享同一个http请求，让页面加载更快，用户体验更佳，这部分就是可以减少页面请求时间\n> 3. 而且针对于第三方库，像Vue或者React这种体系库会包含有像其对应的状态管理库和路由管理库，这个时候webpack就可以让我们抽出这些基础库到一个单独的文件而不是和其他文件放在一起打包为一个文件，这样做的好处就是即便我们不去升级他们的版本就永远不会被刷新，但是如果我们把他们这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件hash值变化紧接着导致浏览器缓存失效，那浏览器就会重复下载这些包含基础库的代码，所以这部分的话我们就可以利用webpack做代码分割的优化\n\n当然webpack也不止这些功能，他也有诸多插件，比如热加载呀，自动刷新呀都是很方便的。","source":"_posts/webpack和gulp的区别.md","raw":"---\ntitle: webpack和gulp的区别\ndate: 2018-05-24 15:18:49\ntags:\n- webpack\n- gulp\ncategories: 前端构建工具\nabout:\n---\nwebpack和gulp的区别的话，我是这么理解的：\n> gulp是个自动化构建的工具，gulp所做的工作就是对指定文件的代码进行压缩合并或者资源打包，所以我一般会在自己的个人项目规模不是很大的时候使用gulp来构建，完了在页面中引用就行了，这样子的目的就是单纯的减小文件体积；\n\n而webpack我觉得就拿我们这个SPA项目来看的话：\n<!--more-->\n\n> 1. 我们需要配置一个entry指明执行入口，找到每个文件所依赖的文件，递归下去，在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换，并将最后递归得到的结果根据entry配置生成代码块chunk，然后输出chunk到文件系统\n> 2. 我们引用了比较多的第三方库，那如果将这些类库在页面中分别引用，请求页面的时候，可能浏览器要发起多次请求，但是可能每一次的请求都是一小段的js代码或者很小的图片，本身可能才几k左右，下载可能只要1秒，但是http请求发送之前我们得先建立tcp连接，tcp的三握四挥消耗的时间比下载资源本身还要长，所以如果我们把这些文件都打包成一个文件，那么只进行一次tcp握手和挥手的过程，但是相应的结果是下载了多个资源，他们共享同一个http请求，让页面加载更快，用户体验更佳，这部分就是可以减少页面请求时间\n> 3. 而且针对于第三方库，像Vue或者React这种体系库会包含有像其对应的状态管理库和路由管理库，这个时候webpack就可以让我们抽出这些基础库到一个单独的文件而不是和其他文件放在一起打包为一个文件，这样做的好处就是即便我们不去升级他们的版本就永远不会被刷新，但是如果我们把他们这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件hash值变化紧接着导致浏览器缓存失效，那浏览器就会重复下载这些包含基础库的代码，所以这部分的话我们就可以利用webpack做代码分割的优化\n\n当然webpack也不止这些功能，他也有诸多插件，比如热加载呀，自动刷新呀都是很方便的。","slug":"webpack和gulp的区别","published":1,"updated":"2019-02-22T08:37:33.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugrom000cvrie5vq7rnnt","content":"<p>webpack和gulp的区别的话，我是这么理解的：</p>\n<blockquote>\n<p>gulp是个自动化构建的工具，gulp所做的工作就是对指定文件的代码进行压缩合并或者资源打包，所以我一般会在自己的个人项目规模不是很大的时候使用gulp来构建，完了在页面中引用就行了，这样子的目的就是单纯的减小文件体积；</p>\n</blockquote>\n<p>而webpack我觉得就拿我们这个SPA项目来看的话：<br><a id=\"more\"></a></p>\n<blockquote>\n<ol>\n<li>我们需要配置一个entry指明执行入口，找到每个文件所依赖的文件，递归下去，在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换，并将最后递归得到的结果根据entry配置生成代码块chunk，然后输出chunk到文件系统</li>\n<li>我们引用了比较多的第三方库，那如果将这些类库在页面中分别引用，请求页面的时候，可能浏览器要发起多次请求，但是可能每一次的请求都是一小段的js代码或者很小的图片，本身可能才几k左右，下载可能只要1秒，但是http请求发送之前我们得先建立tcp连接，tcp的三握四挥消耗的时间比下载资源本身还要长，所以如果我们把这些文件都打包成一个文件，那么只进行一次tcp握手和挥手的过程，但是相应的结果是下载了多个资源，他们共享同一个http请求，让页面加载更快，用户体验更佳，这部分就是可以减少页面请求时间</li>\n<li>而且针对于第三方库，像Vue或者React这种体系库会包含有像其对应的状态管理库和路由管理库，这个时候webpack就可以让我们抽出这些基础库到一个单独的文件而不是和其他文件放在一起打包为一个文件，这样做的好处就是即便我们不去升级他们的版本就永远不会被刷新，但是如果我们把他们这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件hash值变化紧接着导致浏览器缓存失效，那浏览器就会重复下载这些包含基础库的代码，所以这部分的话我们就可以利用webpack做代码分割的优化</li>\n</ol>\n</blockquote>\n<p>当然webpack也不止这些功能，他也有诸多插件，比如热加载呀，自动刷新呀都是很方便的。</p>\n","site":{"data":{}},"excerpt":"<p>webpack和gulp的区别的话，我是这么理解的：</p>\n<blockquote>\n<p>gulp是个自动化构建的工具，gulp所做的工作就是对指定文件的代码进行压缩合并或者资源打包，所以我一般会在自己的个人项目规模不是很大的时候使用gulp来构建，完了在页面中引用就行了，这样子的目的就是单纯的减小文件体积；</p>\n</blockquote>\n<p>而webpack我觉得就拿我们这个SPA项目来看的话：<br>","more":"</p>\n<blockquote>\n<ol>\n<li>我们需要配置一个entry指明执行入口，找到每个文件所依赖的文件，递归下去，在解析文件递归的过程中根据文件类型和loader配置找出合适的loader用来对文件进行转换，并将最后递归得到的结果根据entry配置生成代码块chunk，然后输出chunk到文件系统</li>\n<li>我们引用了比较多的第三方库，那如果将这些类库在页面中分别引用，请求页面的时候，可能浏览器要发起多次请求，但是可能每一次的请求都是一小段的js代码或者很小的图片，本身可能才几k左右，下载可能只要1秒，但是http请求发送之前我们得先建立tcp连接，tcp的三握四挥消耗的时间比下载资源本身还要长，所以如果我们把这些文件都打包成一个文件，那么只进行一次tcp握手和挥手的过程，但是相应的结果是下载了多个资源，他们共享同一个http请求，让页面加载更快，用户体验更佳，这部分就是可以减少页面请求时间</li>\n<li>而且针对于第三方库，像Vue或者React这种体系库会包含有像其对应的状态管理库和路由管理库，这个时候webpack就可以让我们抽出这些基础库到一个单独的文件而不是和其他文件放在一起打包为一个文件，这样做的好处就是即便我们不去升级他们的版本就永远不会被刷新，但是如果我们把他们这些基础库和业务代码打包在一个文件里每次改动业务代码都会导致文件hash值变化紧接着导致浏览器缓存失效，那浏览器就会重复下载这些包含基础库的代码，所以这部分的话我们就可以利用webpack做代码分割的优化</li>\n</ol>\n</blockquote>\n<p>当然webpack也不止这些功能，他也有诸多插件，比如热加载呀，自动刷新呀都是很方便的。</p>"},{"title":"从ES5&ES6两方看继承(一)","date":"2018-05-10T13:56:36.000Z","about":null,"_content":"\n\n> ##### 原型和继承，是学习JS过程中相当重要并且难懂的点，第一次过这块的时候，完全是十脸懵逼的。之后因为准备春招，把这块的整个体系重新拜读了不下三次，才得以勉强面试。最近，也在学习ES6相关，看到Class的extend继承，就想对ES5的继承和ES6的继承做一比对和整理。好啦~正文开始······\n\n\n### 首先，ES5继承\n\n整理一下构造函数、原型对象和实例之间的关系：构造函数中有一个prototype的属性指向它自己的原型(prototype)对象，而原型对象中又有一个constructor属性指回构造函数，原型对象中定义实例共享的属性和方法，实例对象也总有一个prototype属性指向自己的默认原型对象。实例对象和原型对象均有__prpto__属性，它们的__proto__也都指向它的构造函数的原型对象。\n> 注：JS中所有对象都有自己的__proto__属性，隐式指针，也就是后文中的[[prototype]]\n\n<!--more-->\n\n#### 1. ES5继承之原型链[ 核心：将父类的实例作为子类的原型，即重写子类的原型 ]\n\n```\n// 实现模式\nfunction Father() {\n    this.property = true;\n}\n\nFather.prototype.getFatherPro = function() {\n    return this.property;\n}\n\nfunction Son() {\n    this.sonProperty = false;\n}\n\n// Son继承了Father\nSon.prototype = new Father();\n\nSon.prototype.getSonPro = function() {\n    return this.sonProperty;\n}\n\nvar instance = new Son();\nconsole.log(instance.getFatherPro); // true\n\n```\n![](https://note.youdao.com/yws/public/resource/c1554b4563a4504a4b47be66421ba010/xmlnote/WEBRESOURCE1c5ea84c6c60b09c19ba3974de065153/2699)\n\n> 这个代码中，我们改写了Son的原型，这个新原型是Father的实例，而Father的实例的prototype是指向Father Prototype的，所以新原型具有Father的实例拥有的所有属性（property）和方法，而我们后面也给它的新原型添加了方法getSonPro()，所以，在new出来Son的实例instance时，instance的prototype指向Son Prototype，并拥有Son的属性sonProperty和Son Prototype上的属性和方法，自然就可以调用getSonPro并打印出结果。\n\n#### ！！！敲黑板啦~——默认原型，前面的原型链还少一环，就是Father Prototype的[[prototype]]指向Object Prototype，而Object Prototype的[[prototype]]指向null。\n\n##### 确定原型和实例的关系\n1. instanceOf\n2. isPrototypeOf()\n\n> 原型链继承的问题：\n> 1. 因为包含引用类型值的原型属性会被所有实例共享，所以我们一般都是在构造函数中定义属性。通过原型来继承的时候，因为子类的原型实际上是父类的实例，所以父类实例的属性就会变成子类的原型属性，那么子类的所有实例都会共享子类原型上的属性也就是父类上的属性，当子类实例访问或者改变这个属性的时候，也会反映在其他实例上。\n> 2. 在创建子类的实例时不能向父类的构造函数中传递参数。\n\n---\n\n#### 2. ES5继承之借用构造函数[ 核心：子类的构造函数中调用父类的构造函数 ]\n\n```\nfunction Father() {\n    this.arr = [1, 2, 3, 4];\n}\n\nfunction Son() {\n    // 继承Father\n    Father.call(this);\n}\n\nvar instance1 = new Son();\ninstance1.arr.push(5);\nconsole.log(instance1.arr); // [1, 2, 3, 4, 5]\n\nvar instance2 = new Son();\nconsole.log(instance2.arr); // [1, 2, 3, 4]\n```\n> call和apply方法的作用就是在（将来）新创建的实例对象上执行构造函数，所以每个实例对象都会有自己的属性副本，不会影响到所有实例都是相同的属性。而且，借用构造函数还有一个大优势就是可以在子类构造函数中向父类构造函数传参。\n\n\n```\nfunction Father(name) {\n    this.name = name;\n}\n\nfunction Son() {\n    // 继承Father，传入参数\n    Father.call(this, 'zyy');\n    \n    // 实例属性\n    this.age = 21;\n}\n\nvar instance = new Son();\nconsole.log(instance.name); // zyy\nconsole.log(instance.age); // 21\n```\n> 构造函数的问题：\n> 1. 方法都在构造函数中定义，函数复用就无法实现。\n> 2. 在父类原型中定义的方法对于子类而言是不可见的，所以所有类型只能使用构造函数模式。\n\n#### 3. ES5继承之组合继承[ 核心：结合构造函数和原型链，即使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承 ]\n*以最典型的AJAX为例*\n\n```\nfunction Ajax(obj) {\n    this.url = obj.url;\n    this.async = obj.async;\n    this.data = obj.data || '';\n    this.method = obj.method || 'GET';\n    this.dataType = obj.dataTpye;\n    this.success = obj.success;\n    this.error = obj.error;\n    this.timeout = obj.timeout || 0;\n    this.xml = null;\n    this.init();\n}\n\nAjax.prototype = {\n    constructor: Ajax,\n    init: function() {\n        this.createXml();\n    },\n    createXml: function() {\n        ······\n        this.spliceParams();\n        this.dataType();\n    },\n    spliceParams: function() {\n        ······\n        this.data = arr;\n    },\n    dataType: function() {\n        ······\n    }\n}\n\nwindow.Ajax = function(data) {\n    return new Ajax(data);\n}\n```\n> 组合继承的优点：酱紫结合的结果就是所有实例都共享原型对象上的方法，但是又拥有自己独有的属性~\n\n#### 4. ES5继承之原型式继承[ 核心：借助原型基于已有的对象创建新对象 ]\n\n```\nfunction createObj(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nvar person = {\n    name: 'zyy',\n    friends: ['miao', 'pm']\n}\n\nvar person1 = createObj(person);\nvar person2 = createObj(person);\n\nperson1.name = 'person1';\nconsole.log(person1.name); // person1\nconsole.log(person2.name); // zyy\n\nperson1.friends.push('tuo');\nconsole.log(person2.friends); // [\"miao\", \"pm\", \"tuo\"]\n```\n> 原型继承的问题：\n> 1. 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。\n> 2. 上例代码中的person2的friends和person1的一样，而name不同就是因为，包含引用类型的属性值会共享。\n\n#### 5. ES5继承之寄生式继承[ 仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象 ]\n\n```\nfunction createObj (o) {\n    var clone = Object.create(o);\n    clone.sayHi = function () {\n        console.log('hi');\n    }\n    return clone;\n}\n\nvar person = {\n    name: 'zyy',\n    friends: ['miao', 'pm', 'tuo']\n};\n\nvar anotherPerson = createObj(person);\nanotherPerson.sayHi(); // hi\n```\n> 寄生式继承的问题：跟借用构造函数模式一样，每次创建对象都会创建一遍方法\n\n#### 6. ES5继承之寄生组合式继承\n> 组合继承最大的缺点是会调用两次父构造函数。\n一次是设置子类型实例的原型的时候，一次在创建子类型实例的时候。\n\n\n```\nfunction object(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nfunction prototype(child, parent) {\n    var prototype = object(parent.prototype);\n    prototype.constructor = child;\n    child.prototype = prototype;\n}\n\n// 当我们使用的时候：\nprototype(Child, Parent);\n```\n> 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。\n\n","source":"_posts/从ES5&ES6两方看继承(一).md","raw":"---\ntitle: 从ES5&ES6两方看继承(一)\ndate: 2018-05-10 21:56:36\ntags:\n- 对象 \n- 原型 \n- 继承\ncategories: ES5\nabout:\n---\n\n\n> ##### 原型和继承，是学习JS过程中相当重要并且难懂的点，第一次过这块的时候，完全是十脸懵逼的。之后因为准备春招，把这块的整个体系重新拜读了不下三次，才得以勉强面试。最近，也在学习ES6相关，看到Class的extend继承，就想对ES5的继承和ES6的继承做一比对和整理。好啦~正文开始······\n\n\n### 首先，ES5继承\n\n整理一下构造函数、原型对象和实例之间的关系：构造函数中有一个prototype的属性指向它自己的原型(prototype)对象，而原型对象中又有一个constructor属性指回构造函数，原型对象中定义实例共享的属性和方法，实例对象也总有一个prototype属性指向自己的默认原型对象。实例对象和原型对象均有__prpto__属性，它们的__proto__也都指向它的构造函数的原型对象。\n> 注：JS中所有对象都有自己的__proto__属性，隐式指针，也就是后文中的[[prototype]]\n\n<!--more-->\n\n#### 1. ES5继承之原型链[ 核心：将父类的实例作为子类的原型，即重写子类的原型 ]\n\n```\n// 实现模式\nfunction Father() {\n    this.property = true;\n}\n\nFather.prototype.getFatherPro = function() {\n    return this.property;\n}\n\nfunction Son() {\n    this.sonProperty = false;\n}\n\n// Son继承了Father\nSon.prototype = new Father();\n\nSon.prototype.getSonPro = function() {\n    return this.sonProperty;\n}\n\nvar instance = new Son();\nconsole.log(instance.getFatherPro); // true\n\n```\n![](https://note.youdao.com/yws/public/resource/c1554b4563a4504a4b47be66421ba010/xmlnote/WEBRESOURCE1c5ea84c6c60b09c19ba3974de065153/2699)\n\n> 这个代码中，我们改写了Son的原型，这个新原型是Father的实例，而Father的实例的prototype是指向Father Prototype的，所以新原型具有Father的实例拥有的所有属性（property）和方法，而我们后面也给它的新原型添加了方法getSonPro()，所以，在new出来Son的实例instance时，instance的prototype指向Son Prototype，并拥有Son的属性sonProperty和Son Prototype上的属性和方法，自然就可以调用getSonPro并打印出结果。\n\n#### ！！！敲黑板啦~——默认原型，前面的原型链还少一环，就是Father Prototype的[[prototype]]指向Object Prototype，而Object Prototype的[[prototype]]指向null。\n\n##### 确定原型和实例的关系\n1. instanceOf\n2. isPrototypeOf()\n\n> 原型链继承的问题：\n> 1. 因为包含引用类型值的原型属性会被所有实例共享，所以我们一般都是在构造函数中定义属性。通过原型来继承的时候，因为子类的原型实际上是父类的实例，所以父类实例的属性就会变成子类的原型属性，那么子类的所有实例都会共享子类原型上的属性也就是父类上的属性，当子类实例访问或者改变这个属性的时候，也会反映在其他实例上。\n> 2. 在创建子类的实例时不能向父类的构造函数中传递参数。\n\n---\n\n#### 2. ES5继承之借用构造函数[ 核心：子类的构造函数中调用父类的构造函数 ]\n\n```\nfunction Father() {\n    this.arr = [1, 2, 3, 4];\n}\n\nfunction Son() {\n    // 继承Father\n    Father.call(this);\n}\n\nvar instance1 = new Son();\ninstance1.arr.push(5);\nconsole.log(instance1.arr); // [1, 2, 3, 4, 5]\n\nvar instance2 = new Son();\nconsole.log(instance2.arr); // [1, 2, 3, 4]\n```\n> call和apply方法的作用就是在（将来）新创建的实例对象上执行构造函数，所以每个实例对象都会有自己的属性副本，不会影响到所有实例都是相同的属性。而且，借用构造函数还有一个大优势就是可以在子类构造函数中向父类构造函数传参。\n\n\n```\nfunction Father(name) {\n    this.name = name;\n}\n\nfunction Son() {\n    // 继承Father，传入参数\n    Father.call(this, 'zyy');\n    \n    // 实例属性\n    this.age = 21;\n}\n\nvar instance = new Son();\nconsole.log(instance.name); // zyy\nconsole.log(instance.age); // 21\n```\n> 构造函数的问题：\n> 1. 方法都在构造函数中定义，函数复用就无法实现。\n> 2. 在父类原型中定义的方法对于子类而言是不可见的，所以所有类型只能使用构造函数模式。\n\n#### 3. ES5继承之组合继承[ 核心：结合构造函数和原型链，即使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承 ]\n*以最典型的AJAX为例*\n\n```\nfunction Ajax(obj) {\n    this.url = obj.url;\n    this.async = obj.async;\n    this.data = obj.data || '';\n    this.method = obj.method || 'GET';\n    this.dataType = obj.dataTpye;\n    this.success = obj.success;\n    this.error = obj.error;\n    this.timeout = obj.timeout || 0;\n    this.xml = null;\n    this.init();\n}\n\nAjax.prototype = {\n    constructor: Ajax,\n    init: function() {\n        this.createXml();\n    },\n    createXml: function() {\n        ······\n        this.spliceParams();\n        this.dataType();\n    },\n    spliceParams: function() {\n        ······\n        this.data = arr;\n    },\n    dataType: function() {\n        ······\n    }\n}\n\nwindow.Ajax = function(data) {\n    return new Ajax(data);\n}\n```\n> 组合继承的优点：酱紫结合的结果就是所有实例都共享原型对象上的方法，但是又拥有自己独有的属性~\n\n#### 4. ES5继承之原型式继承[ 核心：借助原型基于已有的对象创建新对象 ]\n\n```\nfunction createObj(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nvar person = {\n    name: 'zyy',\n    friends: ['miao', 'pm']\n}\n\nvar person1 = createObj(person);\nvar person2 = createObj(person);\n\nperson1.name = 'person1';\nconsole.log(person1.name); // person1\nconsole.log(person2.name); // zyy\n\nperson1.friends.push('tuo');\nconsole.log(person2.friends); // [\"miao\", \"pm\", \"tuo\"]\n```\n> 原型继承的问题：\n> 1. 包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。\n> 2. 上例代码中的person2的friends和person1的一样，而name不同就是因为，包含引用类型的属性值会共享。\n\n#### 5. ES5继承之寄生式继承[ 仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象 ]\n\n```\nfunction createObj (o) {\n    var clone = Object.create(o);\n    clone.sayHi = function () {\n        console.log('hi');\n    }\n    return clone;\n}\n\nvar person = {\n    name: 'zyy',\n    friends: ['miao', 'pm', 'tuo']\n};\n\nvar anotherPerson = createObj(person);\nanotherPerson.sayHi(); // hi\n```\n> 寄生式继承的问题：跟借用构造函数模式一样，每次创建对象都会创建一遍方法\n\n#### 6. ES5继承之寄生组合式继承\n> 组合继承最大的缺点是会调用两次父构造函数。\n一次是设置子类型实例的原型的时候，一次在创建子类型实例的时候。\n\n\n```\nfunction object(o) {\n    function F() {}\n    F.prototype = o;\n    return new F();\n}\n\nfunction prototype(child, parent) {\n    var prototype = object(parent.prototype);\n    prototype.constructor = child;\n    child.prototype = prototype;\n}\n\n// 当我们使用的时候：\nprototype(Child, Parent);\n```\n> 这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。\n\n","slug":"从ES5&ES6两方看继承(一)","published":1,"updated":"2019-02-22T08:37:33.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugron000dvries9bfleea","content":"<blockquote>\n<h5 id=\"原型和继承，是学习JS过程中相当重要并且难懂的点，第一次过这块的时候，完全是十脸懵逼的。之后因为准备春招，把这块的整个体系重新拜读了不下三次，才得以勉强面试。最近，也在学习ES6相关，看到Class的extend继承，就想对ES5的继承和ES6的继承做一比对和整理。好啦-正文开始······\"><a href=\"#原型和继承，是学习JS过程中相当重要并且难懂的点，第一次过这块的时候，完全是十脸懵逼的。之后因为准备春招，把这块的整个体系重新拜读了不下三次，才得以勉强面试。最近，也在学习ES6相关，看到Class的extend继承，就想对ES5的继承和ES6的继承做一比对和整理。好啦-正文开始······\" class=\"headerlink\" title=\"原型和继承，是学习JS过程中相当重要并且难懂的点，第一次过这块的时候，完全是十脸懵逼的。之后因为准备春招，把这块的整个体系重新拜读了不下三次，才得以勉强面试。最近，也在学习ES6相关，看到Class的extend继承，就想对ES5的继承和ES6的继承做一比对和整理。好啦~正文开始······\"></a>原型和继承，是学习JS过程中相当重要并且难懂的点，第一次过这块的时候，完全是十脸懵逼的。之后因为准备春招，把这块的整个体系重新拜读了不下三次，才得以勉强面试。最近，也在学习ES6相关，看到Class的extend继承，就想对ES5的继承和ES6的继承做一比对和整理。好啦~正文开始······</h5></blockquote>\n<h3 id=\"首先，ES5继承\"><a href=\"#首先，ES5继承\" class=\"headerlink\" title=\"首先，ES5继承\"></a>首先，ES5继承</h3><p>整理一下构造函数、原型对象和实例之间的关系：构造函数中有一个prototype的属性指向它自己的原型(prototype)对象，而原型对象中又有一个constructor属性指回构造函数，原型对象中定义实例共享的属性和方法，实例对象也总有一个prototype属性指向自己的默认原型对象。实例对象和原型对象均有<strong>prpto</strong>属性，它们的<strong>proto</strong>也都指向它的构造函数的原型对象。</p>\n<blockquote>\n<p>注：JS中所有对象都有自己的<strong>proto</strong>属性，隐式指针，也就是后文中的[[prototype]]</p>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"1-ES5继承之原型链-核心：将父类的实例作为子类的原型，即重写子类的原型\"><a href=\"#1-ES5继承之原型链-核心：将父类的实例作为子类的原型，即重写子类的原型\" class=\"headerlink\" title=\"1. ES5继承之原型链[ 核心：将父类的实例作为子类的原型，即重写子类的原型 ]\"></a>1. ES5继承之原型链[ 核心：将父类的实例作为子类的原型，即重写子类的原型 ]</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 实现模式</span><br><span class=\"line\">function Father() &#123;</span><br><span class=\"line\">    this.property = true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Father.prototype.getFatherPro = function() &#123;</span><br><span class=\"line\">    return this.property;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Son() &#123;</span><br><span class=\"line\">    this.sonProperty = false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Son继承了Father</span><br><span class=\"line\">Son.prototype = new Father();</span><br><span class=\"line\"></span><br><span class=\"line\">Son.prototype.getSonPro = function() &#123;</span><br><span class=\"line\">    return this.sonProperty;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var instance = new Son();</span><br><span class=\"line\">console.log(instance.getFatherPro); // true</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/public/resource/c1554b4563a4504a4b47be66421ba010/xmlnote/WEBRESOURCE1c5ea84c6c60b09c19ba3974de065153/2699\" alt></p>\n<blockquote>\n<p>这个代码中，我们改写了Son的原型，这个新原型是Father的实例，而Father的实例的prototype是指向Father Prototype的，所以新原型具有Father的实例拥有的所有属性（property）和方法，而我们后面也给它的新原型添加了方法getSonPro()，所以，在new出来Son的实例instance时，instance的prototype指向Son Prototype，并拥有Son的属性sonProperty和Son Prototype上的属性和方法，自然就可以调用getSonPro并打印出结果。</p>\n</blockquote>\n<h4 id=\"！！！敲黑板啦-——默认原型，前面的原型链还少一环，就是Father-Prototype的-prototype-指向Object-Prototype，而Object-Prototype的-prototype-指向null。\"><a href=\"#！！！敲黑板啦-——默认原型，前面的原型链还少一环，就是Father-Prototype的-prototype-指向Object-Prototype，而Object-Prototype的-prototype-指向null。\" class=\"headerlink\" title=\"！！！敲黑板啦~——默认原型，前面的原型链还少一环，就是Father Prototype的[[prototype]]指向Object Prototype，而Object Prototype的[[prototype]]指向null。\"></a>！！！敲黑板啦~——默认原型，前面的原型链还少一环，就是Father Prototype的[[prototype]]指向Object Prototype，而Object Prototype的[[prototype]]指向null。</h4><h5 id=\"确定原型和实例的关系\"><a href=\"#确定原型和实例的关系\" class=\"headerlink\" title=\"确定原型和实例的关系\"></a>确定原型和实例的关系</h5><ol>\n<li>instanceOf</li>\n<li>isPrototypeOf()</li>\n</ol>\n<blockquote>\n<p>原型链继承的问题：</p>\n<ol>\n<li>因为包含引用类型值的原型属性会被所有实例共享，所以我们一般都是在构造函数中定义属性。通过原型来继承的时候，因为子类的原型实际上是父类的实例，所以父类实例的属性就会变成子类的原型属性，那么子类的所有实例都会共享子类原型上的属性也就是父类上的属性，当子类实例访问或者改变这个属性的时候，也会反映在其他实例上。</li>\n<li>在创建子类的实例时不能向父类的构造函数中传递参数。</li>\n</ol>\n</blockquote>\n<hr>\n<h4 id=\"2-ES5继承之借用构造函数-核心：子类的构造函数中调用父类的构造函数\"><a href=\"#2-ES5继承之借用构造函数-核心：子类的构造函数中调用父类的构造函数\" class=\"headerlink\" title=\"2. ES5继承之借用构造函数[ 核心：子类的构造函数中调用父类的构造函数 ]\"></a>2. ES5继承之借用构造函数[ 核心：子类的构造函数中调用父类的构造函数 ]</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Father() &#123;</span><br><span class=\"line\">    this.arr = [1, 2, 3, 4];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Son() &#123;</span><br><span class=\"line\">    // 继承Father</span><br><span class=\"line\">    Father.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var instance1 = new Son();</span><br><span class=\"line\">instance1.arr.push(5);</span><br><span class=\"line\">console.log(instance1.arr); // [1, 2, 3, 4, 5]</span><br><span class=\"line\"></span><br><span class=\"line\">var instance2 = new Son();</span><br><span class=\"line\">console.log(instance2.arr); // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>call和apply方法的作用就是在（将来）新创建的实例对象上执行构造函数，所以每个实例对象都会有自己的属性副本，不会影响到所有实例都是相同的属性。而且，借用构造函数还有一个大优势就是可以在子类构造函数中向父类构造函数传参。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Father(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Son() &#123;</span><br><span class=\"line\">    // 继承Father，传入参数</span><br><span class=\"line\">    Father.call(this, &apos;zyy&apos;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 实例属性</span><br><span class=\"line\">    this.age = 21;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var instance = new Son();</span><br><span class=\"line\">console.log(instance.name); // zyy</span><br><span class=\"line\">console.log(instance.age); // 21</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>构造函数的问题：</p>\n<ol>\n<li>方法都在构造函数中定义，函数复用就无法实现。</li>\n<li>在父类原型中定义的方法对于子类而言是不可见的，所以所有类型只能使用构造函数模式。</li>\n</ol>\n</blockquote>\n<h4 id=\"3-ES5继承之组合继承-核心：结合构造函数和原型链，即使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承\"><a href=\"#3-ES5继承之组合继承-核心：结合构造函数和原型链，即使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承\" class=\"headerlink\" title=\"3. ES5继承之组合继承[ 核心：结合构造函数和原型链，即使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承 ]\"></a>3. ES5继承之组合继承[ 核心：结合构造函数和原型链，即使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承 ]</h4><p><em>以最典型的AJAX为例</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Ajax(obj) &#123;</span><br><span class=\"line\">    this.url = obj.url;</span><br><span class=\"line\">    this.async = obj.async;</span><br><span class=\"line\">    this.data = obj.data || &apos;&apos;;</span><br><span class=\"line\">    this.method = obj.method || &apos;GET&apos;;</span><br><span class=\"line\">    this.dataType = obj.dataTpye;</span><br><span class=\"line\">    this.success = obj.success;</span><br><span class=\"line\">    this.error = obj.error;</span><br><span class=\"line\">    this.timeout = obj.timeout || 0;</span><br><span class=\"line\">    this.xml = null;</span><br><span class=\"line\">    this.init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Ajax.prototype = &#123;</span><br><span class=\"line\">    constructor: Ajax,</span><br><span class=\"line\">    init: function() &#123;</span><br><span class=\"line\">        this.createXml();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    createXml: function() &#123;</span><br><span class=\"line\">        ······</span><br><span class=\"line\">        this.spliceParams();</span><br><span class=\"line\">        this.dataType();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    spliceParams: function() &#123;</span><br><span class=\"line\">        ······</span><br><span class=\"line\">        this.data = arr;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    dataType: function() &#123;</span><br><span class=\"line\">        ······</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">window.Ajax = function(data) &#123;</span><br><span class=\"line\">    return new Ajax(data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>组合继承的优点：酱紫结合的结果就是所有实例都共享原型对象上的方法，但是又拥有自己独有的属性~</p>\n</blockquote>\n<h4 id=\"4-ES5继承之原型式继承-核心：借助原型基于已有的对象创建新对象\"><a href=\"#4-ES5继承之原型式继承-核心：借助原型基于已有的对象创建新对象\" class=\"headerlink\" title=\"4. ES5继承之原型式继承[ 核心：借助原型基于已有的对象创建新对象 ]\"></a>4. ES5继承之原型式继承[ 核心：借助原型基于已有的对象创建新对象 ]</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createObj(o) &#123;</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var person = &#123;</span><br><span class=\"line\">    name: &apos;zyy&apos;,</span><br><span class=\"line\">    friends: [&apos;miao&apos;, &apos;pm&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var person1 = createObj(person);</span><br><span class=\"line\">var person2 = createObj(person);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.name = &apos;person1&apos;;</span><br><span class=\"line\">console.log(person1.name); // person1</span><br><span class=\"line\">console.log(person2.name); // zyy</span><br><span class=\"line\"></span><br><span class=\"line\">person1.friends.push(&apos;tuo&apos;);</span><br><span class=\"line\">console.log(person2.friends); // [&quot;miao&quot;, &quot;pm&quot;, &quot;tuo&quot;]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>原型继承的问题：</p>\n<ol>\n<li>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</li>\n<li>上例代码中的person2的friends和person1的一样，而name不同就是因为，包含引用类型的属性值会共享。</li>\n</ol>\n</blockquote>\n<h4 id=\"5-ES5继承之寄生式继承-仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象\"><a href=\"#5-ES5继承之寄生式继承-仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象\" class=\"headerlink\" title=\"5. ES5继承之寄生式继承[ 仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象 ]\"></a>5. ES5继承之寄生式继承[ 仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象 ]</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createObj (o) &#123;</span><br><span class=\"line\">    var clone = Object.create(o);</span><br><span class=\"line\">    clone.sayHi = function () &#123;</span><br><span class=\"line\">        console.log(&apos;hi&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return clone;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var person = &#123;</span><br><span class=\"line\">    name: &apos;zyy&apos;,</span><br><span class=\"line\">    friends: [&apos;miao&apos;, &apos;pm&apos;, &apos;tuo&apos;]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var anotherPerson = createObj(person);</span><br><span class=\"line\">anotherPerson.sayHi(); // hi</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>寄生式继承的问题：跟借用构造函数模式一样，每次创建对象都会创建一遍方法</p>\n</blockquote>\n<h4 id=\"6-ES5继承之寄生组合式继承\"><a href=\"#6-ES5继承之寄生组合式继承\" class=\"headerlink\" title=\"6. ES5继承之寄生组合式继承\"></a>6. ES5继承之寄生组合式继承</h4><blockquote>\n<p>组合继承最大的缺点是会调用两次父构造函数。<br>一次是设置子类型实例的原型的时候，一次在创建子类型实例的时候。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function object(o) &#123;</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function prototype(child, parent) &#123;</span><br><span class=\"line\">    var prototype = object(parent.prototype);</span><br><span class=\"line\">    prototype.constructor = child;</span><br><span class=\"line\">    child.prototype = prototype;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当我们使用的时候：</span><br><span class=\"line\">prototype(Child, Parent);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<blockquote>\n<h5 id=\"原型和继承，是学习JS过程中相当重要并且难懂的点，第一次过这块的时候，完全是十脸懵逼的。之后因为准备春招，把这块的整个体系重新拜读了不下三次，才得以勉强面试。最近，也在学习ES6相关，看到Class的extend继承，就想对ES5的继承和ES6的继承做一比对和整理。好啦-正文开始······\"><a href=\"#原型和继承，是学习JS过程中相当重要并且难懂的点，第一次过这块的时候，完全是十脸懵逼的。之后因为准备春招，把这块的整个体系重新拜读了不下三次，才得以勉强面试。最近，也在学习ES6相关，看到Class的extend继承，就想对ES5的继承和ES6的继承做一比对和整理。好啦-正文开始······\" class=\"headerlink\" title=\"原型和继承，是学习JS过程中相当重要并且难懂的点，第一次过这块的时候，完全是十脸懵逼的。之后因为准备春招，把这块的整个体系重新拜读了不下三次，才得以勉强面试。最近，也在学习ES6相关，看到Class的extend继承，就想对ES5的继承和ES6的继承做一比对和整理。好啦~正文开始······\"></a>原型和继承，是学习JS过程中相当重要并且难懂的点，第一次过这块的时候，完全是十脸懵逼的。之后因为准备春招，把这块的整个体系重新拜读了不下三次，才得以勉强面试。最近，也在学习ES6相关，看到Class的extend继承，就想对ES5的继承和ES6的继承做一比对和整理。好啦~正文开始······</h5></blockquote>\n<h3 id=\"首先，ES5继承\"><a href=\"#首先，ES5继承\" class=\"headerlink\" title=\"首先，ES5继承\"></a>首先，ES5继承</h3><p>整理一下构造函数、原型对象和实例之间的关系：构造函数中有一个prototype的属性指向它自己的原型(prototype)对象，而原型对象中又有一个constructor属性指回构造函数，原型对象中定义实例共享的属性和方法，实例对象也总有一个prototype属性指向自己的默认原型对象。实例对象和原型对象均有<strong>prpto</strong>属性，它们的<strong>proto</strong>也都指向它的构造函数的原型对象。</p>\n<blockquote>\n<p>注：JS中所有对象都有自己的<strong>proto</strong>属性，隐式指针，也就是后文中的[[prototype]]</p>\n</blockquote>","more":"<h4 id=\"1-ES5继承之原型链-核心：将父类的实例作为子类的原型，即重写子类的原型\"><a href=\"#1-ES5继承之原型链-核心：将父类的实例作为子类的原型，即重写子类的原型\" class=\"headerlink\" title=\"1. ES5继承之原型链[ 核心：将父类的实例作为子类的原型，即重写子类的原型 ]\"></a>1. ES5继承之原型链[ 核心：将父类的实例作为子类的原型，即重写子类的原型 ]</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 实现模式</span><br><span class=\"line\">function Father() &#123;</span><br><span class=\"line\">    this.property = true;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Father.prototype.getFatherPro = function() &#123;</span><br><span class=\"line\">    return this.property;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Son() &#123;</span><br><span class=\"line\">    this.sonProperty = false;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// Son继承了Father</span><br><span class=\"line\">Son.prototype = new Father();</span><br><span class=\"line\"></span><br><span class=\"line\">Son.prototype.getSonPro = function() &#123;</span><br><span class=\"line\">    return this.sonProperty;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var instance = new Son();</span><br><span class=\"line\">console.log(instance.getFatherPro); // true</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://note.youdao.com/yws/public/resource/c1554b4563a4504a4b47be66421ba010/xmlnote/WEBRESOURCE1c5ea84c6c60b09c19ba3974de065153/2699\" alt></p>\n<blockquote>\n<p>这个代码中，我们改写了Son的原型，这个新原型是Father的实例，而Father的实例的prototype是指向Father Prototype的，所以新原型具有Father的实例拥有的所有属性（property）和方法，而我们后面也给它的新原型添加了方法getSonPro()，所以，在new出来Son的实例instance时，instance的prototype指向Son Prototype，并拥有Son的属性sonProperty和Son Prototype上的属性和方法，自然就可以调用getSonPro并打印出结果。</p>\n</blockquote>\n<h4 id=\"！！！敲黑板啦-——默认原型，前面的原型链还少一环，就是Father-Prototype的-prototype-指向Object-Prototype，而Object-Prototype的-prototype-指向null。\"><a href=\"#！！！敲黑板啦-——默认原型，前面的原型链还少一环，就是Father-Prototype的-prototype-指向Object-Prototype，而Object-Prototype的-prototype-指向null。\" class=\"headerlink\" title=\"！！！敲黑板啦~——默认原型，前面的原型链还少一环，就是Father Prototype的[[prototype]]指向Object Prototype，而Object Prototype的[[prototype]]指向null。\"></a>！！！敲黑板啦~——默认原型，前面的原型链还少一环，就是Father Prototype的[[prototype]]指向Object Prototype，而Object Prototype的[[prototype]]指向null。</h4><h5 id=\"确定原型和实例的关系\"><a href=\"#确定原型和实例的关系\" class=\"headerlink\" title=\"确定原型和实例的关系\"></a>确定原型和实例的关系</h5><ol>\n<li>instanceOf</li>\n<li>isPrototypeOf()</li>\n</ol>\n<blockquote>\n<p>原型链继承的问题：</p>\n<ol>\n<li>因为包含引用类型值的原型属性会被所有实例共享，所以我们一般都是在构造函数中定义属性。通过原型来继承的时候，因为子类的原型实际上是父类的实例，所以父类实例的属性就会变成子类的原型属性，那么子类的所有实例都会共享子类原型上的属性也就是父类上的属性，当子类实例访问或者改变这个属性的时候，也会反映在其他实例上。</li>\n<li>在创建子类的实例时不能向父类的构造函数中传递参数。</li>\n</ol>\n</blockquote>\n<hr>\n<h4 id=\"2-ES5继承之借用构造函数-核心：子类的构造函数中调用父类的构造函数\"><a href=\"#2-ES5继承之借用构造函数-核心：子类的构造函数中调用父类的构造函数\" class=\"headerlink\" title=\"2. ES5继承之借用构造函数[ 核心：子类的构造函数中调用父类的构造函数 ]\"></a>2. ES5继承之借用构造函数[ 核心：子类的构造函数中调用父类的构造函数 ]</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Father() &#123;</span><br><span class=\"line\">    this.arr = [1, 2, 3, 4];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Son() &#123;</span><br><span class=\"line\">    // 继承Father</span><br><span class=\"line\">    Father.call(this);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var instance1 = new Son();</span><br><span class=\"line\">instance1.arr.push(5);</span><br><span class=\"line\">console.log(instance1.arr); // [1, 2, 3, 4, 5]</span><br><span class=\"line\"></span><br><span class=\"line\">var instance2 = new Son();</span><br><span class=\"line\">console.log(instance2.arr); // [1, 2, 3, 4]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>call和apply方法的作用就是在（将来）新创建的实例对象上执行构造函数，所以每个实例对象都会有自己的属性副本，不会影响到所有实例都是相同的属性。而且，借用构造函数还有一个大优势就是可以在子类构造函数中向父类构造函数传参。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Father(name) &#123;</span><br><span class=\"line\">    this.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function Son() &#123;</span><br><span class=\"line\">    // 继承Father，传入参数</span><br><span class=\"line\">    Father.call(this, &apos;zyy&apos;);</span><br><span class=\"line\">    </span><br><span class=\"line\">    // 实例属性</span><br><span class=\"line\">    this.age = 21;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var instance = new Son();</span><br><span class=\"line\">console.log(instance.name); // zyy</span><br><span class=\"line\">console.log(instance.age); // 21</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>构造函数的问题：</p>\n<ol>\n<li>方法都在构造函数中定义，函数复用就无法实现。</li>\n<li>在父类原型中定义的方法对于子类而言是不可见的，所以所有类型只能使用构造函数模式。</li>\n</ol>\n</blockquote>\n<h4 id=\"3-ES5继承之组合继承-核心：结合构造函数和原型链，即使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承\"><a href=\"#3-ES5继承之组合继承-核心：结合构造函数和原型链，即使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承\" class=\"headerlink\" title=\"3. ES5继承之组合继承[ 核心：结合构造函数和原型链，即使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承 ]\"></a>3. ES5继承之组合继承[ 核心：结合构造函数和原型链，即使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承 ]</h4><p><em>以最典型的AJAX为例</em></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Ajax(obj) &#123;</span><br><span class=\"line\">    this.url = obj.url;</span><br><span class=\"line\">    this.async = obj.async;</span><br><span class=\"line\">    this.data = obj.data || &apos;&apos;;</span><br><span class=\"line\">    this.method = obj.method || &apos;GET&apos;;</span><br><span class=\"line\">    this.dataType = obj.dataTpye;</span><br><span class=\"line\">    this.success = obj.success;</span><br><span class=\"line\">    this.error = obj.error;</span><br><span class=\"line\">    this.timeout = obj.timeout || 0;</span><br><span class=\"line\">    this.xml = null;</span><br><span class=\"line\">    this.init();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Ajax.prototype = &#123;</span><br><span class=\"line\">    constructor: Ajax,</span><br><span class=\"line\">    init: function() &#123;</span><br><span class=\"line\">        this.createXml();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    createXml: function() &#123;</span><br><span class=\"line\">        ······</span><br><span class=\"line\">        this.spliceParams();</span><br><span class=\"line\">        this.dataType();</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    spliceParams: function() &#123;</span><br><span class=\"line\">        ······</span><br><span class=\"line\">        this.data = arr;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    dataType: function() &#123;</span><br><span class=\"line\">        ······</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">window.Ajax = function(data) &#123;</span><br><span class=\"line\">    return new Ajax(data);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>组合继承的优点：酱紫结合的结果就是所有实例都共享原型对象上的方法，但是又拥有自己独有的属性~</p>\n</blockquote>\n<h4 id=\"4-ES5继承之原型式继承-核心：借助原型基于已有的对象创建新对象\"><a href=\"#4-ES5继承之原型式继承-核心：借助原型基于已有的对象创建新对象\" class=\"headerlink\" title=\"4. ES5继承之原型式继承[ 核心：借助原型基于已有的对象创建新对象 ]\"></a>4. ES5继承之原型式继承[ 核心：借助原型基于已有的对象创建新对象 ]</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createObj(o) &#123;</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var person = &#123;</span><br><span class=\"line\">    name: &apos;zyy&apos;,</span><br><span class=\"line\">    friends: [&apos;miao&apos;, &apos;pm&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var person1 = createObj(person);</span><br><span class=\"line\">var person2 = createObj(person);</span><br><span class=\"line\"></span><br><span class=\"line\">person1.name = &apos;person1&apos;;</span><br><span class=\"line\">console.log(person1.name); // person1</span><br><span class=\"line\">console.log(person2.name); // zyy</span><br><span class=\"line\"></span><br><span class=\"line\">person1.friends.push(&apos;tuo&apos;);</span><br><span class=\"line\">console.log(person2.friends); // [&quot;miao&quot;, &quot;pm&quot;, &quot;tuo&quot;]</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>原型继承的问题：</p>\n<ol>\n<li>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</li>\n<li>上例代码中的person2的friends和person1的一样，而name不同就是因为，包含引用类型的属性值会共享。</li>\n</ol>\n</blockquote>\n<h4 id=\"5-ES5继承之寄生式继承-仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象\"><a href=\"#5-ES5继承之寄生式继承-仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象\" class=\"headerlink\" title=\"5. ES5继承之寄生式继承[ 仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象 ]\"></a>5. ES5继承之寄生式继承[ 仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象 ]</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createObj (o) &#123;</span><br><span class=\"line\">    var clone = Object.create(o);</span><br><span class=\"line\">    clone.sayHi = function () &#123;</span><br><span class=\"line\">        console.log(&apos;hi&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return clone;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var person = &#123;</span><br><span class=\"line\">    name: &apos;zyy&apos;,</span><br><span class=\"line\">    friends: [&apos;miao&apos;, &apos;pm&apos;, &apos;tuo&apos;]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var anotherPerson = createObj(person);</span><br><span class=\"line\">anotherPerson.sayHi(); // hi</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>寄生式继承的问题：跟借用构造函数模式一样，每次创建对象都会创建一遍方法</p>\n</blockquote>\n<h4 id=\"6-ES5继承之寄生组合式继承\"><a href=\"#6-ES5继承之寄生组合式继承\" class=\"headerlink\" title=\"6. ES5继承之寄生组合式继承\"></a>6. ES5继承之寄生组合式继承</h4><blockquote>\n<p>组合继承最大的缺点是会调用两次父构造函数。<br>一次是设置子类型实例的原型的时候，一次在创建子类型实例的时候。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function object(o) &#123;</span><br><span class=\"line\">    function F() &#123;&#125;</span><br><span class=\"line\">    F.prototype = o;</span><br><span class=\"line\">    return new F();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function prototype(child, parent) &#123;</span><br><span class=\"line\">    var prototype = object(parent.prototype);</span><br><span class=\"line\">    prototype.constructor = child;</span><br><span class=\"line\">    child.prototype = prototype;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 当我们使用的时候：</span><br><span class=\"line\">prototype(Child, Parent);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>这种方式的高效率体现它只调用了一次 Parent 构造函数，并且因此避免了在 Parent.prototype 上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用 instanceof 和 isPrototypeOf。</p>\n</blockquote>"},{"title":"从ES5&ES6两方看继承(二)","date":"2018-05-18T07:13:58.000Z","about":null,"_content":"\n## 接着上文，看ES6继承之Class & extends\n\n### 1.基本语法\n\n```\nclass Point {\n}\n\n// ColorPoint \nclass ColorPoint extends Point {\n    constructor(x, y, color) {\n        super(x, y); // 调用父类的constructor(x, y)\n        this.color = color;\n    }\n\n    toString() {\n        return this.color + ' ' + super.toString(); // 调用父类的toString()\n    }\n}\n```\nsuper方法表示父类构造函数，调用时会新建父类的this对象。只有super方法才可以返回父类实例，所以调用super之后子类才可以使用this关键字。\n\n<!--more-->\n\n> 注意：子类必须在constructor方法中调用super方法，否则新建实例的时候会报错。这是因为ES6的继承机制是酱紫的：先创建父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。也就是说子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其加工，加上子类自己的实例属性和方法。如果不调用super方法子类就得不到this对象。最后，父类的静态方法也会被子类继承。\n\n扯一扯ES5的继承机制：先创建子类的实例对象this，然后将父类的方法添加到子类的实例对象this上面（Parent.apply(this)）。\n\n### 2. Object.getPrototypeOf()\n> 用来从子类上获取父类，因此可以用来判断一个类是否继承了另一个类。\n\n```\nObject.getPrototypeOf(ColorPoint) === Point; // true\n```\n\n### 3. super关键字\n- 作为函数调用时，代表父类的构造函数且只能在子类的构造函数中。即使super代表了父类的构造函数，但是返回的是子类的实例，也就是其内部的this指的是子类，所以super相当于是 ++**父类.prototype.constructor.call(this)**++\n- 作为对象时，++在普通方法中，指向父类的原型对象++，所以定义在父类实例上的属性和方法无法通过super调用。规定在子类普通方法中通过super调用父类方法时，内部的this指向当前的子类实例。因为this指向子类实例，所以++如果在子类的constructor方法中通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性；在静态方法中，指向父类，而不是父类的原型对象++。\n\n### 4.类的prototype和__proto__\n> 作为一个对象，子类的原型（__proto__属性）是父类。\n\n> 作为一个构造函数，子类的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。\n\n### 5.实例的__proto__属性\n> 子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。\n\n### 6.原生构造函数的继承\n> Boolean()、Number()、String()、Array()、Date()、Function()、RegExp()、Error()、Object()以上这些原生构造函数是无法继承的。\n原生构造函数的this无法绑定，导致拿不到内部属性。因为ES5中是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。\n\n```\nfunction MyArray() {\n  Array.apply(this, arguments);\n}\n\nMyArray.prototype = Object.create(Array.prototype, {\n  constructor: {\n    value: MyArray,\n    writable: true,\n    configurable: true,\n    enumerable: true\n  }\n});\n\nvar colors = new MyArray();\ncolors[0] = \"red\";\ncolors.length  // 0\n\ncolors.length = 0;\ncolors[0]  // \"red\"\n```\n之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。\n\n> ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。\n\n```\nclass MyArray extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n```","source":"_posts/从ES5&ES6两方看继承(二).md","raw":"---\ntitle: 从ES5&ES6两方看继承(二)\ndate: 2018-05-18 15:13:58\ntags: \n- 对象\n- 继承\ncategories: ES6\nabout:\n---\n\n## 接着上文，看ES6继承之Class & extends\n\n### 1.基本语法\n\n```\nclass Point {\n}\n\n// ColorPoint \nclass ColorPoint extends Point {\n    constructor(x, y, color) {\n        super(x, y); // 调用父类的constructor(x, y)\n        this.color = color;\n    }\n\n    toString() {\n        return this.color + ' ' + super.toString(); // 调用父类的toString()\n    }\n}\n```\nsuper方法表示父类构造函数，调用时会新建父类的this对象。只有super方法才可以返回父类实例，所以调用super之后子类才可以使用this关键字。\n\n<!--more-->\n\n> 注意：子类必须在constructor方法中调用super方法，否则新建实例的时候会报错。这是因为ES6的继承机制是酱紫的：先创建父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。也就是说子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其加工，加上子类自己的实例属性和方法。如果不调用super方法子类就得不到this对象。最后，父类的静态方法也会被子类继承。\n\n扯一扯ES5的继承机制：先创建子类的实例对象this，然后将父类的方法添加到子类的实例对象this上面（Parent.apply(this)）。\n\n### 2. Object.getPrototypeOf()\n> 用来从子类上获取父类，因此可以用来判断一个类是否继承了另一个类。\n\n```\nObject.getPrototypeOf(ColorPoint) === Point; // true\n```\n\n### 3. super关键字\n- 作为函数调用时，代表父类的构造函数且只能在子类的构造函数中。即使super代表了父类的构造函数，但是返回的是子类的实例，也就是其内部的this指的是子类，所以super相当于是 ++**父类.prototype.constructor.call(this)**++\n- 作为对象时，++在普通方法中，指向父类的原型对象++，所以定义在父类实例上的属性和方法无法通过super调用。规定在子类普通方法中通过super调用父类方法时，内部的this指向当前的子类实例。因为this指向子类实例，所以++如果在子类的constructor方法中通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性；在静态方法中，指向父类，而不是父类的原型对象++。\n\n### 4.类的prototype和__proto__\n> 作为一个对象，子类的原型（__proto__属性）是父类。\n\n> 作为一个构造函数，子类的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。\n\n### 5.实例的__proto__属性\n> 子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。\n\n### 6.原生构造函数的继承\n> Boolean()、Number()、String()、Array()、Date()、Function()、RegExp()、Error()、Object()以上这些原生构造函数是无法继承的。\n原生构造函数的this无法绑定，导致拿不到内部属性。因为ES5中是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。\n\n```\nfunction MyArray() {\n  Array.apply(this, arguments);\n}\n\nMyArray.prototype = Object.create(Array.prototype, {\n  constructor: {\n    value: MyArray,\n    writable: true,\n    configurable: true,\n    enumerable: true\n  }\n});\n\nvar colors = new MyArray();\ncolors[0] = \"red\";\ncolors.length  // 0\n\ncolors.length = 0;\ncolors[0]  // \"red\"\n```\n之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。\n\n> ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。\n\n```\nclass MyArray extends Array {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\nvar arr = new MyArray();\narr[0] = 12;\narr.length // 1\n\narr.length = 0;\narr[0] // undefined\n```","slug":"从ES5&ES6两方看继承(二)","published":1,"updated":"2019-02-22T08:37:33.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugror000hvrie2eer4p94","content":"<h2 id=\"接着上文，看ES6继承之Class-amp-extends\"><a href=\"#接着上文，看ES6继承之Class-amp-extends\" class=\"headerlink\" title=\"接着上文，看ES6继承之Class &amp; extends\"></a>接着上文，看ES6继承之Class &amp; extends</h2><h3 id=\"1-基本语法\"><a href=\"#1-基本语法\" class=\"headerlink\" title=\"1.基本语法\"></a>1.基本语法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ColorPoint </span><br><span class=\"line\">class ColorPoint extends Point &#123;</span><br><span class=\"line\">    constructor(x, y, color) &#123;</span><br><span class=\"line\">        super(x, y); // 调用父类的constructor(x, y)</span><br><span class=\"line\">        this.color = color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>super方法表示父类构造函数，调用时会新建父类的this对象。只有super方法才可以返回父类实例，所以调用super之后子类才可以使用this关键字。</p>\n<a id=\"more\"></a>\n<blockquote>\n<p>注意：子类必须在constructor方法中调用super方法，否则新建实例的时候会报错。这是因为ES6的继承机制是酱紫的：先创建父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。也就是说子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其加工，加上子类自己的实例属性和方法。如果不调用super方法子类就得不到this对象。最后，父类的静态方法也会被子类继承。</p>\n</blockquote>\n<p>扯一扯ES5的继承机制：先创建子类的实例对象this，然后将父类的方法添加到子类的实例对象this上面（Parent.apply(this)）。</p>\n<h3 id=\"2-Object-getPrototypeOf\"><a href=\"#2-Object-getPrototypeOf\" class=\"headerlink\" title=\"2. Object.getPrototypeOf()\"></a>2. Object.getPrototypeOf()</h3><blockquote>\n<p>用来从子类上获取父类，因此可以用来判断一个类是否继承了另一个类。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.getPrototypeOf(ColorPoint) === Point; // true</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-super关键字\"><a href=\"#3-super关键字\" class=\"headerlink\" title=\"3. super关键字\"></a>3. super关键字</h3><ul>\n<li>作为函数调用时，代表父类的构造函数且只能在子类的构造函数中。即使super代表了父类的构造函数，但是返回的是子类的实例，也就是其内部的this指的是子类，所以super相当于是 ++<strong>父类.prototype.constructor.call(this)</strong>++</li>\n<li>作为对象时，++在普通方法中，指向父类的原型对象++，所以定义在父类实例上的属性和方法无法通过super调用。规定在子类普通方法中通过super调用父类方法时，内部的this指向当前的子类实例。因为this指向子类实例，所以++如果在子类的constructor方法中通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性；在静态方法中，指向父类，而不是父类的原型对象++。</li>\n</ul>\n<h3 id=\"4-类的prototype和proto\"><a href=\"#4-类的prototype和proto\" class=\"headerlink\" title=\"4.类的prototype和proto\"></a>4.类的prototype和<strong>proto</strong></h3><blockquote>\n<p>作为一个对象，子类的原型（<strong>proto</strong>属性）是父类。</p>\n</blockquote>\n<blockquote>\n<p>作为一个构造函数，子类的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。</p>\n</blockquote>\n<h3 id=\"5-实例的proto属性\"><a href=\"#5-实例的proto属性\" class=\"headerlink\" title=\"5.实例的proto属性\"></a>5.实例的<strong>proto</strong>属性</h3><blockquote>\n<p>子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>proto</strong>属性。也就是说，子类的原型的原型，是父类的原型。因此，通过子类实例的<strong>proto</strong>.<strong>proto</strong>属性，可以修改父类实例的行为。</p>\n</blockquote>\n<h3 id=\"6-原生构造函数的继承\"><a href=\"#6-原生构造函数的继承\" class=\"headerlink\" title=\"6.原生构造函数的继承\"></a>6.原生构造函数的继承</h3><blockquote>\n<p>Boolean()、Number()、String()、Array()、Date()、Function()、RegExp()、Error()、Object()以上这些原生构造函数是无法继承的。<br>原生构造函数的this无法绑定，导致拿不到内部属性。因为ES5中是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MyArray() &#123;</span><br><span class=\"line\">  Array.apply(this, arguments);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyArray.prototype = Object.create(Array.prototype, &#123;</span><br><span class=\"line\">  constructor: &#123;</span><br><span class=\"line\">    value: MyArray,</span><br><span class=\"line\">    writable: true,</span><br><span class=\"line\">    configurable: true,</span><br><span class=\"line\">    enumerable: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var colors = new MyArray();</span><br><span class=\"line\">colors[0] = &quot;red&quot;;</span><br><span class=\"line\">colors.length  // 0</span><br><span class=\"line\"></span><br><span class=\"line\">colors.length = 0;</span><br><span class=\"line\">colors[0]  // &quot;red&quot;</span><br></pre></td></tr></table></figure>\n<p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。</p>\n<blockquote>\n<p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyArray extends Array &#123;</span><br><span class=\"line\">  constructor(...args) &#123;</span><br><span class=\"line\">    super(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new MyArray();</span><br><span class=\"line\">arr[0] = 12;</span><br><span class=\"line\">arr.length // 1</span><br><span class=\"line\"></span><br><span class=\"line\">arr.length = 0;</span><br><span class=\"line\">arr[0] // undefined</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"接着上文，看ES6继承之Class-amp-extends\"><a href=\"#接着上文，看ES6继承之Class-amp-extends\" class=\"headerlink\" title=\"接着上文，看ES6继承之Class &amp; extends\"></a>接着上文，看ES6继承之Class &amp; extends</h2><h3 id=\"1-基本语法\"><a href=\"#1-基本语法\" class=\"headerlink\" title=\"1.基本语法\"></a>1.基本语法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// ColorPoint </span><br><span class=\"line\">class ColorPoint extends Point &#123;</span><br><span class=\"line\">    constructor(x, y, color) &#123;</span><br><span class=\"line\">        super(x, y); // 调用父类的constructor(x, y)</span><br><span class=\"line\">        this.color = color;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        return this.color + &apos; &apos; + super.toString(); // 调用父类的toString()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>super方法表示父类构造函数，调用时会新建父类的this对象。只有super方法才可以返回父类实例，所以调用super之后子类才可以使用this关键字。</p>","more":"<blockquote>\n<p>注意：子类必须在constructor方法中调用super方法，否则新建实例的时候会报错。这是因为ES6的继承机制是酱紫的：先创建父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。也就是说子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其加工，加上子类自己的实例属性和方法。如果不调用super方法子类就得不到this对象。最后，父类的静态方法也会被子类继承。</p>\n</blockquote>\n<p>扯一扯ES5的继承机制：先创建子类的实例对象this，然后将父类的方法添加到子类的实例对象this上面（Parent.apply(this)）。</p>\n<h3 id=\"2-Object-getPrototypeOf\"><a href=\"#2-Object-getPrototypeOf\" class=\"headerlink\" title=\"2. Object.getPrototypeOf()\"></a>2. Object.getPrototypeOf()</h3><blockquote>\n<p>用来从子类上获取父类，因此可以用来判断一个类是否继承了另一个类。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.getPrototypeOf(ColorPoint) === Point; // true</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-super关键字\"><a href=\"#3-super关键字\" class=\"headerlink\" title=\"3. super关键字\"></a>3. super关键字</h3><ul>\n<li>作为函数调用时，代表父类的构造函数且只能在子类的构造函数中。即使super代表了父类的构造函数，但是返回的是子类的实例，也就是其内部的this指的是子类，所以super相当于是 ++<strong>父类.prototype.constructor.call(this)</strong>++</li>\n<li>作为对象时，++在普通方法中，指向父类的原型对象++，所以定义在父类实例上的属性和方法无法通过super调用。规定在子类普通方法中通过super调用父类方法时，内部的this指向当前的子类实例。因为this指向子类实例，所以++如果在子类的constructor方法中通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性；在静态方法中，指向父类，而不是父类的原型对象++。</li>\n</ul>\n<h3 id=\"4-类的prototype和proto\"><a href=\"#4-类的prototype和proto\" class=\"headerlink\" title=\"4.类的prototype和proto\"></a>4.类的prototype和<strong>proto</strong></h3><blockquote>\n<p>作为一个对象，子类的原型（<strong>proto</strong>属性）是父类。</p>\n</blockquote>\n<blockquote>\n<p>作为一个构造函数，子类的原型对象（prototype属性）是父类的原型对象（prototype属性）的实例。</p>\n</blockquote>\n<h3 id=\"5-实例的proto属性\"><a href=\"#5-实例的proto属性\" class=\"headerlink\" title=\"5.实例的proto属性\"></a>5.实例的<strong>proto</strong>属性</h3><blockquote>\n<p>子类实例的<strong>proto</strong>属性的<strong>proto</strong>属性，指向父类实例的<strong>proto</strong>属性。也就是说，子类的原型的原型，是父类的原型。因此，通过子类实例的<strong>proto</strong>.<strong>proto</strong>属性，可以修改父类实例的行为。</p>\n</blockquote>\n<h3 id=\"6-原生构造函数的继承\"><a href=\"#6-原生构造函数的继承\" class=\"headerlink\" title=\"6.原生构造函数的继承\"></a>6.原生构造函数的继承</h3><blockquote>\n<p>Boolean()、Number()、String()、Array()、Date()、Function()、RegExp()、Error()、Object()以上这些原生构造函数是无法继承的。<br>原生构造函数的this无法绑定，导致拿不到内部属性。因为ES5中是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MyArray() &#123;</span><br><span class=\"line\">  Array.apply(this, arguments);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">MyArray.prototype = Object.create(Array.prototype, &#123;</span><br><span class=\"line\">  constructor: &#123;</span><br><span class=\"line\">    value: MyArray,</span><br><span class=\"line\">    writable: true,</span><br><span class=\"line\">    configurable: true,</span><br><span class=\"line\">    enumerable: true</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var colors = new MyArray();</span><br><span class=\"line\">colors[0] = &quot;red&quot;;</span><br><span class=\"line\">colors.length  // 0</span><br><span class=\"line\"></span><br><span class=\"line\">colors.length = 0;</span><br><span class=\"line\">colors[0]  // &quot;red&quot;</span><br></pre></td></tr></table></figure>\n<p>之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。</p>\n<blockquote>\n<p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyArray extends Array &#123;</span><br><span class=\"line\">  constructor(...args) &#123;</span><br><span class=\"line\">    super(...args);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var arr = new MyArray();</span><br><span class=\"line\">arr[0] = 12;</span><br><span class=\"line\">arr.length // 1</span><br><span class=\"line\"></span><br><span class=\"line\">arr.length = 0;</span><br><span class=\"line\">arr[0] // undefined</span><br></pre></td></tr></table></figure>"},{"title":"初试ES6之Class","date":"2018-05-09T15:52:36.000Z","about":null,"_content":"\n## Class基础知识\n\n### 语法：\n\n```\n// 方法一 Class声明\nclass Point {\n    construstor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    toString() {\n        return '(' + this.x + ',' + this.y + ')';\n    }\n}\n\n// 方法二 Class表达式\nlet person = new class {\n    constructor(name) {\n        this.name = name;\n    }\n\n    sayName() {\n        console.log(this.name);\n    }\n}('张三');\n\nperson.sayName(); // \"张三\"\n// person是一个立即执行的类的实例\n```\n\n### 类的数据类型是函数，因为类本身指向构造函数，类的方法都定义在prototype属性上面，可以使用Object.assign方法一次向类添加多个方法\n<!-- more -->\n### ！注意：\n#### 1.在类的实例上调用方法，就是调用原型上的方法\n#### 2.prototype对象的constructor属性直接指向类本身\n#### 3.类的内部所有定义的方法都是不可枚举的\n#### 4.类默认有constructor方法，如果没有显示定义，空的constructor方法会被默认添加\n#### 5.constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象\n#### 6.Class的name属性总是返回类名\n```\nclass Point {\n    constructor() {\n        return Object.create(null);\n    }\n}\nnew Point instanceof Point   // false\n```\n#### 6.类必须使用new调用\n\n---\n\n\n## 敲黑板！！！划重点！！！\n\n- #### 实例的属性除非显示定义在this对象上，否则都是定义在原型（class）上，即实例的自身属性都定义在this变量上，实例共享的属性和方法都定义在原型对象上也就是类上。\n```\n//定义类\nclass Point {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  \n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n  \n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n```\n- #### 类的所有实例共享一个原型对象，也就是说可以通过实例的__proto__属性为class添加方法。不过，因为通过实例的__proto__属性改写原型会改变class的原始定义，会影响到所有实例，需注意！\n\n```\nvar p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__.printName = function () { return 'Oops' };\n\np1.printName() // \"Oops\"\np2.printName() // \"Oops\"\n\nvar p3 = new Point(4,2);\np3.printName() // \"Oops\"\n```\n\n--- \n\n__proto__不是语言本身特性，而是各大厂商实现的私有属性，不建议在生产环境中使用该属性，建议使用Object.getPrototypeOf方法来获取实例对象的原型，然后再添加源性方法/属性。\n\n---\n\n- #### 类不存在变量提升，必须保证子类在父类之后定义\n- #### 私有方法的实现：\n    ##### 1.方法名前加下划线（不保险），类的外部还是可以调到这个方法\n    ##### 2.将私有方法移出模块（因为模块内部的方法都是对外可见的）\n    ##### 3.利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值\n- #### 私有属性的提案：\n    ##### 1.使用#在属性名之前，使用时必须带有#一起使用\n    ##### 2.私有属性可以指定初始值，在构造函数时进行初始化\n    * #设置私有属性，也可以设置私有方法\n    * 私有属性也可以设置getter和setter方法\n- #### this指向：类的方法内部如果使用this，则默认指向类的实例，但是单独使用这个方法时，this会指向该方法运行时所在的环境，此时会因为找不到绑定对象而报错\n    * 解决方法：\n        1. 构造方法中指定this（最推荐！）\n        2. 使用箭头函数\n        3. 使用Proxy（未使用，详见ES6文档）\n- #### Class的取值函数（getter）和存值函数（setter）是设置在属性的Descriptor对象上的\n```\nclass CustomHTMLElement {\n  constructor(element) {\n    this.element = element;\n  }\n\n  get html() {\n    return this.element.innerHTML;\n  }\n\n  set html(value) {\n    this.element.innerHTML = value;\n  }\n}\n\nvar descriptor = Object.getOwnPropertyDescriptor(\n  CustomHTMLElement.prototype, \"html\"\n);\n\n\"get\" in descriptor  // true\n\"set\" in descriptor  // true\n```\n- #### Class内部的方法前加上*，即为一个Generator函数（emmmmm，是时候又回去看看generator啦~）\n- #### Class的静态方法：\n    * 语法：static methodName() {}\n    * 可以在类上调用，但是不能在实例上调用。如果静态方法中指定了this，则指向类。\n    * 静态方法可以与非静态方法重名。\n    * 父类的静态方法可以被子类继承，也可以从super对象上调用的。\n- #### Class的静态属性和实例属性：\n    * 静态属性指的是类本身的属性，而不是this上的属性\n    * 类的实例属性可以用等式写在类的定义中\n    ```\n    class MyClass {\n        myProp = 42;\n\n        constructor() {\n            console.log(this.myProp); // 42\n        }\n    }\n    ```\n    \n    * 类的静态属性是在实例属性写法前面加上static关键字\n    \n    ```\n    // 老写法\n    class Foo {\n        // ...\n    }\n    Foo.prop = 1;\n\n    // 新写法\n    class Foo {\n        static prop = 1;\n    }\n    ```\n- #### new.target属性用在构造函数之中可以确定构造函数是怎么调用的，正常返回new命令作用于的构造函数，如果构造函数不是通过new命令调用的，new.target返回undefined\n    * Class内部调用new.target，返回当前Class\n    * 子类继承父类时，new.target返回子类[可以用来写不能单独使用必须继承后才可使用的类]\n    * 函数外部，使用new.target会报错\n\n\n","source":"_posts/初试ES6之Class.md","raw":"---\ntitle: 初试ES6之Class\ndate: 2018-05-09 23:52:36\ntags: \n- Class\ncategories: ES6\nabout:\n---\n\n## Class基础知识\n\n### 语法：\n\n```\n// 方法一 Class声明\nclass Point {\n    construstor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n    \n    toString() {\n        return '(' + this.x + ',' + this.y + ')';\n    }\n}\n\n// 方法二 Class表达式\nlet person = new class {\n    constructor(name) {\n        this.name = name;\n    }\n\n    sayName() {\n        console.log(this.name);\n    }\n}('张三');\n\nperson.sayName(); // \"张三\"\n// person是一个立即执行的类的实例\n```\n\n### 类的数据类型是函数，因为类本身指向构造函数，类的方法都定义在prototype属性上面，可以使用Object.assign方法一次向类添加多个方法\n<!-- more -->\n### ！注意：\n#### 1.在类的实例上调用方法，就是调用原型上的方法\n#### 2.prototype对象的constructor属性直接指向类本身\n#### 3.类的内部所有定义的方法都是不可枚举的\n#### 4.类默认有constructor方法，如果没有显示定义，空的constructor方法会被默认添加\n#### 5.constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象\n#### 6.Class的name属性总是返回类名\n```\nclass Point {\n    constructor() {\n        return Object.create(null);\n    }\n}\nnew Point instanceof Point   // false\n```\n#### 6.类必须使用new调用\n\n---\n\n\n## 敲黑板！！！划重点！！！\n\n- #### 实例的属性除非显示定义在this对象上，否则都是定义在原型（class）上，即实例的自身属性都定义在this变量上，实例共享的属性和方法都定义在原型对象上也就是类上。\n```\n//定义类\nclass Point {\n\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  \n  toString() {\n    return '(' + this.x + ', ' + this.y + ')';\n  }\n  \n}\n\nvar point = new Point(2, 3);\n\npoint.toString() // (2, 3)\n\npoint.hasOwnProperty('x') // true\npoint.hasOwnProperty('y') // true\npoint.hasOwnProperty('toString') // false\npoint.__proto__.hasOwnProperty('toString') // true\n```\n- #### 类的所有实例共享一个原型对象，也就是说可以通过实例的__proto__属性为class添加方法。不过，因为通过实例的__proto__属性改写原型会改变class的原始定义，会影响到所有实例，需注意！\n\n```\nvar p1 = new Point(2,3);\nvar p2 = new Point(3,2);\n\np1.__proto__.printName = function () { return 'Oops' };\n\np1.printName() // \"Oops\"\np2.printName() // \"Oops\"\n\nvar p3 = new Point(4,2);\np3.printName() // \"Oops\"\n```\n\n--- \n\n__proto__不是语言本身特性，而是各大厂商实现的私有属性，不建议在生产环境中使用该属性，建议使用Object.getPrototypeOf方法来获取实例对象的原型，然后再添加源性方法/属性。\n\n---\n\n- #### 类不存在变量提升，必须保证子类在父类之后定义\n- #### 私有方法的实现：\n    ##### 1.方法名前加下划线（不保险），类的外部还是可以调到这个方法\n    ##### 2.将私有方法移出模块（因为模块内部的方法都是对外可见的）\n    ##### 3.利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值\n- #### 私有属性的提案：\n    ##### 1.使用#在属性名之前，使用时必须带有#一起使用\n    ##### 2.私有属性可以指定初始值，在构造函数时进行初始化\n    * #设置私有属性，也可以设置私有方法\n    * 私有属性也可以设置getter和setter方法\n- #### this指向：类的方法内部如果使用this，则默认指向类的实例，但是单独使用这个方法时，this会指向该方法运行时所在的环境，此时会因为找不到绑定对象而报错\n    * 解决方法：\n        1. 构造方法中指定this（最推荐！）\n        2. 使用箭头函数\n        3. 使用Proxy（未使用，详见ES6文档）\n- #### Class的取值函数（getter）和存值函数（setter）是设置在属性的Descriptor对象上的\n```\nclass CustomHTMLElement {\n  constructor(element) {\n    this.element = element;\n  }\n\n  get html() {\n    return this.element.innerHTML;\n  }\n\n  set html(value) {\n    this.element.innerHTML = value;\n  }\n}\n\nvar descriptor = Object.getOwnPropertyDescriptor(\n  CustomHTMLElement.prototype, \"html\"\n);\n\n\"get\" in descriptor  // true\n\"set\" in descriptor  // true\n```\n- #### Class内部的方法前加上*，即为一个Generator函数（emmmmm，是时候又回去看看generator啦~）\n- #### Class的静态方法：\n    * 语法：static methodName() {}\n    * 可以在类上调用，但是不能在实例上调用。如果静态方法中指定了this，则指向类。\n    * 静态方法可以与非静态方法重名。\n    * 父类的静态方法可以被子类继承，也可以从super对象上调用的。\n- #### Class的静态属性和实例属性：\n    * 静态属性指的是类本身的属性，而不是this上的属性\n    * 类的实例属性可以用等式写在类的定义中\n    ```\n    class MyClass {\n        myProp = 42;\n\n        constructor() {\n            console.log(this.myProp); // 42\n        }\n    }\n    ```\n    \n    * 类的静态属性是在实例属性写法前面加上static关键字\n    \n    ```\n    // 老写法\n    class Foo {\n        // ...\n    }\n    Foo.prop = 1;\n\n    // 新写法\n    class Foo {\n        static prop = 1;\n    }\n    ```\n- #### new.target属性用在构造函数之中可以确定构造函数是怎么调用的，正常返回new命令作用于的构造函数，如果构造函数不是通过new命令调用的，new.target返回undefined\n    * Class内部调用new.target，返回当前Class\n    * 子类继承父类时，new.target返回子类[可以用来写不能单独使用必须继承后才可使用的类]\n    * 函数外部，使用new.target会报错\n\n\n","slug":"初试ES6之Class","published":1,"updated":"2019-02-22T08:37:33.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugros000jvrievbpl0tch","content":"<h2 id=\"Class基础知识\"><a href=\"#Class基础知识\" class=\"headerlink\" title=\"Class基础知识\"></a>Class基础知识</h2><h3 id=\"语法：\"><a href=\"#语法：\" class=\"headerlink\" title=\"语法：\"></a>语法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 方法一 Class声明</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\">    construstor(x, y) &#123;</span><br><span class=\"line\">        this.x = x;</span><br><span class=\"line\">        this.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        return &apos;(&apos; + this.x + &apos;,&apos; + this.y + &apos;)&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法二 Class表达式</span><br><span class=\"line\">let person = new class &#123;</span><br><span class=\"line\">    constructor(name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sayName() &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(&apos;张三&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">person.sayName(); // &quot;张三&quot;</span><br><span class=\"line\">// person是一个立即执行的类的实例</span><br></pre></td></tr></table></figure>\n<h3 id=\"类的数据类型是函数，因为类本身指向构造函数，类的方法都定义在prototype属性上面，可以使用Object-assign方法一次向类添加多个方法\"><a href=\"#类的数据类型是函数，因为类本身指向构造函数，类的方法都定义在prototype属性上面，可以使用Object-assign方法一次向类添加多个方法\" class=\"headerlink\" title=\"类的数据类型是函数，因为类本身指向构造函数，类的方法都定义在prototype属性上面，可以使用Object.assign方法一次向类添加多个方法\"></a>类的数据类型是函数，因为类本身指向构造函数，类的方法都定义在prototype属性上面，可以使用Object.assign方法一次向类添加多个方法</h3><a id=\"more\"></a>\n<h3 id=\"！注意：\"><a href=\"#！注意：\" class=\"headerlink\" title=\"！注意：\"></a>！注意：</h3><h4 id=\"1-在类的实例上调用方法，就是调用原型上的方法\"><a href=\"#1-在类的实例上调用方法，就是调用原型上的方法\" class=\"headerlink\" title=\"1.在类的实例上调用方法，就是调用原型上的方法\"></a>1.在类的实例上调用方法，就是调用原型上的方法</h4><h4 id=\"2-prototype对象的constructor属性直接指向类本身\"><a href=\"#2-prototype对象的constructor属性直接指向类本身\" class=\"headerlink\" title=\"2.prototype对象的constructor属性直接指向类本身\"></a>2.prototype对象的constructor属性直接指向类本身</h4><h4 id=\"3-类的内部所有定义的方法都是不可枚举的\"><a href=\"#3-类的内部所有定义的方法都是不可枚举的\" class=\"headerlink\" title=\"3.类的内部所有定义的方法都是不可枚举的\"></a>3.类的内部所有定义的方法都是不可枚举的</h4><h4 id=\"4-类默认有constructor方法，如果没有显示定义，空的constructor方法会被默认添加\"><a href=\"#4-类默认有constructor方法，如果没有显示定义，空的constructor方法会被默认添加\" class=\"headerlink\" title=\"4.类默认有constructor方法，如果没有显示定义，空的constructor方法会被默认添加\"></a>4.类默认有constructor方法，如果没有显示定义，空的constructor方法会被默认添加</h4><h4 id=\"5-constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象\"><a href=\"#5-constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象\" class=\"headerlink\" title=\"5.constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象\"></a>5.constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象</h4><h4 id=\"6-Class的name属性总是返回类名\"><a href=\"#6-Class的name属性总是返回类名\" class=\"headerlink\" title=\"6.Class的name属性总是返回类名\"></a>6.Class的name属性总是返回类名</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        return Object.create(null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new Point instanceof Point   // false</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-类必须使用new调用\"><a href=\"#6-类必须使用new调用\" class=\"headerlink\" title=\"6.类必须使用new调用\"></a>6.类必须使用new调用</h4><hr>\n<h2 id=\"敲黑板！！！划重点！！！\"><a href=\"#敲黑板！！！划重点！！！\" class=\"headerlink\" title=\"敲黑板！！！划重点！！！\"></a>敲黑板！！！划重点！！！</h2><ul>\n<li><h4 id=\"实例的属性除非显示定义在this对象上，否则都是定义在原型（class）上，即实例的自身属性都定义在this变量上，实例共享的属性和方法都定义在原型对象上也就是类上。\"><a href=\"#实例的属性除非显示定义在this对象上，否则都是定义在原型（class）上，即实例的自身属性都定义在this变量上，实例共享的属性和方法都定义在原型对象上也就是类上。\" class=\"headerlink\" title=\"实例的属性除非显示定义在this对象上，否则都是定义在原型（class）上，即实例的自身属性都定义在this变量上，实例共享的属性和方法都定义在原型对象上也就是类上。\"></a>实例的属性除非显示定义在this对象上，否则都是定义在原型（class）上，即实例的自身属性都定义在this变量上，实例共享的属性和方法都定义在原型对象上也就是类上。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义类</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor(x, y) &#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">    this.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var point = new Point(2, 3);</span><br><span class=\"line\"></span><br><span class=\"line\">point.toString() // (2, 3)</span><br><span class=\"line\"></span><br><span class=\"line\">point.hasOwnProperty(&apos;x&apos;) // true</span><br><span class=\"line\">point.hasOwnProperty(&apos;y&apos;) // true</span><br><span class=\"line\">point.hasOwnProperty(&apos;toString&apos;) // false</span><br><span class=\"line\">point.__proto__.hasOwnProperty(&apos;toString&apos;) // true</span><br></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"类的所有实例共享一个原型对象，也就是说可以通过实例的proto属性为class添加方法。不过，因为通过实例的proto属性改写原型会改变class的原始定义，会影响到所有实例，需注意！\"><a href=\"#类的所有实例共享一个原型对象，也就是说可以通过实例的proto属性为class添加方法。不过，因为通过实例的proto属性改写原型会改变class的原始定义，会影响到所有实例，需注意！\" class=\"headerlink\" title=\"类的所有实例共享一个原型对象，也就是说可以通过实例的proto属性为class添加方法。不过，因为通过实例的proto属性改写原型会改变class的原始定义，会影响到所有实例，需注意！\"></a>类的所有实例共享一个原型对象，也就是说可以通过实例的<strong>proto</strong>属性为class添加方法。不过，因为通过实例的<strong>proto</strong>属性改写原型会改变class的原始定义，会影响到所有实例，需注意！</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 = new Point(2,3);</span><br><span class=\"line\">var p2 = new Point(3,2);</span><br><span class=\"line\"></span><br><span class=\"line\">p1.__proto__.printName = function () &#123; return &apos;Oops&apos; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">p1.printName() // &quot;Oops&quot;</span><br><span class=\"line\">p2.printName() // &quot;Oops&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">var p3 = new Point(4,2);</span><br><span class=\"line\">p3.printName() // &quot;Oops&quot;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><strong>proto</strong>不是语言本身特性，而是各大厂商实现的私有属性，不建议在生产环境中使用该属性，建议使用Object.getPrototypeOf方法来获取实例对象的原型，然后再添加源性方法/属性。</p>\n<hr>\n<ul>\n<li><h4 id=\"类不存在变量提升，必须保证子类在父类之后定义\"><a href=\"#类不存在变量提升，必须保证子类在父类之后定义\" class=\"headerlink\" title=\"类不存在变量提升，必须保证子类在父类之后定义\"></a>类不存在变量提升，必须保证子类在父类之后定义</h4></li>\n<li><h4 id=\"私有方法的实现：\"><a href=\"#私有方法的实现：\" class=\"headerlink\" title=\"私有方法的实现：\"></a>私有方法的实现：</h4><h5 id=\"1-方法名前加下划线（不保险），类的外部还是可以调到这个方法\"><a href=\"#1-方法名前加下划线（不保险），类的外部还是可以调到这个方法\" class=\"headerlink\" title=\"1.方法名前加下划线（不保险），类的外部还是可以调到这个方法\"></a>1.方法名前加下划线（不保险），类的外部还是可以调到这个方法</h5><h5 id=\"2-将私有方法移出模块（因为模块内部的方法都是对外可见的）\"><a href=\"#2-将私有方法移出模块（因为模块内部的方法都是对外可见的）\" class=\"headerlink\" title=\"2.将私有方法移出模块（因为模块内部的方法都是对外可见的）\"></a>2.将私有方法移出模块（因为模块内部的方法都是对外可见的）</h5><h5 id=\"3-利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值\"><a href=\"#3-利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值\" class=\"headerlink\" title=\"3.利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值\"></a>3.利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值</h5></li>\n<li><h4 id=\"私有属性的提案：\"><a href=\"#私有属性的提案：\" class=\"headerlink\" title=\"私有属性的提案：\"></a>私有属性的提案：</h4><h5 id=\"1-使用-在属性名之前，使用时必须带有-一起使用\"><a href=\"#1-使用-在属性名之前，使用时必须带有-一起使用\" class=\"headerlink\" title=\"1.使用#在属性名之前，使用时必须带有#一起使用\"></a>1.使用#在属性名之前，使用时必须带有#一起使用</h5><h5 id=\"2-私有属性可以指定初始值，在构造函数时进行初始化\"><a href=\"#2-私有属性可以指定初始值，在构造函数时进行初始化\" class=\"headerlink\" title=\"2.私有属性可以指定初始值，在构造函数时进行初始化\"></a>2.私有属性可以指定初始值，在构造函数时进行初始化</h5><ul>\n<li>#设置私有属性，也可以设置私有方法</li>\n<li>私有属性也可以设置getter和setter方法</li>\n</ul>\n</li>\n<li><h4 id=\"this指向：类的方法内部如果使用this，则默认指向类的实例，但是单独使用这个方法时，this会指向该方法运行时所在的环境，此时会因为找不到绑定对象而报错\"><a href=\"#this指向：类的方法内部如果使用this，则默认指向类的实例，但是单独使用这个方法时，this会指向该方法运行时所在的环境，此时会因为找不到绑定对象而报错\" class=\"headerlink\" title=\"this指向：类的方法内部如果使用this，则默认指向类的实例，但是单独使用这个方法时，this会指向该方法运行时所在的环境，此时会因为找不到绑定对象而报错\"></a>this指向：类的方法内部如果使用this，则默认指向类的实例，但是单独使用这个方法时，this会指向该方法运行时所在的环境，此时会因为找不到绑定对象而报错</h4><ul>\n<li>解决方法：<ol>\n<li>构造方法中指定this（最推荐！）</li>\n<li>使用箭头函数</li>\n<li>使用Proxy（未使用，详见ES6文档）</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><h4 id=\"Class的取值函数（getter）和存值函数（setter）是设置在属性的Descriptor对象上的\"><a href=\"#Class的取值函数（getter）和存值函数（setter）是设置在属性的Descriptor对象上的\" class=\"headerlink\" title=\"Class的取值函数（getter）和存值函数（setter）是设置在属性的Descriptor对象上的\"></a>Class的取值函数（getter）和存值函数（setter）是设置在属性的Descriptor对象上的</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CustomHTMLElement &#123;</span><br><span class=\"line\">  constructor(element) &#123;</span><br><span class=\"line\">    this.element = element;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get html() &#123;</span><br><span class=\"line\">    return this.element.innerHTML;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  set html(value) &#123;</span><br><span class=\"line\">    this.element.innerHTML = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var descriptor = Object.getOwnPropertyDescriptor(</span><br><span class=\"line\">  CustomHTMLElement.prototype, &quot;html&quot;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;get&quot; in descriptor  // true</span><br><span class=\"line\">&quot;set&quot; in descriptor  // true</span><br></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"Class内部的方法前加上-，即为一个Generator函数（emmmmm，是时候又回去看看generator啦-）\"><a href=\"#Class内部的方法前加上-，即为一个Generator函数（emmmmm，是时候又回去看看generator啦-）\" class=\"headerlink\" title=\"Class内部的方法前加上*，即为一个Generator函数（emmmmm，是时候又回去看看generator啦~）\"></a>Class内部的方法前加上*，即为一个Generator函数（emmmmm，是时候又回去看看generator啦~）</h4></li>\n<li><h4 id=\"Class的静态方法：\"><a href=\"#Class的静态方法：\" class=\"headerlink\" title=\"Class的静态方法：\"></a>Class的静态方法：</h4><ul>\n<li>语法：static methodName() {}</li>\n<li>可以在类上调用，但是不能在实例上调用。如果静态方法中指定了this，则指向类。</li>\n<li>静态方法可以与非静态方法重名。</li>\n<li>父类的静态方法可以被子类继承，也可以从super对象上调用的。</li>\n</ul>\n</li>\n<li><h4 id=\"Class的静态属性和实例属性：\"><a href=\"#Class的静态属性和实例属性：\" class=\"headerlink\" title=\"Class的静态属性和实例属性：\"></a>Class的静态属性和实例属性：</h4><ul>\n<li>静态属性指的是类本身的属性，而不是this上的属性</li>\n<li>类的实例属性可以用等式写在类的定义中<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">    myProp = 42;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        console.log(this.myProp); // 42</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>* 类的静态属性是在实例属性写法前面加上static关键字\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 老写法</span><br><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prop = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">// 新写法</span><br><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">    static prop = 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><ul>\n<li><h4 id=\"new-target属性用在构造函数之中可以确定构造函数是怎么调用的，正常返回new命令作用于的构造函数，如果构造函数不是通过new命令调用的，new-target返回undefined\"><a href=\"#new-target属性用在构造函数之中可以确定构造函数是怎么调用的，正常返回new命令作用于的构造函数，如果构造函数不是通过new命令调用的，new-target返回undefined\" class=\"headerlink\" title=\"new.target属性用在构造函数之中可以确定构造函数是怎么调用的，正常返回new命令作用于的构造函数，如果构造函数不是通过new命令调用的，new.target返回undefined\"></a>new.target属性用在构造函数之中可以确定构造函数是怎么调用的，正常返回new命令作用于的构造函数，如果构造函数不是通过new命令调用的，new.target返回undefined</h4><ul>\n<li>Class内部调用new.target，返回当前Class</li>\n<li>子类继承父类时，new.target返回子类[可以用来写不能单独使用必须继承后才可使用的类]</li>\n<li>函数外部，使用new.target会报错</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"Class基础知识\"><a href=\"#Class基础知识\" class=\"headerlink\" title=\"Class基础知识\"></a>Class基础知识</h2><h3 id=\"语法：\"><a href=\"#语法：\" class=\"headerlink\" title=\"语法：\"></a>语法：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 方法一 Class声明</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\">    construstor(x, y) &#123;</span><br><span class=\"line\">        this.x = x;</span><br><span class=\"line\">        this.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    toString() &#123;</span><br><span class=\"line\">        return &apos;(&apos; + this.x + &apos;,&apos; + this.y + &apos;)&apos;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 方法二 Class表达式</span><br><span class=\"line\">let person = new class &#123;</span><br><span class=\"line\">    constructor(name) &#123;</span><br><span class=\"line\">        this.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    sayName() &#123;</span><br><span class=\"line\">        console.log(this.name);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(&apos;张三&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">person.sayName(); // &quot;张三&quot;</span><br><span class=\"line\">// person是一个立即执行的类的实例</span><br></pre></td></tr></table></figure>\n<h3 id=\"类的数据类型是函数，因为类本身指向构造函数，类的方法都定义在prototype属性上面，可以使用Object-assign方法一次向类添加多个方法\"><a href=\"#类的数据类型是函数，因为类本身指向构造函数，类的方法都定义在prototype属性上面，可以使用Object-assign方法一次向类添加多个方法\" class=\"headerlink\" title=\"类的数据类型是函数，因为类本身指向构造函数，类的方法都定义在prototype属性上面，可以使用Object.assign方法一次向类添加多个方法\"></a>类的数据类型是函数，因为类本身指向构造函数，类的方法都定义在prototype属性上面，可以使用Object.assign方法一次向类添加多个方法</h3>","more":"<h3 id=\"！注意：\"><a href=\"#！注意：\" class=\"headerlink\" title=\"！注意：\"></a>！注意：</h3><h4 id=\"1-在类的实例上调用方法，就是调用原型上的方法\"><a href=\"#1-在类的实例上调用方法，就是调用原型上的方法\" class=\"headerlink\" title=\"1.在类的实例上调用方法，就是调用原型上的方法\"></a>1.在类的实例上调用方法，就是调用原型上的方法</h4><h4 id=\"2-prototype对象的constructor属性直接指向类本身\"><a href=\"#2-prototype对象的constructor属性直接指向类本身\" class=\"headerlink\" title=\"2.prototype对象的constructor属性直接指向类本身\"></a>2.prototype对象的constructor属性直接指向类本身</h4><h4 id=\"3-类的内部所有定义的方法都是不可枚举的\"><a href=\"#3-类的内部所有定义的方法都是不可枚举的\" class=\"headerlink\" title=\"3.类的内部所有定义的方法都是不可枚举的\"></a>3.类的内部所有定义的方法都是不可枚举的</h4><h4 id=\"4-类默认有constructor方法，如果没有显示定义，空的constructor方法会被默认添加\"><a href=\"#4-类默认有constructor方法，如果没有显示定义，空的constructor方法会被默认添加\" class=\"headerlink\" title=\"4.类默认有constructor方法，如果没有显示定义，空的constructor方法会被默认添加\"></a>4.类默认有constructor方法，如果没有显示定义，空的constructor方法会被默认添加</h4><h4 id=\"5-constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象\"><a href=\"#5-constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象\" class=\"headerlink\" title=\"5.constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象\"></a>5.constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象</h4><h4 id=\"6-Class的name属性总是返回类名\"><a href=\"#6-Class的name属性总是返回类名\" class=\"headerlink\" title=\"6.Class的name属性总是返回类名\"></a>6.Class的name属性总是返回类名</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Point &#123;</span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        return Object.create(null);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">new Point instanceof Point   // false</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-类必须使用new调用\"><a href=\"#6-类必须使用new调用\" class=\"headerlink\" title=\"6.类必须使用new调用\"></a>6.类必须使用new调用</h4><hr>\n<h2 id=\"敲黑板！！！划重点！！！\"><a href=\"#敲黑板！！！划重点！！！\" class=\"headerlink\" title=\"敲黑板！！！划重点！！！\"></a>敲黑板！！！划重点！！！</h2><ul>\n<li><h4 id=\"实例的属性除非显示定义在this对象上，否则都是定义在原型（class）上，即实例的自身属性都定义在this变量上，实例共享的属性和方法都定义在原型对象上也就是类上。\"><a href=\"#实例的属性除非显示定义在this对象上，否则都是定义在原型（class）上，即实例的自身属性都定义在this变量上，实例共享的属性和方法都定义在原型对象上也就是类上。\" class=\"headerlink\" title=\"实例的属性除非显示定义在this对象上，否则都是定义在原型（class）上，即实例的自身属性都定义在this变量上，实例共享的属性和方法都定义在原型对象上也就是类上。\"></a>实例的属性除非显示定义在this对象上，否则都是定义在原型（class）上，即实例的自身属性都定义在this变量上，实例共享的属性和方法都定义在原型对象上也就是类上。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义类</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  constructor(x, y) &#123;</span><br><span class=\"line\">    this.x = x;</span><br><span class=\"line\">    this.y = y;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">  toString() &#123;</span><br><span class=\"line\">    return &apos;(&apos; + this.x + &apos;, &apos; + this.y + &apos;)&apos;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var point = new Point(2, 3);</span><br><span class=\"line\"></span><br><span class=\"line\">point.toString() // (2, 3)</span><br><span class=\"line\"></span><br><span class=\"line\">point.hasOwnProperty(&apos;x&apos;) // true</span><br><span class=\"line\">point.hasOwnProperty(&apos;y&apos;) // true</span><br><span class=\"line\">point.hasOwnProperty(&apos;toString&apos;) // false</span><br><span class=\"line\">point.__proto__.hasOwnProperty(&apos;toString&apos;) // true</span><br></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"类的所有实例共享一个原型对象，也就是说可以通过实例的proto属性为class添加方法。不过，因为通过实例的proto属性改写原型会改变class的原始定义，会影响到所有实例，需注意！\"><a href=\"#类的所有实例共享一个原型对象，也就是说可以通过实例的proto属性为class添加方法。不过，因为通过实例的proto属性改写原型会改变class的原始定义，会影响到所有实例，需注意！\" class=\"headerlink\" title=\"类的所有实例共享一个原型对象，也就是说可以通过实例的proto属性为class添加方法。不过，因为通过实例的proto属性改写原型会改变class的原始定义，会影响到所有实例，需注意！\"></a>类的所有实例共享一个原型对象，也就是说可以通过实例的<strong>proto</strong>属性为class添加方法。不过，因为通过实例的<strong>proto</strong>属性改写原型会改变class的原始定义，会影响到所有实例，需注意！</h4></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 = new Point(2,3);</span><br><span class=\"line\">var p2 = new Point(3,2);</span><br><span class=\"line\"></span><br><span class=\"line\">p1.__proto__.printName = function () &#123; return &apos;Oops&apos; &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">p1.printName() // &quot;Oops&quot;</span><br><span class=\"line\">p2.printName() // &quot;Oops&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">var p3 = new Point(4,2);</span><br><span class=\"line\">p3.printName() // &quot;Oops&quot;</span><br></pre></td></tr></table></figure>\n<hr>\n<p><strong>proto</strong>不是语言本身特性，而是各大厂商实现的私有属性，不建议在生产环境中使用该属性，建议使用Object.getPrototypeOf方法来获取实例对象的原型，然后再添加源性方法/属性。</p>\n<hr>\n<ul>\n<li><h4 id=\"类不存在变量提升，必须保证子类在父类之后定义\"><a href=\"#类不存在变量提升，必须保证子类在父类之后定义\" class=\"headerlink\" title=\"类不存在变量提升，必须保证子类在父类之后定义\"></a>类不存在变量提升，必须保证子类在父类之后定义</h4></li>\n<li><h4 id=\"私有方法的实现：\"><a href=\"#私有方法的实现：\" class=\"headerlink\" title=\"私有方法的实现：\"></a>私有方法的实现：</h4><h5 id=\"1-方法名前加下划线（不保险），类的外部还是可以调到这个方法\"><a href=\"#1-方法名前加下划线（不保险），类的外部还是可以调到这个方法\" class=\"headerlink\" title=\"1.方法名前加下划线（不保险），类的外部还是可以调到这个方法\"></a>1.方法名前加下划线（不保险），类的外部还是可以调到这个方法</h5><h5 id=\"2-将私有方法移出模块（因为模块内部的方法都是对外可见的）\"><a href=\"#2-将私有方法移出模块（因为模块内部的方法都是对外可见的）\" class=\"headerlink\" title=\"2.将私有方法移出模块（因为模块内部的方法都是对外可见的）\"></a>2.将私有方法移出模块（因为模块内部的方法都是对外可见的）</h5><h5 id=\"3-利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值\"><a href=\"#3-利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值\" class=\"headerlink\" title=\"3.利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值\"></a>3.利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值</h5></li>\n<li><h4 id=\"私有属性的提案：\"><a href=\"#私有属性的提案：\" class=\"headerlink\" title=\"私有属性的提案：\"></a>私有属性的提案：</h4><h5 id=\"1-使用-在属性名之前，使用时必须带有-一起使用\"><a href=\"#1-使用-在属性名之前，使用时必须带有-一起使用\" class=\"headerlink\" title=\"1.使用#在属性名之前，使用时必须带有#一起使用\"></a>1.使用#在属性名之前，使用时必须带有#一起使用</h5><h5 id=\"2-私有属性可以指定初始值，在构造函数时进行初始化\"><a href=\"#2-私有属性可以指定初始值，在构造函数时进行初始化\" class=\"headerlink\" title=\"2.私有属性可以指定初始值，在构造函数时进行初始化\"></a>2.私有属性可以指定初始值，在构造函数时进行初始化</h5><ul>\n<li>#设置私有属性，也可以设置私有方法</li>\n<li>私有属性也可以设置getter和setter方法</li>\n</ul>\n</li>\n<li><h4 id=\"this指向：类的方法内部如果使用this，则默认指向类的实例，但是单独使用这个方法时，this会指向该方法运行时所在的环境，此时会因为找不到绑定对象而报错\"><a href=\"#this指向：类的方法内部如果使用this，则默认指向类的实例，但是单独使用这个方法时，this会指向该方法运行时所在的环境，此时会因为找不到绑定对象而报错\" class=\"headerlink\" title=\"this指向：类的方法内部如果使用this，则默认指向类的实例，但是单独使用这个方法时，this会指向该方法运行时所在的环境，此时会因为找不到绑定对象而报错\"></a>this指向：类的方法内部如果使用this，则默认指向类的实例，但是单独使用这个方法时，this会指向该方法运行时所在的环境，此时会因为找不到绑定对象而报错</h4><ul>\n<li>解决方法：<ol>\n<li>构造方法中指定this（最推荐！）</li>\n<li>使用箭头函数</li>\n<li>使用Proxy（未使用，详见ES6文档）</li>\n</ol>\n</li>\n</ul>\n</li>\n<li><h4 id=\"Class的取值函数（getter）和存值函数（setter）是设置在属性的Descriptor对象上的\"><a href=\"#Class的取值函数（getter）和存值函数（setter）是设置在属性的Descriptor对象上的\" class=\"headerlink\" title=\"Class的取值函数（getter）和存值函数（setter）是设置在属性的Descriptor对象上的\"></a>Class的取值函数（getter）和存值函数（setter）是设置在属性的Descriptor对象上的</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class CustomHTMLElement &#123;</span><br><span class=\"line\">  constructor(element) &#123;</span><br><span class=\"line\">    this.element = element;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  get html() &#123;</span><br><span class=\"line\">    return this.element.innerHTML;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  set html(value) &#123;</span><br><span class=\"line\">    this.element.innerHTML = value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var descriptor = Object.getOwnPropertyDescriptor(</span><br><span class=\"line\">  CustomHTMLElement.prototype, &quot;html&quot;</span><br><span class=\"line\">);</span><br><span class=\"line\"></span><br><span class=\"line\">&quot;get&quot; in descriptor  // true</span><br><span class=\"line\">&quot;set&quot; in descriptor  // true</span><br></pre></td></tr></table></figure>\n</li>\n<li><h4 id=\"Class内部的方法前加上-，即为一个Generator函数（emmmmm，是时候又回去看看generator啦-）\"><a href=\"#Class内部的方法前加上-，即为一个Generator函数（emmmmm，是时候又回去看看generator啦-）\" class=\"headerlink\" title=\"Class内部的方法前加上*，即为一个Generator函数（emmmmm，是时候又回去看看generator啦~）\"></a>Class内部的方法前加上*，即为一个Generator函数（emmmmm，是时候又回去看看generator啦~）</h4></li>\n<li><h4 id=\"Class的静态方法：\"><a href=\"#Class的静态方法：\" class=\"headerlink\" title=\"Class的静态方法：\"></a>Class的静态方法：</h4><ul>\n<li>语法：static methodName() {}</li>\n<li>可以在类上调用，但是不能在实例上调用。如果静态方法中指定了this，则指向类。</li>\n<li>静态方法可以与非静态方法重名。</li>\n<li>父类的静态方法可以被子类继承，也可以从super对象上调用的。</li>\n</ul>\n</li>\n<li><h4 id=\"Class的静态属性和实例属性：\"><a href=\"#Class的静态属性和实例属性：\" class=\"headerlink\" title=\"Class的静态属性和实例属性：\"></a>Class的静态属性和实例属性：</h4><ul>\n<li>静态属性指的是类本身的属性，而不是this上的属性</li>\n<li>类的实例属性可以用等式写在类的定义中<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">    myProp = 42;</span><br><span class=\"line\"></span><br><span class=\"line\">    constructor() &#123;</span><br><span class=\"line\">        console.log(this.myProp); // 42</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>* 类的静态属性是在实例属性写法前面加上static关键字\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 老写法</span><br><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">    // ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo.prop = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">// 新写法</span><br><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">    static prop = 1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</code></pre><ul>\n<li><h4 id=\"new-target属性用在构造函数之中可以确定构造函数是怎么调用的，正常返回new命令作用于的构造函数，如果构造函数不是通过new命令调用的，new-target返回undefined\"><a href=\"#new-target属性用在构造函数之中可以确定构造函数是怎么调用的，正常返回new命令作用于的构造函数，如果构造函数不是通过new命令调用的，new-target返回undefined\" class=\"headerlink\" title=\"new.target属性用在构造函数之中可以确定构造函数是怎么调用的，正常返回new命令作用于的构造函数，如果构造函数不是通过new命令调用的，new.target返回undefined\"></a>new.target属性用在构造函数之中可以确定构造函数是怎么调用的，正常返回new命令作用于的构造函数，如果构造函数不是通过new命令调用的，new.target返回undefined</h4><ul>\n<li>Class内部调用new.target，返回当前Class</li>\n<li>子类继承父类时，new.target返回子类[可以用来写不能单独使用必须继承后才可使用的类]</li>\n<li>函数外部，使用new.target会报错</li>\n</ul>\n</li>\n</ul>"},{"title":"深入JS中的作用域和执行上下文","date":"2018-06-24T07:58:03.000Z","about":null,"_content":"\n#### 作用域：代码中定义变量的区域，确定执行代码访问变量的权限。\n\n> JS采用词法作用域（静态作用域），所以函数的作用域在函数定义的时候就决定了，也就是说函数的作用域基于函数创建的位置。相对的是动态作用域，函数的作用域在函数调用的时候决定。\n\n**作用域分类：全局作用域、函数作用域和eval()作用域（不讨论）**\n\n> JS代码的整个执行过程，分为两个阶段：代码编译阶段和代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码。执行阶段由js引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。\n\n<!--more-->\n\n#### 执行上下文\n\n> 当JS执行到一段可执行代码的时候就会创建对应的执行上下文，JS引擎创建了执行上下文栈（ECS）管理执行上下文。执行上下文有三个重要属性：变量对象（VO）、作用域链（Scope Chain）、this。\n\n执行上下文的生命周期可以分为两个阶段：**创建阶段和代码执行阶段。**\n\n#### 创建上下文阶段\n> 在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。\n\n##### 变量对象（VO）\n> 与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。\n\n1. 全局上下文中的变量对象初始化是全局对象\n2. 函数上下文中的变量对象（VO只包括Arguments对象\n3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始化的属性值，这个时候VO会被激活为AO\n4. 代码执行阶段，会再次修改变量对象的属性值\n\n##### >变量对象的创建\n1. 建立arguments对象，检查当前上下文中的参数，建立该对象下的属性与属性值\n2. 检查当前上下文中的函数声明，在VO中以函数名建立一个属性，函数所在内存地址的引用为属性值。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖\n3. 检查当前的变量声明，在VO中以变量名建立一个属性名，属性值为undefined。如果该变量名已经存在，为了防止同名函数被修改为undefined，会直接跳过该变量，原属性值不会被修改\n\n#### 代码执行阶段\n> **顺序执行代码**，根据代码，修改变量对象的值\n\n总结完了那看两个代码吧~\n\n```\nconsole.log(foo);\nfunction foo() { \n    console.log('function foo') \n}\nvar foo = 20;\n```\n\n```\n// 首先，创建上下文阶段：\n\nEC = {\n    VO: {},\n    scopeChain: {},\n    this: '',\n}\n\n// 接着，创建变量对象：\nVO = {\n    arguments: {···},\n    foo: <foo reference> // 表示函数foo的地址引用\n    // 因为在检查var声明的变量foo的时候发现与当前的变量对象中的foo属性同名，则忽略给其赋值undefined\n}\n\n// 进入执行阶段，VO-->AO，顺序执行代码\nAO = {\n    arguments: {···},\n    foo: <foo reference>\n}\n\n// 执行顺序变成如下：\nfunction foo() { // 这里foo函数在函数上下文顶部是因为函数声明提升\n    console.log('function foo') \n}\nconsole.log(foo); // ƒ foo() { console.log('function foo') }\nfoo = 20; // 顺序执行代码到这里，才会给var声明的同名变量赋值\n```\n\n```\nfunction foo() { \n    console.log('function foo') \n}\nvar foo = 20;\nconsole.log(foo);\n```\n\n```\n// 首先，创建上下文阶段：\n\nEC = {\n    VO: {},\n    scopeChain: {},\n    this: '',\n}\n\n// 接着，创建变量对象：\nVO = {\n    arguments: {···},\n    foo: <foo reference> // 表示函数foo的地址引用\n    // 因为在检查var声明的变量foo的时候发现与当前的变量对象中的foo属性同名，则忽略给其赋值undefined\n}\n\n// 进入执行阶段，VO-->AO，顺序执行代码\nAO = {\n    arguments: {···},\n    foo: <foo reference>\n}\n\n// 执行顺序变成如下：\nfunction foo() { // 这里foo函数在函数上下文顶部是因为函数声明提升\n    console.log('function foo') \n}\nfoo = 20;\nconsole.log(foo); // 20\n```\n\n\n","source":"_posts/深入JS中的作用域和执行上下文.md","raw":"---\ntitle: 深入JS中的作用域和执行上下文\ndate: 2018-06-24 15:58:03\ntags: \n- 作用域\n- 执行上下文\ncategories: ES5\nabout:\n---\n\n#### 作用域：代码中定义变量的区域，确定执行代码访问变量的权限。\n\n> JS采用词法作用域（静态作用域），所以函数的作用域在函数定义的时候就决定了，也就是说函数的作用域基于函数创建的位置。相对的是动态作用域，函数的作用域在函数调用的时候决定。\n\n**作用域分类：全局作用域、函数作用域和eval()作用域（不讨论）**\n\n> JS代码的整个执行过程，分为两个阶段：代码编译阶段和代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码。执行阶段由js引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。\n\n<!--more-->\n\n#### 执行上下文\n\n> 当JS执行到一段可执行代码的时候就会创建对应的执行上下文，JS引擎创建了执行上下文栈（ECS）管理执行上下文。执行上下文有三个重要属性：变量对象（VO）、作用域链（Scope Chain）、this。\n\n执行上下文的生命周期可以分为两个阶段：**创建阶段和代码执行阶段。**\n\n#### 创建上下文阶段\n> 在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。\n\n##### 变量对象（VO）\n> 与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。\n\n1. 全局上下文中的变量对象初始化是全局对象\n2. 函数上下文中的变量对象（VO只包括Arguments对象\n3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始化的属性值，这个时候VO会被激活为AO\n4. 代码执行阶段，会再次修改变量对象的属性值\n\n##### >变量对象的创建\n1. 建立arguments对象，检查当前上下文中的参数，建立该对象下的属性与属性值\n2. 检查当前上下文中的函数声明，在VO中以函数名建立一个属性，函数所在内存地址的引用为属性值。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖\n3. 检查当前的变量声明，在VO中以变量名建立一个属性名，属性值为undefined。如果该变量名已经存在，为了防止同名函数被修改为undefined，会直接跳过该变量，原属性值不会被修改\n\n#### 代码执行阶段\n> **顺序执行代码**，根据代码，修改变量对象的值\n\n总结完了那看两个代码吧~\n\n```\nconsole.log(foo);\nfunction foo() { \n    console.log('function foo') \n}\nvar foo = 20;\n```\n\n```\n// 首先，创建上下文阶段：\n\nEC = {\n    VO: {},\n    scopeChain: {},\n    this: '',\n}\n\n// 接着，创建变量对象：\nVO = {\n    arguments: {···},\n    foo: <foo reference> // 表示函数foo的地址引用\n    // 因为在检查var声明的变量foo的时候发现与当前的变量对象中的foo属性同名，则忽略给其赋值undefined\n}\n\n// 进入执行阶段，VO-->AO，顺序执行代码\nAO = {\n    arguments: {···},\n    foo: <foo reference>\n}\n\n// 执行顺序变成如下：\nfunction foo() { // 这里foo函数在函数上下文顶部是因为函数声明提升\n    console.log('function foo') \n}\nconsole.log(foo); // ƒ foo() { console.log('function foo') }\nfoo = 20; // 顺序执行代码到这里，才会给var声明的同名变量赋值\n```\n\n```\nfunction foo() { \n    console.log('function foo') \n}\nvar foo = 20;\nconsole.log(foo);\n```\n\n```\n// 首先，创建上下文阶段：\n\nEC = {\n    VO: {},\n    scopeChain: {},\n    this: '',\n}\n\n// 接着，创建变量对象：\nVO = {\n    arguments: {···},\n    foo: <foo reference> // 表示函数foo的地址引用\n    // 因为在检查var声明的变量foo的时候发现与当前的变量对象中的foo属性同名，则忽略给其赋值undefined\n}\n\n// 进入执行阶段，VO-->AO，顺序执行代码\nAO = {\n    arguments: {···},\n    foo: <foo reference>\n}\n\n// 执行顺序变成如下：\nfunction foo() { // 这里foo函数在函数上下文顶部是因为函数声明提升\n    console.log('function foo') \n}\nfoo = 20;\nconsole.log(foo); // 20\n```\n\n\n","slug":"深入JS中的作用域和执行上下文","published":1,"updated":"2019-02-22T08:37:33.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugrou000ovrieniz0067f","content":"<h4 id=\"作用域：代码中定义变量的区域，确定执行代码访问变量的权限。\"><a href=\"#作用域：代码中定义变量的区域，确定执行代码访问变量的权限。\" class=\"headerlink\" title=\"作用域：代码中定义变量的区域，确定执行代码访问变量的权限。\"></a>作用域：代码中定义变量的区域，确定执行代码访问变量的权限。</h4><blockquote>\n<p>JS采用词法作用域（静态作用域），所以函数的作用域在函数定义的时候就决定了，也就是说函数的作用域基于函数创建的位置。相对的是动态作用域，函数的作用域在函数调用的时候决定。</p>\n</blockquote>\n<p><strong>作用域分类：全局作用域、函数作用域和eval()作用域（不讨论）</strong></p>\n<blockquote>\n<p>JS代码的整个执行过程，分为两个阶段：代码编译阶段和代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码。执行阶段由js引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</p>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a>执行上下文</h4><blockquote>\n<p>当JS执行到一段可执行代码的时候就会创建对应的执行上下文，JS引擎创建了执行上下文栈（ECS）管理执行上下文。执行上下文有三个重要属性：变量对象（VO）、作用域链（Scope Chain）、this。</p>\n</blockquote>\n<p>执行上下文的生命周期可以分为两个阶段：<strong>创建阶段和代码执行阶段。</strong></p>\n<h4 id=\"创建上下文阶段\"><a href=\"#创建上下文阶段\" class=\"headerlink\" title=\"创建上下文阶段\"></a>创建上下文阶段</h4><blockquote>\n<p>在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。</p>\n</blockquote>\n<h5 id=\"变量对象（VO）\"><a href=\"#变量对象（VO）\" class=\"headerlink\" title=\"变量对象（VO）\"></a>变量对象（VO）</h5><blockquote>\n<p>与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p>\n</blockquote>\n<ol>\n<li>全局上下文中的变量对象初始化是全局对象</li>\n<li>函数上下文中的变量对象（VO只包括Arguments对象</li>\n<li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始化的属性值，这个时候VO会被激活为AO</li>\n<li>代码执行阶段，会再次修改变量对象的属性值</li>\n</ol>\n<h5 id=\"gt-变量对象的创建\"><a href=\"#gt-变量对象的创建\" class=\"headerlink\" title=\"&gt;变量对象的创建\"></a>&gt;变量对象的创建</h5><ol>\n<li>建立arguments对象，检查当前上下文中的参数，建立该对象下的属性与属性值</li>\n<li>检查当前上下文中的函数声明，在VO中以函数名建立一个属性，函数所在内存地址的引用为属性值。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖</li>\n<li>检查当前的变量声明，在VO中以变量名建立一个属性名，属性值为undefined。如果该变量名已经存在，为了防止同名函数被修改为undefined，会直接跳过该变量，原属性值不会被修改</li>\n</ol>\n<h4 id=\"代码执行阶段\"><a href=\"#代码执行阶段\" class=\"headerlink\" title=\"代码执行阶段\"></a>代码执行阶段</h4><blockquote>\n<p><strong>顺序执行代码</strong>，根据代码，修改变量对象的值</p>\n</blockquote>\n<p>总结完了那看两个代码吧~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(foo);</span><br><span class=\"line\">function foo() &#123; </span><br><span class=\"line\">    console.log(&apos;function foo&apos;) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = 20;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 首先，创建上下文阶段：</span><br><span class=\"line\"></span><br><span class=\"line\">EC = &#123;</span><br><span class=\"line\">    VO: &#123;&#125;,</span><br><span class=\"line\">    scopeChain: &#123;&#125;,</span><br><span class=\"line\">    this: &apos;&apos;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 接着，创建变量对象：</span><br><span class=\"line\">VO = &#123;</span><br><span class=\"line\">    arguments: &#123;···&#125;,</span><br><span class=\"line\">    foo: &lt;foo reference&gt; // 表示函数foo的地址引用</span><br><span class=\"line\">    // 因为在检查var声明的变量foo的时候发现与当前的变量对象中的foo属性同名，则忽略给其赋值undefined</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 进入执行阶段，VO--&gt;AO，顺序执行代码</span><br><span class=\"line\">AO = &#123;</span><br><span class=\"line\">    arguments: &#123;···&#125;,</span><br><span class=\"line\">    foo: &lt;foo reference&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 执行顺序变成如下：</span><br><span class=\"line\">function foo() &#123; // 这里foo函数在函数上下文顶部是因为函数声明提升</span><br><span class=\"line\">    console.log(&apos;function foo&apos;) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(foo); // ƒ foo() &#123; console.log(&apos;function foo&apos;) &#125;</span><br><span class=\"line\">foo = 20; // 顺序执行代码到这里，才会给var声明的同名变量赋值</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123; </span><br><span class=\"line\">    console.log(&apos;function foo&apos;) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = 20;</span><br><span class=\"line\">console.log(foo);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 首先，创建上下文阶段：</span><br><span class=\"line\"></span><br><span class=\"line\">EC = &#123;</span><br><span class=\"line\">    VO: &#123;&#125;,</span><br><span class=\"line\">    scopeChain: &#123;&#125;,</span><br><span class=\"line\">    this: &apos;&apos;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 接着，创建变量对象：</span><br><span class=\"line\">VO = &#123;</span><br><span class=\"line\">    arguments: &#123;···&#125;,</span><br><span class=\"line\">    foo: &lt;foo reference&gt; // 表示函数foo的地址引用</span><br><span class=\"line\">    // 因为在检查var声明的变量foo的时候发现与当前的变量对象中的foo属性同名，则忽略给其赋值undefined</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 进入执行阶段，VO--&gt;AO，顺序执行代码</span><br><span class=\"line\">AO = &#123;</span><br><span class=\"line\">    arguments: &#123;···&#125;,</span><br><span class=\"line\">    foo: &lt;foo reference&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 执行顺序变成如下：</span><br><span class=\"line\">function foo() &#123; // 这里foo函数在函数上下文顶部是因为函数声明提升</span><br><span class=\"line\">    console.log(&apos;function foo&apos;) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo = 20;</span><br><span class=\"line\">console.log(foo); // 20</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h4 id=\"作用域：代码中定义变量的区域，确定执行代码访问变量的权限。\"><a href=\"#作用域：代码中定义变量的区域，确定执行代码访问变量的权限。\" class=\"headerlink\" title=\"作用域：代码中定义变量的区域，确定执行代码访问变量的权限。\"></a>作用域：代码中定义变量的区域，确定执行代码访问变量的权限。</h4><blockquote>\n<p>JS采用词法作用域（静态作用域），所以函数的作用域在函数定义的时候就决定了，也就是说函数的作用域基于函数创建的位置。相对的是动态作用域，函数的作用域在函数调用的时候决定。</p>\n</blockquote>\n<p><strong>作用域分类：全局作用域、函数作用域和eval()作用域（不讨论）</strong></p>\n<blockquote>\n<p>JS代码的整个执行过程，分为两个阶段：代码编译阶段和代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码。执行阶段由js引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</p>\n</blockquote>","more":"<h4 id=\"执行上下文\"><a href=\"#执行上下文\" class=\"headerlink\" title=\"执行上下文\"></a>执行上下文</h4><blockquote>\n<p>当JS执行到一段可执行代码的时候就会创建对应的执行上下文，JS引擎创建了执行上下文栈（ECS）管理执行上下文。执行上下文有三个重要属性：变量对象（VO）、作用域链（Scope Chain）、this。</p>\n</blockquote>\n<p>执行上下文的生命周期可以分为两个阶段：<strong>创建阶段和代码执行阶段。</strong></p>\n<h4 id=\"创建上下文阶段\"><a href=\"#创建上下文阶段\" class=\"headerlink\" title=\"创建上下文阶段\"></a>创建上下文阶段</h4><blockquote>\n<p>在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向。</p>\n</blockquote>\n<h5 id=\"变量对象（VO）\"><a href=\"#变量对象（VO）\" class=\"headerlink\" title=\"变量对象（VO）\"></a>变量对象（VO）</h5><blockquote>\n<p>与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p>\n</blockquote>\n<ol>\n<li>全局上下文中的变量对象初始化是全局对象</li>\n<li>函数上下文中的变量对象（VO只包括Arguments对象</li>\n<li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始化的属性值，这个时候VO会被激活为AO</li>\n<li>代码执行阶段，会再次修改变量对象的属性值</li>\n</ol>\n<h5 id=\"gt-变量对象的创建\"><a href=\"#gt-变量对象的创建\" class=\"headerlink\" title=\"&gt;变量对象的创建\"></a>&gt;变量对象的创建</h5><ol>\n<li>建立arguments对象，检查当前上下文中的参数，建立该对象下的属性与属性值</li>\n<li>检查当前上下文中的函数声明，在VO中以函数名建立一个属性，函数所在内存地址的引用为属性值。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖</li>\n<li>检查当前的变量声明，在VO中以变量名建立一个属性名，属性值为undefined。如果该变量名已经存在，为了防止同名函数被修改为undefined，会直接跳过该变量，原属性值不会被修改</li>\n</ol>\n<h4 id=\"代码执行阶段\"><a href=\"#代码执行阶段\" class=\"headerlink\" title=\"代码执行阶段\"></a>代码执行阶段</h4><blockquote>\n<p><strong>顺序执行代码</strong>，根据代码，修改变量对象的值</p>\n</blockquote>\n<p>总结完了那看两个代码吧~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(foo);</span><br><span class=\"line\">function foo() &#123; </span><br><span class=\"line\">    console.log(&apos;function foo&apos;) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = 20;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 首先，创建上下文阶段：</span><br><span class=\"line\"></span><br><span class=\"line\">EC = &#123;</span><br><span class=\"line\">    VO: &#123;&#125;,</span><br><span class=\"line\">    scopeChain: &#123;&#125;,</span><br><span class=\"line\">    this: &apos;&apos;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 接着，创建变量对象：</span><br><span class=\"line\">VO = &#123;</span><br><span class=\"line\">    arguments: &#123;···&#125;,</span><br><span class=\"line\">    foo: &lt;foo reference&gt; // 表示函数foo的地址引用</span><br><span class=\"line\">    // 因为在检查var声明的变量foo的时候发现与当前的变量对象中的foo属性同名，则忽略给其赋值undefined</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 进入执行阶段，VO--&gt;AO，顺序执行代码</span><br><span class=\"line\">AO = &#123;</span><br><span class=\"line\">    arguments: &#123;···&#125;,</span><br><span class=\"line\">    foo: &lt;foo reference&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 执行顺序变成如下：</span><br><span class=\"line\">function foo() &#123; // 这里foo函数在函数上下文顶部是因为函数声明提升</span><br><span class=\"line\">    console.log(&apos;function foo&apos;) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(foo); // ƒ foo() &#123; console.log(&apos;function foo&apos;) &#125;</span><br><span class=\"line\">foo = 20; // 顺序执行代码到这里，才会给var声明的同名变量赋值</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123; </span><br><span class=\"line\">    console.log(&apos;function foo&apos;) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var foo = 20;</span><br><span class=\"line\">console.log(foo);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 首先，创建上下文阶段：</span><br><span class=\"line\"></span><br><span class=\"line\">EC = &#123;</span><br><span class=\"line\">    VO: &#123;&#125;,</span><br><span class=\"line\">    scopeChain: &#123;&#125;,</span><br><span class=\"line\">    this: &apos;&apos;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 接着，创建变量对象：</span><br><span class=\"line\">VO = &#123;</span><br><span class=\"line\">    arguments: &#123;···&#125;,</span><br><span class=\"line\">    foo: &lt;foo reference&gt; // 表示函数foo的地址引用</span><br><span class=\"line\">    // 因为在检查var声明的变量foo的时候发现与当前的变量对象中的foo属性同名，则忽略给其赋值undefined</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 进入执行阶段，VO--&gt;AO，顺序执行代码</span><br><span class=\"line\">AO = &#123;</span><br><span class=\"line\">    arguments: &#123;···&#125;,</span><br><span class=\"line\">    foo: &lt;foo reference&gt;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 执行顺序变成如下：</span><br><span class=\"line\">function foo() &#123; // 这里foo函数在函数上下文顶部是因为函数声明提升</span><br><span class=\"line\">    console.log(&apos;function foo&apos;) </span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo = 20;</span><br><span class=\"line\">console.log(foo); // 20</span><br></pre></td></tr></table></figure>"},{"title":"浅谈Webpack模块化实现原理","date":"2018-05-23T11:06:12.000Z","about":null,"_content":"先上总结吧，后面有代码分析：\n\n##### 总结：webpack的模块化原理是酱紫的——首先我们需要在webpack.config.js中取指定入口文件，完了分析webpack编译后的文件可以看到，整个文件由一个自执行函数包裹，入参是一个数组，这个数组包含了所有的模块，函数体的逻辑就是webpack的模块化逻辑。其中有一个函数叫__webpack_require__，参数为moduleId，然后在这个函数体的末尾调用了他传入参数为0并返回，这个0指代的模块就是我们的入口模块。也就是说，从入参的modules数组中取第一个函数进行调用，并传入了module，module.exports以及__webpack_require__这三个参数，然后你可以在入口函数的函数体内看到又调用了__webpack_require__(1)···等等来调用入口文件中所有后续需要的模块，这样就会引入后续的第二个第三个····函数，从第二个函数开始的入参exports，都是这个模块的module.exports通过对象的引用传参，这个模块中需要的其他模块也都是通过__webpack_require__来引的，最终会将module.exports return出来。\n\n<!--more-->\n\nwebpack(1.x)编译后的文件：\n\n```\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t(function(root) {\n\t\n\t    __webpack_require__(1);\n\t    __webpack_require__(5);\n\t    __webpack_require__(7);\n\t\n\t    var homepage = __webpack_require__(67);\n\t    var homepageWiki = __webpack_require__(73);\n\t    var homepageSetting = __webpack_require__(75);\n\t    Vue.use(VueRouter);\n\t    var App = Vue.extend({});\n\t    var router = new VueRouter();\n\t    root.router = router;\n\t    router.map({\n\t        '/': {\n\t            component: login\n\t        },\n\t        '/login': {\n\t            name: 'login',\n\t            component: login\n\t        }\n\t   });\n\t   router.start(App, '#app');\n\t})(window);\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\tvar getHeaders = __webpack_require__(71);\n\tvar baseAjax = function(api, data, callback) {\n\t    var headers = getHeaders();\n\t    // console.log(api, '')\n\t    // console.log(headers);\n\t    $.ajax({\n\t        url: api,\n\t        type: 'POST',\n\t        dataType: 'json',\n\t        data: data,\n\t        success: callback,\n\t        headers: headers\n\t    });\n\t};\n\tmodule.exports = baseAjax;\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\tvar baseAjax = __webpack_require__(70);\n\tmodule.exports = {\n\t}\n/***/ }),\n/******/ ]);\n```\n\nwebpack.config.js文件：\n\n```\nvar webpack = require('webpack');\nvar ExtractTextPlugin = require('extract-text-webpack-plugin');//将所有css文件导成一个\nvar extractLESS = new ExtractTextPlugin('./css/[name].less');\nvar extractCSS = new ExtractTextPlugin('./css/[name].css');\n// var proxy = require('http-proxy-middleware');\n\nmodule.exports = {\n\tentry : __dirname + '/src/app.js',\n\toutput : {\n\t\tpath : __dirname + '/lastpack',\n\t\tfilename : '[name].pack.js'\n\t},\n\tmodule : {\n\t\tloaders : [\n\t\t\t{\n\t\t\t\ttest : /\\.html$/,\n\t\t\t\tloader : 'html'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttest : /\\.(css|less)/,\n\t\t\t\tloader : ExtractTextPlugin.extract('style', 'css!less'),\n\t\t\t\texclude: '/lastpack/'\n\t\t\t}\n\t\t]\n\t},\n\texternals : {\n\t\t'vue' : 'Vue',\n\t\t'vue-router' : 'VueRouter' //在项目中require的类库不会被合并到出口文件\n\t},\n\tplugins : [\n\t\textractCSS,\n\t\tnew webpack.optimize.UglifyJsPlugin({// webpack内置插件压缩JS/CSS\n\t\t\tcompress : {\n\t\t\t\twarnings : false\n\t\t\t}\n\t\t})\n\t],\n\tdevServer: {\n\t\tproxy: {\n\t\t\t'/api/*': {\n\t\t\t\ttarget: 'https://localhost',\n\t\t\t\tchangeOrigin: true\n\t\t\t}\n\t\t}\n\t}\n};\n```\n\n精简一下代码：\n\n```\n(function(modules){\n})([]);\n```\n这块的自执行函数的入参是个数组，这个数组包含了所有模块，这些模块都包裹在函数中。自执行函数体里的逻辑就是处理模块的逻辑，关键就在__webpack_require__这个函数，这个函数就是require的替代。自执行函数的函数体里先定义了这个函数，然后调用了他并传入一个moduleId，这个例子中是0，也就是我们的入口模块__dirname + '/src/app.js'的内容。\n\n__webpack_require__内部执行了\n\n```\n// Execute the module function\nmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n// Flag the module as loaded\nmodule.loaded = true;\n// Return the exports of the module\nreturn module.exports;\n```\n也就是从入参的modules数组中取第一个函数进行调用，并传入了module，module.exports以及__webpack_require__，再看第一个函数（入口函数）的逻辑：\n\n```\nfunction(module, exports, __webpack_require__) {\n\n\t(function(root) {\n\t\n\t    __webpack_require__(1);\n\t    __webpack_require__(5);\n\t    __webpack_require__(7);\n\t    ···\n\t});\n}\n```\n可以看到入口模块又调用了__webpack_require__(1)去引入第二个函数。\n\n这里入参的exports就是这个模块的module.exports通过对象的引用传参，最后会将module.exports return出来。到这里就完成了__webpack_require__的使命。\n\n比如说在入口模块中又调用了__webpack_require__(1)，就会得到这个模块返回的module.exports。\n","source":"_posts/浅谈Webpack模块化实现原理.md","raw":"---\ntitle: 浅谈Webpack模块化实现原理\ndate: 2018-05-23 19:06:12\ntags:\n- Webpack\ncategories: 前端构建工具\nabout:\n---\n先上总结吧，后面有代码分析：\n\n##### 总结：webpack的模块化原理是酱紫的——首先我们需要在webpack.config.js中取指定入口文件，完了分析webpack编译后的文件可以看到，整个文件由一个自执行函数包裹，入参是一个数组，这个数组包含了所有的模块，函数体的逻辑就是webpack的模块化逻辑。其中有一个函数叫__webpack_require__，参数为moduleId，然后在这个函数体的末尾调用了他传入参数为0并返回，这个0指代的模块就是我们的入口模块。也就是说，从入参的modules数组中取第一个函数进行调用，并传入了module，module.exports以及__webpack_require__这三个参数，然后你可以在入口函数的函数体内看到又调用了__webpack_require__(1)···等等来调用入口文件中所有后续需要的模块，这样就会引入后续的第二个第三个····函数，从第二个函数开始的入参exports，都是这个模块的module.exports通过对象的引用传参，这个模块中需要的其他模块也都是通过__webpack_require__来引的，最终会将module.exports return出来。\n\n<!--more-->\n\nwebpack(1.x)编译后的文件：\n\n```\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t(function(root) {\n\t\n\t    __webpack_require__(1);\n\t    __webpack_require__(5);\n\t    __webpack_require__(7);\n\t\n\t    var homepage = __webpack_require__(67);\n\t    var homepageWiki = __webpack_require__(73);\n\t    var homepageSetting = __webpack_require__(75);\n\t    Vue.use(VueRouter);\n\t    var App = Vue.extend({});\n\t    var router = new VueRouter();\n\t    root.router = router;\n\t    router.map({\n\t        '/': {\n\t            component: login\n\t        },\n\t        '/login': {\n\t            name: 'login',\n\t            component: login\n\t        }\n\t   });\n\t   router.start(App, '#app');\n\t})(window);\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\tvar getHeaders = __webpack_require__(71);\n\tvar baseAjax = function(api, data, callback) {\n\t    var headers = getHeaders();\n\t    // console.log(api, '')\n\t    // console.log(headers);\n\t    $.ajax({\n\t        url: api,\n\t        type: 'POST',\n\t        dataType: 'json',\n\t        data: data,\n\t        success: callback,\n\t        headers: headers\n\t    });\n\t};\n\tmodule.exports = baseAjax;\n/***/ }),\n/* 77 */\n/***/ (function(module, exports, __webpack_require__) {\n\tvar baseAjax = __webpack_require__(70);\n\tmodule.exports = {\n\t}\n/***/ }),\n/******/ ]);\n```\n\nwebpack.config.js文件：\n\n```\nvar webpack = require('webpack');\nvar ExtractTextPlugin = require('extract-text-webpack-plugin');//将所有css文件导成一个\nvar extractLESS = new ExtractTextPlugin('./css/[name].less');\nvar extractCSS = new ExtractTextPlugin('./css/[name].css');\n// var proxy = require('http-proxy-middleware');\n\nmodule.exports = {\n\tentry : __dirname + '/src/app.js',\n\toutput : {\n\t\tpath : __dirname + '/lastpack',\n\t\tfilename : '[name].pack.js'\n\t},\n\tmodule : {\n\t\tloaders : [\n\t\t\t{\n\t\t\t\ttest : /\\.html$/,\n\t\t\t\tloader : 'html'\n\t\t\t},\n\t\t\t{\n\t\t\t\ttest : /\\.(css|less)/,\n\t\t\t\tloader : ExtractTextPlugin.extract('style', 'css!less'),\n\t\t\t\texclude: '/lastpack/'\n\t\t\t}\n\t\t]\n\t},\n\texternals : {\n\t\t'vue' : 'Vue',\n\t\t'vue-router' : 'VueRouter' //在项目中require的类库不会被合并到出口文件\n\t},\n\tplugins : [\n\t\textractCSS,\n\t\tnew webpack.optimize.UglifyJsPlugin({// webpack内置插件压缩JS/CSS\n\t\t\tcompress : {\n\t\t\t\twarnings : false\n\t\t\t}\n\t\t})\n\t],\n\tdevServer: {\n\t\tproxy: {\n\t\t\t'/api/*': {\n\t\t\t\ttarget: 'https://localhost',\n\t\t\t\tchangeOrigin: true\n\t\t\t}\n\t\t}\n\t}\n};\n```\n\n精简一下代码：\n\n```\n(function(modules){\n})([]);\n```\n这块的自执行函数的入参是个数组，这个数组包含了所有模块，这些模块都包裹在函数中。自执行函数体里的逻辑就是处理模块的逻辑，关键就在__webpack_require__这个函数，这个函数就是require的替代。自执行函数的函数体里先定义了这个函数，然后调用了他并传入一个moduleId，这个例子中是0，也就是我们的入口模块__dirname + '/src/app.js'的内容。\n\n__webpack_require__内部执行了\n\n```\n// Execute the module function\nmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n// Flag the module as loaded\nmodule.loaded = true;\n// Return the exports of the module\nreturn module.exports;\n```\n也就是从入参的modules数组中取第一个函数进行调用，并传入了module，module.exports以及__webpack_require__，再看第一个函数（入口函数）的逻辑：\n\n```\nfunction(module, exports, __webpack_require__) {\n\n\t(function(root) {\n\t\n\t    __webpack_require__(1);\n\t    __webpack_require__(5);\n\t    __webpack_require__(7);\n\t    ···\n\t});\n}\n```\n可以看到入口模块又调用了__webpack_require__(1)去引入第二个函数。\n\n这里入参的exports就是这个模块的module.exports通过对象的引用传参，最后会将module.exports return出来。到这里就完成了__webpack_require__的使命。\n\n比如说在入口模块中又调用了__webpack_require__(1)，就会得到这个模块返回的module.exports。\n","slug":"浅谈Webpack模块化实现原理","published":1,"updated":"2019-02-22T08:37:33.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugrov000rvriebv9mmrdw","content":"<p>先上总结吧，后面有代码分析：</p>\n<h5 id=\"总结：webpack的模块化原理是酱紫的——首先我们需要在webpack-config-js中取指定入口文件，完了分析webpack编译后的文件可以看到，整个文件由一个自执行函数包裹，入参是一个数组，这个数组包含了所有的模块，函数体的逻辑就是webpack的模块化逻辑。其中有一个函数叫webpack-require，参数为moduleId，然后在这个函数体的末尾调用了他传入参数为0并返回，这个0指代的模块就是我们的入口模块。也就是说，从入参的modules数组中取第一个函数进行调用，并传入了module，module-exports以及webpack-require这三个参数，然后你可以在入口函数的函数体内看到又调用了webpack-require-1-···等等来调用入口文件中所有后续需要的模块，这样就会引入后续的第二个第三个····函数，从第二个函数开始的入参exports，都是这个模块的module-exports通过对象的引用传参，这个模块中需要的其他模块也都是通过webpack-require来引的，最终会将module-exports-return出来。\"><a href=\"#总结：webpack的模块化原理是酱紫的——首先我们需要在webpack-config-js中取指定入口文件，完了分析webpack编译后的文件可以看到，整个文件由一个自执行函数包裹，入参是一个数组，这个数组包含了所有的模块，函数体的逻辑就是webpack的模块化逻辑。其中有一个函数叫webpack-require，参数为moduleId，然后在这个函数体的末尾调用了他传入参数为0并返回，这个0指代的模块就是我们的入口模块。也就是说，从入参的modules数组中取第一个函数进行调用，并传入了module，module-exports以及webpack-require这三个参数，然后你可以在入口函数的函数体内看到又调用了webpack-require-1-···等等来调用入口文件中所有后续需要的模块，这样就会引入后续的第二个第三个····函数，从第二个函数开始的入参exports，都是这个模块的module-exports通过对象的引用传参，这个模块中需要的其他模块也都是通过webpack-require来引的，最终会将module-exports-return出来。\" class=\"headerlink\" title=\"总结：webpack的模块化原理是酱紫的——首先我们需要在webpack.config.js中取指定入口文件，完了分析webpack编译后的文件可以看到，整个文件由一个自执行函数包裹，入参是一个数组，这个数组包含了所有的模块，函数体的逻辑就是webpack的模块化逻辑。其中有一个函数叫webpack_require，参数为moduleId，然后在这个函数体的末尾调用了他传入参数为0并返回，这个0指代的模块就是我们的入口模块。也就是说，从入参的modules数组中取第一个函数进行调用，并传入了module，module.exports以及webpack_require这三个参数，然后你可以在入口函数的函数体内看到又调用了webpack_require(1)···等等来调用入口文件中所有后续需要的模块，这样就会引入后续的第二个第三个····函数，从第二个函数开始的入参exports，都是这个模块的module.exports通过对象的引用传参，这个模块中需要的其他模块也都是通过webpack_require来引的，最终会将module.exports return出来。\"></a>总结：webpack的模块化原理是酱紫的——首先我们需要在webpack.config.js中取指定入口文件，完了分析webpack编译后的文件可以看到，整个文件由一个自执行函数包裹，入参是一个数组，这个数组包含了所有的模块，函数体的逻辑就是webpack的模块化逻辑。其中有一个函数叫<strong>webpack_require</strong>，参数为moduleId，然后在这个函数体的末尾调用了他传入参数为0并返回，这个0指代的模块就是我们的入口模块。也就是说，从入参的modules数组中取第一个函数进行调用，并传入了module，module.exports以及<strong>webpack_require</strong>这三个参数，然后你可以在入口函数的函数体内看到又调用了<strong>webpack_require</strong>(1)···等等来调用入口文件中所有后续需要的模块，这样就会引入后续的第二个第三个····函数，从第二个函数开始的入参exports，都是这个模块的module.exports通过对象的引用传参，这个模块中需要的其他模块也都是通过<strong>webpack_require</strong>来引的，最终会将module.exports return出来。</h5><a id=\"more\"></a>\n<p>webpack(1.x)编译后的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/******/ (function(modules) &#123; // webpackBootstrap</span><br><span class=\"line\">/******/ \t// The module cache</span><br><span class=\"line\">/******/ \tvar installedModules = &#123;&#125;;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t// The require function</span><br><span class=\"line\">/******/ \tfunction __webpack_require__(moduleId) &#123;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t\t// Check if module is in cache</span><br><span class=\"line\">/******/ \t\tif(installedModules[moduleId])</span><br><span class=\"line\">/******/ \t\t\treturn installedModules[moduleId].exports;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t\t// Create a new module (and put it into the cache)</span><br><span class=\"line\">/******/ \t\tvar module = installedModules[moduleId] = &#123;</span><br><span class=\"line\">/******/ \t\t\texports: &#123;&#125;,</span><br><span class=\"line\">/******/ \t\t\tid: moduleId,</span><br><span class=\"line\">/******/ \t\t\tloaded: false</span><br><span class=\"line\">/******/ \t\t&#125;;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t\t// Execute the module function</span><br><span class=\"line\">/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t\t// Flag the module as loaded</span><br><span class=\"line\">/******/ \t\tmodule.loaded = true;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t\t// Return the exports of the module</span><br><span class=\"line\">/******/ \t\treturn module.exports;</span><br><span class=\"line\">/******/ \t&#125;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t// expose the modules object (__webpack_modules__)</span><br><span class=\"line\">/******/ \t__webpack_require__.m = modules;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t// expose the module cache</span><br><span class=\"line\">/******/ \t__webpack_require__.c = installedModules;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t// __webpack_public_path__</span><br><span class=\"line\">/******/ \t__webpack_require__.p = &quot;&quot;;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t// Load entry module and return exports</span><br><span class=\"line\">/******/ \treturn __webpack_require__(0);</span><br><span class=\"line\">/******/ &#125;)</span><br><span class=\"line\">/************************************************************************/</span><br><span class=\"line\">/******/ ([</span><br><span class=\"line\">/* 0 */</span><br><span class=\"line\">/***/ (function(module, exports, __webpack_require__) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t(function(root) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    __webpack_require__(1);</span><br><span class=\"line\">\t    __webpack_require__(5);</span><br><span class=\"line\">\t    __webpack_require__(7);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    var homepage = __webpack_require__(67);</span><br><span class=\"line\">\t    var homepageWiki = __webpack_require__(73);</span><br><span class=\"line\">\t    var homepageSetting = __webpack_require__(75);</span><br><span class=\"line\">\t    Vue.use(VueRouter);</span><br><span class=\"line\">\t    var App = Vue.extend(&#123;&#125;);</span><br><span class=\"line\">\t    var router = new VueRouter();</span><br><span class=\"line\">\t    root.router = router;</span><br><span class=\"line\">\t    router.map(&#123;</span><br><span class=\"line\">\t        &apos;/&apos;: &#123;</span><br><span class=\"line\">\t            component: login</span><br><span class=\"line\">\t        &#125;,</span><br><span class=\"line\">\t        &apos;/login&apos;: &#123;</span><br><span class=\"line\">\t            name: &apos;login&apos;,</span><br><span class=\"line\">\t            component: login</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t   &#125;);</span><br><span class=\"line\">\t   router.start(App, &apos;#app&apos;);</span><br><span class=\"line\">\t&#125;)(window);</span><br><span class=\"line\">/***/ &#125;),</span><br><span class=\"line\">/* 70 */</span><br><span class=\"line\">/***/ (function(module, exports, __webpack_require__) &#123;</span><br><span class=\"line\">\tvar getHeaders = __webpack_require__(71);</span><br><span class=\"line\">\tvar baseAjax = function(api, data, callback) &#123;</span><br><span class=\"line\">\t    var headers = getHeaders();</span><br><span class=\"line\">\t    // console.log(api, &apos;&apos;)</span><br><span class=\"line\">\t    // console.log(headers);</span><br><span class=\"line\">\t    $.ajax(&#123;</span><br><span class=\"line\">\t        url: api,</span><br><span class=\"line\">\t        type: &apos;POST&apos;,</span><br><span class=\"line\">\t        dataType: &apos;json&apos;,</span><br><span class=\"line\">\t        data: data,</span><br><span class=\"line\">\t        success: callback,</span><br><span class=\"line\">\t        headers: headers</span><br><span class=\"line\">\t    &#125;);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tmodule.exports = baseAjax;</span><br><span class=\"line\">/***/ &#125;),</span><br><span class=\"line\">/* 77 */</span><br><span class=\"line\">/***/ (function(module, exports, __webpack_require__) &#123;</span><br><span class=\"line\">\tvar baseAjax = __webpack_require__(70);</span><br><span class=\"line\">\tmodule.exports = &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">/***/ &#125;),</span><br><span class=\"line\">/******/ ]);</span><br></pre></td></tr></table></figure>\n<p>webpack.config.js文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var webpack = require(&apos;webpack&apos;);</span><br><span class=\"line\">var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);//将所有css文件导成一个</span><br><span class=\"line\">var extractLESS = new ExtractTextPlugin(&apos;./css/[name].less&apos;);</span><br><span class=\"line\">var extractCSS = new ExtractTextPlugin(&apos;./css/[name].css&apos;);</span><br><span class=\"line\">// var proxy = require(&apos;http-proxy-middleware&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">\tentry : __dirname + &apos;/src/app.js&apos;,</span><br><span class=\"line\">\toutput : &#123;</span><br><span class=\"line\">\t\tpath : __dirname + &apos;/lastpack&apos;,</span><br><span class=\"line\">\t\tfilename : &apos;[name].pack.js&apos;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tmodule : &#123;</span><br><span class=\"line\">\t\tloaders : [</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ttest : /\\.html$/,</span><br><span class=\"line\">\t\t\t\tloader : &apos;html&apos;</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ttest : /\\.(css|less)/,</span><br><span class=\"line\">\t\t\t\tloader : ExtractTextPlugin.extract(&apos;style&apos;, &apos;css!less&apos;),</span><br><span class=\"line\">\t\t\t\texclude: &apos;/lastpack/&apos;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\texternals : &#123;</span><br><span class=\"line\">\t\t&apos;vue&apos; : &apos;Vue&apos;,</span><br><span class=\"line\">\t\t&apos;vue-router&apos; : &apos;VueRouter&apos; //在项目中require的类库不会被合并到出口文件</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tplugins : [</span><br><span class=\"line\">\t\textractCSS,</span><br><span class=\"line\">\t\tnew webpack.optimize.UglifyJsPlugin(&#123;// webpack内置插件压缩JS/CSS</span><br><span class=\"line\">\t\t\tcompress : &#123;</span><br><span class=\"line\">\t\t\t\twarnings : false</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t],</span><br><span class=\"line\">\tdevServer: &#123;</span><br><span class=\"line\">\t\tproxy: &#123;</span><br><span class=\"line\">\t\t\t&apos;/api/*&apos;: &#123;</span><br><span class=\"line\">\t\t\t\ttarget: &apos;https://localhost&apos;,</span><br><span class=\"line\">\t\t\t\tchangeOrigin: true</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>精简一下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(modules)&#123;</span><br><span class=\"line\">&#125;)([]);</span><br></pre></td></tr></table></figure>\n<p>这块的自执行函数的入参是个数组，这个数组包含了所有模块，这些模块都包裹在函数中。自执行函数体里的逻辑就是处理模块的逻辑，关键就在<strong>webpack_require</strong>这个函数，这个函数就是require的替代。自执行函数的函数体里先定义了这个函数，然后调用了他并传入一个moduleId，这个例子中是0，也就是我们的入口模块__dirname + ‘/src/app.js’的内容。</p>\n<p><strong>webpack_require</strong>内部执行了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Execute the module function</span><br><span class=\"line\">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class=\"line\">// Flag the module as loaded</span><br><span class=\"line\">module.loaded = true;</span><br><span class=\"line\">// Return the exports of the module</span><br><span class=\"line\">return module.exports;</span><br></pre></td></tr></table></figure>\n<p>也就是从入参的modules数组中取第一个函数进行调用，并传入了module，module.exports以及<strong>webpack_require</strong>，再看第一个函数（入口函数）的逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(module, exports, __webpack_require__) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t(function(root) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    __webpack_require__(1);</span><br><span class=\"line\">\t    __webpack_require__(5);</span><br><span class=\"line\">\t    __webpack_require__(7);</span><br><span class=\"line\">\t    ···</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到入口模块又调用了<strong>webpack_require</strong>(1)去引入第二个函数。</p>\n<p>这里入参的exports就是这个模块的module.exports通过对象的引用传参，最后会将module.exports return出来。到这里就完成了<strong>webpack_require</strong>的使命。</p>\n<p>比如说在入口模块中又调用了<strong>webpack_require</strong>(1)，就会得到这个模块返回的module.exports。</p>\n","site":{"data":{}},"excerpt":"<p>先上总结吧，后面有代码分析：</p>\n<h5 id=\"总结：webpack的模块化原理是酱紫的——首先我们需要在webpack-config-js中取指定入口文件，完了分析webpack编译后的文件可以看到，整个文件由一个自执行函数包裹，入参是一个数组，这个数组包含了所有的模块，函数体的逻辑就是webpack的模块化逻辑。其中有一个函数叫webpack-require，参数为moduleId，然后在这个函数体的末尾调用了他传入参数为0并返回，这个0指代的模块就是我们的入口模块。也就是说，从入参的modules数组中取第一个函数进行调用，并传入了module，module-exports以及webpack-require这三个参数，然后你可以在入口函数的函数体内看到又调用了webpack-require-1-···等等来调用入口文件中所有后续需要的模块，这样就会引入后续的第二个第三个····函数，从第二个函数开始的入参exports，都是这个模块的module-exports通过对象的引用传参，这个模块中需要的其他模块也都是通过webpack-require来引的，最终会将module-exports-return出来。\"><a href=\"#总结：webpack的模块化原理是酱紫的——首先我们需要在webpack-config-js中取指定入口文件，完了分析webpack编译后的文件可以看到，整个文件由一个自执行函数包裹，入参是一个数组，这个数组包含了所有的模块，函数体的逻辑就是webpack的模块化逻辑。其中有一个函数叫webpack-require，参数为moduleId，然后在这个函数体的末尾调用了他传入参数为0并返回，这个0指代的模块就是我们的入口模块。也就是说，从入参的modules数组中取第一个函数进行调用，并传入了module，module-exports以及webpack-require这三个参数，然后你可以在入口函数的函数体内看到又调用了webpack-require-1-···等等来调用入口文件中所有后续需要的模块，这样就会引入后续的第二个第三个····函数，从第二个函数开始的入参exports，都是这个模块的module-exports通过对象的引用传参，这个模块中需要的其他模块也都是通过webpack-require来引的，最终会将module-exports-return出来。\" class=\"headerlink\" title=\"总结：webpack的模块化原理是酱紫的——首先我们需要在webpack.config.js中取指定入口文件，完了分析webpack编译后的文件可以看到，整个文件由一个自执行函数包裹，入参是一个数组，这个数组包含了所有的模块，函数体的逻辑就是webpack的模块化逻辑。其中有一个函数叫webpack_require，参数为moduleId，然后在这个函数体的末尾调用了他传入参数为0并返回，这个0指代的模块就是我们的入口模块。也就是说，从入参的modules数组中取第一个函数进行调用，并传入了module，module.exports以及webpack_require这三个参数，然后你可以在入口函数的函数体内看到又调用了webpack_require(1)···等等来调用入口文件中所有后续需要的模块，这样就会引入后续的第二个第三个····函数，从第二个函数开始的入参exports，都是这个模块的module.exports通过对象的引用传参，这个模块中需要的其他模块也都是通过webpack_require来引的，最终会将module.exports return出来。\"></a>总结：webpack的模块化原理是酱紫的——首先我们需要在webpack.config.js中取指定入口文件，完了分析webpack编译后的文件可以看到，整个文件由一个自执行函数包裹，入参是一个数组，这个数组包含了所有的模块，函数体的逻辑就是webpack的模块化逻辑。其中有一个函数叫<strong>webpack_require</strong>，参数为moduleId，然后在这个函数体的末尾调用了他传入参数为0并返回，这个0指代的模块就是我们的入口模块。也就是说，从入参的modules数组中取第一个函数进行调用，并传入了module，module.exports以及<strong>webpack_require</strong>这三个参数，然后你可以在入口函数的函数体内看到又调用了<strong>webpack_require</strong>(1)···等等来调用入口文件中所有后续需要的模块，这样就会引入后续的第二个第三个····函数，从第二个函数开始的入参exports，都是这个模块的module.exports通过对象的引用传参，这个模块中需要的其他模块也都是通过<strong>webpack_require</strong>来引的，最终会将module.exports return出来。</h5>","more":"<p>webpack(1.x)编译后的文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/******/ (function(modules) &#123; // webpackBootstrap</span><br><span class=\"line\">/******/ \t// The module cache</span><br><span class=\"line\">/******/ \tvar installedModules = &#123;&#125;;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t// The require function</span><br><span class=\"line\">/******/ \tfunction __webpack_require__(moduleId) &#123;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t\t// Check if module is in cache</span><br><span class=\"line\">/******/ \t\tif(installedModules[moduleId])</span><br><span class=\"line\">/******/ \t\t\treturn installedModules[moduleId].exports;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t\t// Create a new module (and put it into the cache)</span><br><span class=\"line\">/******/ \t\tvar module = installedModules[moduleId] = &#123;</span><br><span class=\"line\">/******/ \t\t\texports: &#123;&#125;,</span><br><span class=\"line\">/******/ \t\t\tid: moduleId,</span><br><span class=\"line\">/******/ \t\t\tloaded: false</span><br><span class=\"line\">/******/ \t\t&#125;;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t\t// Execute the module function</span><br><span class=\"line\">/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t\t// Flag the module as loaded</span><br><span class=\"line\">/******/ \t\tmodule.loaded = true;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t\t// Return the exports of the module</span><br><span class=\"line\">/******/ \t\treturn module.exports;</span><br><span class=\"line\">/******/ \t&#125;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t// expose the modules object (__webpack_modules__)</span><br><span class=\"line\">/******/ \t__webpack_require__.m = modules;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t// expose the module cache</span><br><span class=\"line\">/******/ \t__webpack_require__.c = installedModules;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t// __webpack_public_path__</span><br><span class=\"line\">/******/ \t__webpack_require__.p = &quot;&quot;;</span><br><span class=\"line\">/******/</span><br><span class=\"line\">/******/ \t// Load entry module and return exports</span><br><span class=\"line\">/******/ \treturn __webpack_require__(0);</span><br><span class=\"line\">/******/ &#125;)</span><br><span class=\"line\">/************************************************************************/</span><br><span class=\"line\">/******/ ([</span><br><span class=\"line\">/* 0 */</span><br><span class=\"line\">/***/ (function(module, exports, __webpack_require__) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t(function(root) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    __webpack_require__(1);</span><br><span class=\"line\">\t    __webpack_require__(5);</span><br><span class=\"line\">\t    __webpack_require__(7);</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    var homepage = __webpack_require__(67);</span><br><span class=\"line\">\t    var homepageWiki = __webpack_require__(73);</span><br><span class=\"line\">\t    var homepageSetting = __webpack_require__(75);</span><br><span class=\"line\">\t    Vue.use(VueRouter);</span><br><span class=\"line\">\t    var App = Vue.extend(&#123;&#125;);</span><br><span class=\"line\">\t    var router = new VueRouter();</span><br><span class=\"line\">\t    root.router = router;</span><br><span class=\"line\">\t    router.map(&#123;</span><br><span class=\"line\">\t        &apos;/&apos;: &#123;</span><br><span class=\"line\">\t            component: login</span><br><span class=\"line\">\t        &#125;,</span><br><span class=\"line\">\t        &apos;/login&apos;: &#123;</span><br><span class=\"line\">\t            name: &apos;login&apos;,</span><br><span class=\"line\">\t            component: login</span><br><span class=\"line\">\t        &#125;</span><br><span class=\"line\">\t   &#125;);</span><br><span class=\"line\">\t   router.start(App, &apos;#app&apos;);</span><br><span class=\"line\">\t&#125;)(window);</span><br><span class=\"line\">/***/ &#125;),</span><br><span class=\"line\">/* 70 */</span><br><span class=\"line\">/***/ (function(module, exports, __webpack_require__) &#123;</span><br><span class=\"line\">\tvar getHeaders = __webpack_require__(71);</span><br><span class=\"line\">\tvar baseAjax = function(api, data, callback) &#123;</span><br><span class=\"line\">\t    var headers = getHeaders();</span><br><span class=\"line\">\t    // console.log(api, &apos;&apos;)</span><br><span class=\"line\">\t    // console.log(headers);</span><br><span class=\"line\">\t    $.ajax(&#123;</span><br><span class=\"line\">\t        url: api,</span><br><span class=\"line\">\t        type: &apos;POST&apos;,</span><br><span class=\"line\">\t        dataType: &apos;json&apos;,</span><br><span class=\"line\">\t        data: data,</span><br><span class=\"line\">\t        success: callback,</span><br><span class=\"line\">\t        headers: headers</span><br><span class=\"line\">\t    &#125;);</span><br><span class=\"line\">\t&#125;;</span><br><span class=\"line\">\tmodule.exports = baseAjax;</span><br><span class=\"line\">/***/ &#125;),</span><br><span class=\"line\">/* 77 */</span><br><span class=\"line\">/***/ (function(module, exports, __webpack_require__) &#123;</span><br><span class=\"line\">\tvar baseAjax = __webpack_require__(70);</span><br><span class=\"line\">\tmodule.exports = &#123;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">/***/ &#125;),</span><br><span class=\"line\">/******/ ]);</span><br></pre></td></tr></table></figure>\n<p>webpack.config.js文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var webpack = require(&apos;webpack&apos;);</span><br><span class=\"line\">var ExtractTextPlugin = require(&apos;extract-text-webpack-plugin&apos;);//将所有css文件导成一个</span><br><span class=\"line\">var extractLESS = new ExtractTextPlugin(&apos;./css/[name].less&apos;);</span><br><span class=\"line\">var extractCSS = new ExtractTextPlugin(&apos;./css/[name].css&apos;);</span><br><span class=\"line\">// var proxy = require(&apos;http-proxy-middleware&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">\tentry : __dirname + &apos;/src/app.js&apos;,</span><br><span class=\"line\">\toutput : &#123;</span><br><span class=\"line\">\t\tpath : __dirname + &apos;/lastpack&apos;,</span><br><span class=\"line\">\t\tfilename : &apos;[name].pack.js&apos;</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tmodule : &#123;</span><br><span class=\"line\">\t\tloaders : [</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ttest : /\\.html$/,</span><br><span class=\"line\">\t\t\t\tloader : &apos;html&apos;</span><br><span class=\"line\">\t\t\t&#125;,</span><br><span class=\"line\">\t\t\t&#123;</span><br><span class=\"line\">\t\t\t\ttest : /\\.(css|less)/,</span><br><span class=\"line\">\t\t\t\tloader : ExtractTextPlugin.extract(&apos;style&apos;, &apos;css!less&apos;),</span><br><span class=\"line\">\t\t\t\texclude: &apos;/lastpack/&apos;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t]</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\texternals : &#123;</span><br><span class=\"line\">\t\t&apos;vue&apos; : &apos;Vue&apos;,</span><br><span class=\"line\">\t\t&apos;vue-router&apos; : &apos;VueRouter&apos; //在项目中require的类库不会被合并到出口文件</span><br><span class=\"line\">\t&#125;,</span><br><span class=\"line\">\tplugins : [</span><br><span class=\"line\">\t\textractCSS,</span><br><span class=\"line\">\t\tnew webpack.optimize.UglifyJsPlugin(&#123;// webpack内置插件压缩JS/CSS</span><br><span class=\"line\">\t\t\tcompress : &#123;</span><br><span class=\"line\">\t\t\t\twarnings : false</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;)</span><br><span class=\"line\">\t],</span><br><span class=\"line\">\tdevServer: &#123;</span><br><span class=\"line\">\t\tproxy: &#123;</span><br><span class=\"line\">\t\t\t&apos;/api/*&apos;: &#123;</span><br><span class=\"line\">\t\t\t\ttarget: &apos;https://localhost&apos;,</span><br><span class=\"line\">\t\t\t\tchangeOrigin: true</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>精简一下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function(modules)&#123;</span><br><span class=\"line\">&#125;)([]);</span><br></pre></td></tr></table></figure>\n<p>这块的自执行函数的入参是个数组，这个数组包含了所有模块，这些模块都包裹在函数中。自执行函数体里的逻辑就是处理模块的逻辑，关键就在<strong>webpack_require</strong>这个函数，这个函数就是require的替代。自执行函数的函数体里先定义了这个函数，然后调用了他并传入一个moduleId，这个例子中是0，也就是我们的入口模块__dirname + ‘/src/app.js’的内容。</p>\n<p><strong>webpack_require</strong>内部执行了</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Execute the module function</span><br><span class=\"line\">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><br><span class=\"line\">// Flag the module as loaded</span><br><span class=\"line\">module.loaded = true;</span><br><span class=\"line\">// Return the exports of the module</span><br><span class=\"line\">return module.exports;</span><br></pre></td></tr></table></figure>\n<p>也就是从入参的modules数组中取第一个函数进行调用，并传入了module，module.exports以及<strong>webpack_require</strong>，再看第一个函数（入口函数）的逻辑：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function(module, exports, __webpack_require__) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t(function(root) &#123;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t    __webpack_require__(1);</span><br><span class=\"line\">\t    __webpack_require__(5);</span><br><span class=\"line\">\t    __webpack_require__(7);</span><br><span class=\"line\">\t    ···</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到入口模块又调用了<strong>webpack_require</strong>(1)去引入第二个函数。</p>\n<p>这里入参的exports就是这个模块的module.exports通过对象的引用传参，最后会将module.exports return出来。到这里就完成了<strong>webpack_require</strong>的使命。</p>\n<p>比如说在入口模块中又调用了<strong>webpack_require</strong>(1)，就会得到这个模块返回的module.exports。</p>"},{"title":"深入作用域链","date":"2018-06-24T08:05:19.000Z","about":null,"_content":"\n#### 作用域链\n> 当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。\n\n接下来以一个函数的创建和激活两个时期来看作用域链式如何创建和变化的~\n\n#### 函数创建\n> 函数的作用域在函数定义的时候就决定了，因为函数有一个内部属性[[scope]]，当函数创建的时候，就会保存所有父变量到其中，可以理解为父变量对象的层级链，但是[[scope]]并不代表完整的作用域链。\n\n<!--more-->\n\n```\nfunction foo() {\n    function bar() {\n        ...\n    }\n}\n\n// 函数创建时，各自的[[scope]]为：\nfoo.[[scope]] = [\n    globalContext.VO\n];\n\nbar.[[scope]] = [\n    fooContext.AO,\n    globalContext.VO\n];\n```\n\n#### 函数激活\n> 函数激活时，进入函数上下文，创建VO/AO之后，就会将活动对象添加到作用域链的前端。这个时候执行上下文的作用域链，我们命名为Scope:\n\n```\nScope = [AO].concat([[scope]]);\n```\n\n结合上文讲的执行上下文和变量对象，总结一下函数执行上下文中作用域链和变量对象的创建过程：\n\n```\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope2 = 'local scope';\n    return scope2;\n}\ncheckscope();\n```\n执行过程如下：\n\n```\n// 1.checkscope 函数被创建，保存作用域链到内部属性[[scope]]\ncheckscope.[[scope]] = [\n    globalContext.VO\n];\n\n// 2.激活 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈\nECStack = [\n    checkscopeContext,\n    globalContext\n];\n\n// 3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链\ncheckscopeContext = {\n    Scope: checkscope.[[scope]],\n}\n\n// 4.第二步：用 arguments 创建变量对象，随后初始化活动对象，加入形参、函数声明、变量声明\ncheckscopeContext = {\n    VO: {\n        arguments: {\n            length: 0\n        },\n        scope2: undefined\n    }，\n    Scope: checkscope.[[scope]],\n}\n\n// 5.准备工作做完，开始执行函数，随着函数的执行，VO变成AO被压入 checkscope 作用域链顶端，这个时候修改 AO 的属性值（也就是函数引用和变量赋值）\ncheckscopeContext = {\n    AO: {\n        arguments: {\n            length: 0\n        },\n        scope2: 'local scope'\n    },\n    Scope: [AO, [[Scope]]]\n}\n\n// 7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出\nECStack = [\n    globalContext\n];\n```\n\n","source":"_posts/深入作用域链.md","raw":"---\ntitle: 深入作用域链\ndate: 2018-06-24 16:05:19\ntags:\n- 作用域链\n- 执行上下文\ncategories: ES5\nabout:\n---\n\n#### 作用域链\n> 当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。\n\n接下来以一个函数的创建和激活两个时期来看作用域链式如何创建和变化的~\n\n#### 函数创建\n> 函数的作用域在函数定义的时候就决定了，因为函数有一个内部属性[[scope]]，当函数创建的时候，就会保存所有父变量到其中，可以理解为父变量对象的层级链，但是[[scope]]并不代表完整的作用域链。\n\n<!--more-->\n\n```\nfunction foo() {\n    function bar() {\n        ...\n    }\n}\n\n// 函数创建时，各自的[[scope]]为：\nfoo.[[scope]] = [\n    globalContext.VO\n];\n\nbar.[[scope]] = [\n    fooContext.AO,\n    globalContext.VO\n];\n```\n\n#### 函数激活\n> 函数激活时，进入函数上下文，创建VO/AO之后，就会将活动对象添加到作用域链的前端。这个时候执行上下文的作用域链，我们命名为Scope:\n\n```\nScope = [AO].concat([[scope]]);\n```\n\n结合上文讲的执行上下文和变量对象，总结一下函数执行上下文中作用域链和变量对象的创建过程：\n\n```\nvar scope = \"global scope\";\nfunction checkscope(){\n    var scope2 = 'local scope';\n    return scope2;\n}\ncheckscope();\n```\n执行过程如下：\n\n```\n// 1.checkscope 函数被创建，保存作用域链到内部属性[[scope]]\ncheckscope.[[scope]] = [\n    globalContext.VO\n];\n\n// 2.激活 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈\nECStack = [\n    checkscopeContext,\n    globalContext\n];\n\n// 3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链\ncheckscopeContext = {\n    Scope: checkscope.[[scope]],\n}\n\n// 4.第二步：用 arguments 创建变量对象，随后初始化活动对象，加入形参、函数声明、变量声明\ncheckscopeContext = {\n    VO: {\n        arguments: {\n            length: 0\n        },\n        scope2: undefined\n    }，\n    Scope: checkscope.[[scope]],\n}\n\n// 5.准备工作做完，开始执行函数，随着函数的执行，VO变成AO被压入 checkscope 作用域链顶端，这个时候修改 AO 的属性值（也就是函数引用和变量赋值）\ncheckscopeContext = {\n    AO: {\n        arguments: {\n            length: 0\n        },\n        scope2: 'local scope'\n    },\n    Scope: [AO, [[Scope]]]\n}\n\n// 7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出\nECStack = [\n    globalContext\n];\n```\n\n","slug":"深入作用域链","published":1,"updated":"2019-02-22T08:37:33.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugrow000vvriehbra3c5z","content":"<h4 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h4><blockquote>\n<p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>\n</blockquote>\n<p>接下来以一个函数的创建和激活两个时期来看作用域链式如何创建和变化的~</p>\n<h4 id=\"函数创建\"><a href=\"#函数创建\" class=\"headerlink\" title=\"函数创建\"></a>函数创建</h4><blockquote>\n<p>函数的作用域在函数定义的时候就决定了，因为函数有一个内部属性[[scope]]，当函数创建的时候，就会保存所有父变量到其中，可以理解为父变量对象的层级链，但是[[scope]]并不代表完整的作用域链。</p>\n</blockquote>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    function bar() &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 函数创建时，各自的[[scope]]为：</span><br><span class=\"line\">foo.[[scope]] = [</span><br><span class=\"line\">    globalContext.VO</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">bar.[[scope]] = [</span><br><span class=\"line\">    fooContext.AO,</span><br><span class=\"line\">    globalContext.VO</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数激活\"><a href=\"#函数激活\" class=\"headerlink\" title=\"函数激活\"></a>函数激活</h4><blockquote>\n<p>函数激活时，进入函数上下文，创建VO/AO之后，就会将活动对象添加到作用域链的前端。这个时候执行上下文的作用域链，我们命名为Scope:</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scope = [AO].concat([[scope]]);</span><br></pre></td></tr></table></figure>\n<p>结合上文讲的执行上下文和变量对象，总结一下函数执行上下文中作用域链和变量对象的创建过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var scope = &quot;global scope&quot;;</span><br><span class=\"line\">function checkscope()&#123;</span><br><span class=\"line\">    var scope2 = &apos;local scope&apos;;</span><br><span class=\"line\">    return scope2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope();</span><br></pre></td></tr></table></figure>\n<p>执行过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.checkscope 函数被创建，保存作用域链到内部属性[[scope]]</span><br><span class=\"line\">checkscope.[[scope]] = [</span><br><span class=\"line\">    globalContext.VO</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">// 2.激活 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</span><br><span class=\"line\">ECStack = [</span><br><span class=\"line\">    checkscopeContext,</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">// 3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</span><br><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    Scope: checkscope.[[scope]],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 4.第二步：用 arguments 创建变量对象，随后初始化活动对象，加入形参、函数声明、变量声明</span><br><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    VO: &#123;</span><br><span class=\"line\">        arguments: &#123;</span><br><span class=\"line\">            length: 0</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        scope2: undefined</span><br><span class=\"line\">    &#125;，</span><br><span class=\"line\">    Scope: checkscope.[[scope]],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 5.准备工作做完，开始执行函数，随着函数的执行，VO变成AO被压入 checkscope 作用域链顶端，这个时候修改 AO 的属性值（也就是函数引用和变量赋值）</span><br><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    AO: &#123;</span><br><span class=\"line\">        arguments: &#123;</span><br><span class=\"line\">            length: 0</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        scope2: &apos;local scope&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Scope: [AO, [[Scope]]]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</span><br><span class=\"line\">ECStack = [</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h4 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h4><blockquote>\n<p>当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</p>\n</blockquote>\n<p>接下来以一个函数的创建和激活两个时期来看作用域链式如何创建和变化的~</p>\n<h4 id=\"函数创建\"><a href=\"#函数创建\" class=\"headerlink\" title=\"函数创建\"></a>函数创建</h4><blockquote>\n<p>函数的作用域在函数定义的时候就决定了，因为函数有一个内部属性[[scope]]，当函数创建的时候，就会保存所有父变量到其中，可以理解为父变量对象的层级链，但是[[scope]]并不代表完整的作用域链。</p>\n</blockquote>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    function bar() &#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 函数创建时，各自的[[scope]]为：</span><br><span class=\"line\">foo.[[scope]] = [</span><br><span class=\"line\">    globalContext.VO</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">bar.[[scope]] = [</span><br><span class=\"line\">    fooContext.AO,</span><br><span class=\"line\">    globalContext.VO</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>\n<h4 id=\"函数激活\"><a href=\"#函数激活\" class=\"headerlink\" title=\"函数激活\"></a>函数激活</h4><blockquote>\n<p>函数激活时，进入函数上下文，创建VO/AO之后，就会将活动对象添加到作用域链的前端。这个时候执行上下文的作用域链，我们命名为Scope:</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Scope = [AO].concat([[scope]]);</span><br></pre></td></tr></table></figure>\n<p>结合上文讲的执行上下文和变量对象，总结一下函数执行上下文中作用域链和变量对象的创建过程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var scope = &quot;global scope&quot;;</span><br><span class=\"line\">function checkscope()&#123;</span><br><span class=\"line\">    var scope2 = &apos;local scope&apos;;</span><br><span class=\"line\">    return scope2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">checkscope();</span><br></pre></td></tr></table></figure>\n<p>执行过程如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 1.checkscope 函数被创建，保存作用域链到内部属性[[scope]]</span><br><span class=\"line\">checkscope.[[scope]] = [</span><br><span class=\"line\">    globalContext.VO</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">// 2.激活 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈</span><br><span class=\"line\">ECStack = [</span><br><span class=\"line\">    checkscopeContext,</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br><span class=\"line\"></span><br><span class=\"line\">// 3.checkscope 函数并不立刻执行，开始做准备工作，第一步：复制函数[[scope]]属性创建作用域链</span><br><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    Scope: checkscope.[[scope]],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 4.第二步：用 arguments 创建变量对象，随后初始化活动对象，加入形参、函数声明、变量声明</span><br><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    VO: &#123;</span><br><span class=\"line\">        arguments: &#123;</span><br><span class=\"line\">            length: 0</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        scope2: undefined</span><br><span class=\"line\">    &#125;，</span><br><span class=\"line\">    Scope: checkscope.[[scope]],</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 5.准备工作做完，开始执行函数，随着函数的执行，VO变成AO被压入 checkscope 作用域链顶端，这个时候修改 AO 的属性值（也就是函数引用和变量赋值）</span><br><span class=\"line\">checkscopeContext = &#123;</span><br><span class=\"line\">    AO: &#123;</span><br><span class=\"line\">        arguments: &#123;</span><br><span class=\"line\">            length: 0</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        scope2: &apos;local scope&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    Scope: [AO, [[Scope]]]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 7.查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</span><br><span class=\"line\">ECStack = [</span><br><span class=\"line\">    globalContext</span><br><span class=\"line\">];</span><br></pre></td></tr></table></figure>"},{"title":"深入闭包","date":"2018-06-24T08:05:44.000Z","about":null,"_content":"\n#### 定义\n\n《JS忍者秘籍》中对闭包的定义为：\n\n> 闭包实际上是一个作用域，在创建时允许其自身的变量和函数访问其自身之外的变量时的作用域。\n\n所以，闭包是由两部分组成的:\n> 闭包 = 函数 + 函数能够访问的自有变量\n\n看个例子：\n<!--more-->\n\n```\nvar outerValue = 1; // 全局作用域声明一个变量\n\nfunction outerFunction() { // 在全局作用域中声明一个函数\n    console.log(outerValue); // 1\n}\n\nouterFunction(); // 执行该函数\n```\n该函数是能够访问到自身之外的变量outerValue的，这个时候我们其实已经创建了一个闭包！只不过，这只是理论上的闭包，还有一个实践上的闭包。\n\n1. 从理论上：所有的函数，因为它们在创建的时候就将上层上下文的数据保存起来了，哪怕是简单的全局变量也是如此，因为函数中访问自由变量就相当于是在访问自由变量，这个时候使用最外层的作用域。\n\n2. 从实际上，以下函数才算是闭包：\n\n    i. 即使创建它的上下文已经销毁，他仍然存在（比如，内部函数从父函数中返回）\n\n    ii. 在代码中引用了自有变量\n\n#### 必刷题\n```\nvar divs = document.getElementsByTagName(\"div\");\n\nfor(var i = 0; i < divs.length; i++) {\n    div[i].onclick = function() {\n        alert(i);\n    };\n}\n\ndata[0](); // 3\ndata[1](); // 3\ndata[2](); // 3\n```\n这么理解吧~\n\n在激活data[0]之前，全局上下文的VO为：\n```\nglobalContext = {\n    VO: {\n        data: [···],\n        i: 3\n    }\n}\n```\n\n当激活data[0]函数的时候，data[0]函数的作用域链（scopeChain）为：\n```\ndata[0]()Context = {\n    Scope: [AO, globalContext.VO]\n}\n```\n\n而data[0]Context的AO中并没有i值，所以会从globalContext.VO中查找，此时i为3，所以打印结果为3，data[1]和data[2]也是一样。\n\n改成闭包~\n\n```\nvar divs = document.getElementsByTagName(\"div\");\n\nfor(var i = 0; i < divs.length; i++) {\n    div[i].onclick = (function() {\n        return  function(j) {\n            alert(j);\n        };\n    })(i);\n}\n\ndata[0](); // 0\ndata[1](); // 1\ndata[2](); // 2\n```\n\n在激活data[0]之前，全局上下文的VO为：\n```\nglobalContext = {\n    VO: {\n        data: [···],\n        i: 3\n    }\n}\n```\n\n当激活data[0]函数的时候，data[0]函数的作用域链（scopeChain）为：\n```\ndata[0]()Context = {\n    Scope: [AO, 匿名函数Context.VO, globalContext.VO]\n}\n\n匿名函数Context = {\n    AO: {\n        arguments: {\n            0: 0,\n            lenth: 1\n        },\n        i: 0\n    }\n}\n```\ndata[0]Context的AO并没有i值，所以会沿着作用域链从匿名函数Context.VO中去找，而匿名函数中如果有就直接用，没有就沿着链继续找globalContext.VO，但是这个例子在匿名函数Context.VO中找到了，所以即使globalContext.VO也有i值（为3），也不会利用，所以data[0]函数的打印结果就是0。\n\ndata[1]和data[2]一样。\n\n!!!划重点\n1. 循环不会创建一个执行上下文，所以不会有VO/AO\n2. var声明的循环变量不会将变量与循环块绑定，可以使用let关键字将for循环的块隐式地声明为块作用域（原理：循环变量在循环过程中不止被声明一次，每次迭代都会声明。之后的每次迭代都会使用上一次循环迭代结束时的值来初始化这个变量）\n\n总之！一句话~闭包，其实是跟词法作用域紧密相关的一个概念，通过维护作用域链中涉及的变量的存活，从而导致能在执行上下文栈销毁后访问到变量的值，这也就是常说的内存常驻问题。后续再讲啦~","source":"_posts/深入闭包.md","raw":"---\ntitle: 深入闭包\ndate: 2018-06-24 16:05:44\ntags:\n- 闭包\ncategories: ES5\nabout:\n---\n\n#### 定义\n\n《JS忍者秘籍》中对闭包的定义为：\n\n> 闭包实际上是一个作用域，在创建时允许其自身的变量和函数访问其自身之外的变量时的作用域。\n\n所以，闭包是由两部分组成的:\n> 闭包 = 函数 + 函数能够访问的自有变量\n\n看个例子：\n<!--more-->\n\n```\nvar outerValue = 1; // 全局作用域声明一个变量\n\nfunction outerFunction() { // 在全局作用域中声明一个函数\n    console.log(outerValue); // 1\n}\n\nouterFunction(); // 执行该函数\n```\n该函数是能够访问到自身之外的变量outerValue的，这个时候我们其实已经创建了一个闭包！只不过，这只是理论上的闭包，还有一个实践上的闭包。\n\n1. 从理论上：所有的函数，因为它们在创建的时候就将上层上下文的数据保存起来了，哪怕是简单的全局变量也是如此，因为函数中访问自由变量就相当于是在访问自由变量，这个时候使用最外层的作用域。\n\n2. 从实际上，以下函数才算是闭包：\n\n    i. 即使创建它的上下文已经销毁，他仍然存在（比如，内部函数从父函数中返回）\n\n    ii. 在代码中引用了自有变量\n\n#### 必刷题\n```\nvar divs = document.getElementsByTagName(\"div\");\n\nfor(var i = 0; i < divs.length; i++) {\n    div[i].onclick = function() {\n        alert(i);\n    };\n}\n\ndata[0](); // 3\ndata[1](); // 3\ndata[2](); // 3\n```\n这么理解吧~\n\n在激活data[0]之前，全局上下文的VO为：\n```\nglobalContext = {\n    VO: {\n        data: [···],\n        i: 3\n    }\n}\n```\n\n当激活data[0]函数的时候，data[0]函数的作用域链（scopeChain）为：\n```\ndata[0]()Context = {\n    Scope: [AO, globalContext.VO]\n}\n```\n\n而data[0]Context的AO中并没有i值，所以会从globalContext.VO中查找，此时i为3，所以打印结果为3，data[1]和data[2]也是一样。\n\n改成闭包~\n\n```\nvar divs = document.getElementsByTagName(\"div\");\n\nfor(var i = 0; i < divs.length; i++) {\n    div[i].onclick = (function() {\n        return  function(j) {\n            alert(j);\n        };\n    })(i);\n}\n\ndata[0](); // 0\ndata[1](); // 1\ndata[2](); // 2\n```\n\n在激活data[0]之前，全局上下文的VO为：\n```\nglobalContext = {\n    VO: {\n        data: [···],\n        i: 3\n    }\n}\n```\n\n当激活data[0]函数的时候，data[0]函数的作用域链（scopeChain）为：\n```\ndata[0]()Context = {\n    Scope: [AO, 匿名函数Context.VO, globalContext.VO]\n}\n\n匿名函数Context = {\n    AO: {\n        arguments: {\n            0: 0,\n            lenth: 1\n        },\n        i: 0\n    }\n}\n```\ndata[0]Context的AO并没有i值，所以会沿着作用域链从匿名函数Context.VO中去找，而匿名函数中如果有就直接用，没有就沿着链继续找globalContext.VO，但是这个例子在匿名函数Context.VO中找到了，所以即使globalContext.VO也有i值（为3），也不会利用，所以data[0]函数的打印结果就是0。\n\ndata[1]和data[2]一样。\n\n!!!划重点\n1. 循环不会创建一个执行上下文，所以不会有VO/AO\n2. var声明的循环变量不会将变量与循环块绑定，可以使用let关键字将for循环的块隐式地声明为块作用域（原理：循环变量在循环过程中不止被声明一次，每次迭代都会声明。之后的每次迭代都会使用上一次循环迭代结束时的值来初始化这个变量）\n\n总之！一句话~闭包，其实是跟词法作用域紧密相关的一个概念，通过维护作用域链中涉及的变量的存活，从而导致能在执行上下文栈销毁后访问到变量的值，这也就是常说的内存常驻问题。后续再讲啦~","slug":"深入闭包","published":1,"updated":"2019-02-22T08:37:33.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugrox000xvrieicb1gk0p","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>《JS忍者秘籍》中对闭包的定义为：</p>\n<blockquote>\n<p>闭包实际上是一个作用域，在创建时允许其自身的变量和函数访问其自身之外的变量时的作用域。</p>\n</blockquote>\n<p>所以，闭包是由两部分组成的:</p>\n<blockquote>\n<p>闭包 = 函数 + 函数能够访问的自有变量</p>\n</blockquote>\n<p>看个例子：<br><a id=\"more\"></a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var outerValue = 1; // 全局作用域声明一个变量</span><br><span class=\"line\"></span><br><span class=\"line\">function outerFunction() &#123; // 在全局作用域中声明一个函数</span><br><span class=\"line\">    console.log(outerValue); // 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">outerFunction(); // 执行该函数</span><br></pre></td></tr></table></figure>\n<p>该函数是能够访问到自身之外的变量outerValue的，这个时候我们其实已经创建了一个闭包！只不过，这只是理论上的闭包，还有一个实践上的闭包。</p>\n<ol>\n<li><p>从理论上：所有的函数，因为它们在创建的时候就将上层上下文的数据保存起来了，哪怕是简单的全局变量也是如此，因为函数中访问自由变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</p>\n</li>\n<li><p>从实际上，以下函数才算是闭包：</p>\n<p> i. 即使创建它的上下文已经销毁，他仍然存在（比如，内部函数从父函数中返回）</p>\n<p> ii. 在代码中引用了自有变量</p>\n</li>\n</ol>\n<h4 id=\"必刷题\"><a href=\"#必刷题\" class=\"headerlink\" title=\"必刷题\"></a>必刷题</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var divs = document.getElementsByTagName(&quot;div&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">for(var i = 0; i &lt; divs.length; i++) &#123;</span><br><span class=\"line\">    div[i].onclick = function() &#123;</span><br><span class=\"line\">        alert(i);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data[0](); // 3</span><br><span class=\"line\">data[1](); // 3</span><br><span class=\"line\">data[2](); // 3</span><br></pre></td></tr></table></figure>\n<p>这么理解吧~</p>\n<p>在激活data[0]之前，全局上下文的VO为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globalContext = &#123;</span><br><span class=\"line\">    VO: &#123;</span><br><span class=\"line\">        data: [···],</span><br><span class=\"line\">        i: 3</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当激活data[0]函数的时候，data[0]函数的作用域链（scopeChain）为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data[0]()Context = &#123;</span><br><span class=\"line\">    Scope: [AO, globalContext.VO]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而data[0]Context的AO中并没有i值，所以会从globalContext.VO中查找，此时i为3，所以打印结果为3，data[1]和data[2]也是一样。</p>\n<p>改成闭包~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var divs = document.getElementsByTagName(&quot;div&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">for(var i = 0; i &lt; divs.length; i++) &#123;</span><br><span class=\"line\">    div[i].onclick = (function() &#123;</span><br><span class=\"line\">        return  function(j) &#123;</span><br><span class=\"line\">            alert(j);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data[0](); // 0</span><br><span class=\"line\">data[1](); // 1</span><br><span class=\"line\">data[2](); // 2</span><br></pre></td></tr></table></figure>\n<p>在激活data[0]之前，全局上下文的VO为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globalContext = &#123;</span><br><span class=\"line\">    VO: &#123;</span><br><span class=\"line\">        data: [···],</span><br><span class=\"line\">        i: 3</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当激活data[0]函数的时候，data[0]函数的作用域链（scopeChain）为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data[0]()Context = &#123;</span><br><span class=\"line\">    Scope: [AO, 匿名函数Context.VO, globalContext.VO]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">匿名函数Context = &#123;</span><br><span class=\"line\">    AO: &#123;</span><br><span class=\"line\">        arguments: &#123;</span><br><span class=\"line\">            0: 0,</span><br><span class=\"line\">            lenth: 1</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        i: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>data[0]Context的AO并没有i值，所以会沿着作用域链从匿名函数Context.VO中去找，而匿名函数中如果有就直接用，没有就沿着链继续找globalContext.VO，但是这个例子在匿名函数Context.VO中找到了，所以即使globalContext.VO也有i值（为3），也不会利用，所以data[0]函数的打印结果就是0。</p>\n<p>data[1]和data[2]一样。</p>\n<p>!!!划重点</p>\n<ol>\n<li>循环不会创建一个执行上下文，所以不会有VO/AO</li>\n<li>var声明的循环变量不会将变量与循环块绑定，可以使用let关键字将for循环的块隐式地声明为块作用域（原理：循环变量在循环过程中不止被声明一次，每次迭代都会声明。之后的每次迭代都会使用上一次循环迭代结束时的值来初始化这个变量）</li>\n</ol>\n<p>总之！一句话~闭包，其实是跟词法作用域紧密相关的一个概念，通过维护作用域链中涉及的变量的存活，从而导致能在执行上下文栈销毁后访问到变量的值，这也就是常说的内存常驻问题。后续再讲啦~</p>\n","site":{"data":{}},"excerpt":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>《JS忍者秘籍》中对闭包的定义为：</p>\n<blockquote>\n<p>闭包实际上是一个作用域，在创建时允许其自身的变量和函数访问其自身之外的变量时的作用域。</p>\n</blockquote>\n<p>所以，闭包是由两部分组成的:</p>\n<blockquote>\n<p>闭包 = 函数 + 函数能够访问的自有变量</p>\n</blockquote>\n<p>看个例子：<br>","more":"</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var outerValue = 1; // 全局作用域声明一个变量</span><br><span class=\"line\"></span><br><span class=\"line\">function outerFunction() &#123; // 在全局作用域中声明一个函数</span><br><span class=\"line\">    console.log(outerValue); // 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">outerFunction(); // 执行该函数</span><br></pre></td></tr></table></figure>\n<p>该函数是能够访问到自身之外的变量outerValue的，这个时候我们其实已经创建了一个闭包！只不过，这只是理论上的闭包，还有一个实践上的闭包。</p>\n<ol>\n<li><p>从理论上：所有的函数，因为它们在创建的时候就将上层上下文的数据保存起来了，哪怕是简单的全局变量也是如此，因为函数中访问自由变量就相当于是在访问自由变量，这个时候使用最外层的作用域。</p>\n</li>\n<li><p>从实际上，以下函数才算是闭包：</p>\n<p> i. 即使创建它的上下文已经销毁，他仍然存在（比如，内部函数从父函数中返回）</p>\n<p> ii. 在代码中引用了自有变量</p>\n</li>\n</ol>\n<h4 id=\"必刷题\"><a href=\"#必刷题\" class=\"headerlink\" title=\"必刷题\"></a>必刷题</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var divs = document.getElementsByTagName(&quot;div&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">for(var i = 0; i &lt; divs.length; i++) &#123;</span><br><span class=\"line\">    div[i].onclick = function() &#123;</span><br><span class=\"line\">        alert(i);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data[0](); // 3</span><br><span class=\"line\">data[1](); // 3</span><br><span class=\"line\">data[2](); // 3</span><br></pre></td></tr></table></figure>\n<p>这么理解吧~</p>\n<p>在激活data[0]之前，全局上下文的VO为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globalContext = &#123;</span><br><span class=\"line\">    VO: &#123;</span><br><span class=\"line\">        data: [···],</span><br><span class=\"line\">        i: 3</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当激活data[0]函数的时候，data[0]函数的作用域链（scopeChain）为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data[0]()Context = &#123;</span><br><span class=\"line\">    Scope: [AO, globalContext.VO]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>而data[0]Context的AO中并没有i值，所以会从globalContext.VO中查找，此时i为3，所以打印结果为3，data[1]和data[2]也是一样。</p>\n<p>改成闭包~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var divs = document.getElementsByTagName(&quot;div&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">for(var i = 0; i &lt; divs.length; i++) &#123;</span><br><span class=\"line\">    div[i].onclick = (function() &#123;</span><br><span class=\"line\">        return  function(j) &#123;</span><br><span class=\"line\">            alert(j);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;)(i);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">data[0](); // 0</span><br><span class=\"line\">data[1](); // 1</span><br><span class=\"line\">data[2](); // 2</span><br></pre></td></tr></table></figure>\n<p>在激活data[0]之前，全局上下文的VO为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">globalContext = &#123;</span><br><span class=\"line\">    VO: &#123;</span><br><span class=\"line\">        data: [···],</span><br><span class=\"line\">        i: 3</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>当激活data[0]函数的时候，data[0]函数的作用域链（scopeChain）为：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data[0]()Context = &#123;</span><br><span class=\"line\">    Scope: [AO, 匿名函数Context.VO, globalContext.VO]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">匿名函数Context = &#123;</span><br><span class=\"line\">    AO: &#123;</span><br><span class=\"line\">        arguments: &#123;</span><br><span class=\"line\">            0: 0,</span><br><span class=\"line\">            lenth: 1</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        i: 0</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>data[0]Context的AO并没有i值，所以会沿着作用域链从匿名函数Context.VO中去找，而匿名函数中如果有就直接用，没有就沿着链继续找globalContext.VO，但是这个例子在匿名函数Context.VO中找到了，所以即使globalContext.VO也有i值（为3），也不会利用，所以data[0]函数的打印结果就是0。</p>\n<p>data[1]和data[2]一样。</p>\n<p>!!!划重点</p>\n<ol>\n<li>循环不会创建一个执行上下文，所以不会有VO/AO</li>\n<li>var声明的循环变量不会将变量与循环块绑定，可以使用let关键字将for循环的块隐式地声明为块作用域（原理：循环变量在循环过程中不止被声明一次，每次迭代都会声明。之后的每次迭代都会使用上一次循环迭代结束时的值来初始化这个变量）</li>\n</ol>\n<p>总之！一句话~闭包，其实是跟词法作用域紧密相关的一个概念，通过维护作用域链中涉及的变量的存活，从而导致能在执行上下文栈销毁后访问到变量的值，这也就是常说的内存常驻问题。后续再讲啦~</p>"},{"title":"由一道算法带进ES6之SetMap","date":"2018-05-08T09:00:42.000Z","_content":"\n# Set:\n## 构造函数（可生成Set数据结构），类似数组，成员值唯一。\n\n## Set实例具有的属性：\n### 1.Set.prototype.constructor:默认Set\n### 2.Set.prototype.size:成员总数\n\n<!-- more -->\n\n## Set实例的操作和遍历方法：\n### 1.add(value)：添加，返回Set结构\n### 2.delete(value)：删除，返回布尔值，表示是否删除成功\n### 3.has(value)：返回布尔值，表示是否为Set成员\n### 4.clear()：清除所有成员，无返回值\n### 5.keys()：返回键名\n### 6.values()：返回键值\n### 7.entries()：返回键值对\n### 8.forEach()：使用回调函数遍历每个成员\n\n## 注意：\n#### 1.用于数组去重\n```\nnew Set(arr)\n```\n#### 2.向Set加入值时不会发生类型转换，比较时采用类似 === 的算法比较，区别在于Set中认为NaN等于自身（向Set中加入两个NaN时只能加入一个），=== 中认为NaN!==NaN\n#### 3.Set的遍历顺序是插入顺序，使用Set保存一个回调函数列表，调用时就能保证按照加入顺序调用\n#### 4.keys()和values()返回一致，因为Set只有键值（或者说键名和键值一样）\n#### 5.Set结构的实例默认可遍历，默认生成函数为values，可以直接用for···of···遍历\n```\nSet.prototype[Symbole.iterator] === Set.prototype.values\n```\n#### 6.扩展运算符内部使用for···of循环，也可以用来遍历。扩展运算符和Set结构一起可以用作数组去重\n\n##### eg1：\n```\nlet set = new Set(arr);\nlet result = [···set];\n```\n##### eg2：\n```\nlet arr = [1,4,2,2,4,5,3];\nlet result = [···new Set(arr)];\n```\n\n#### 7.使用Set实现并集、交集、差集\n```\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集 \nlet union = new Set([...a, ...b]); \n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x))); \n// Set {2, 3}\n\n// 差集\nlet difference = new Set([...a].filter(x => !b.has(x)));  \n// Set {1}\n\n```\n\n# Map:\n## JS对象，键值对集合（Hash结构）。\n\n## 注意：\n\n### 1.Map构造函数接受数组作为参数\n### 2.Set和Map都可以用来生成新的Map\n### 3.如果对同一个键多次赋值，后面的值将覆盖前面的值，如果读取一个未知的键值，返回undefined \n\n```\nconst map = new Map();\n\nmap\n.set(1, 'aaa')\n.set(1, 'bbb');\n\nmap.get(1) // \"bbb\"\n\nnew Map().get('asfddfsasadf')\n// undefined\n```\n\n#### 4.只有对同一个对象的引用，Map 结构才将其视为同一个键；同理，同样的值的两个实例，在Map结构中被视为两个键\n\n```\nconst map = new Map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n\n```\n\n```\nconst map = new Map();\n\nconst k1 = ['a'];\nconst k2 = ['a'];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222\n```\n*Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（crash）的问题*\n\n#### 5.如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键\n```\nlet map = new Map();\n\nmap.set(-0, 123);\nmap.get(+0) // 123\n\nmap.set(true, 1);\nmap.set('true', 2);\nmap.get(true) // 1\n\nmap.set(undefined, 3);\nmap.set(null, 4);\nmap.get(undefined) // 3\n\nmap.set(NaN, 123);\nmap.get(NaN) // 123\n\n```\n\n## Map实例的属性\n### 1.map.size：返回Map结构的成员总数\n### 2.map.set：设置键名key对应的键值为value，返回Map结构，如果key值已存在，则value会被更新，否则生成该key\n*set方法返回的是当前的Map对象，因此可以采用链式写法*\n\n## Map实例的操作和遍历方法\n### 1.map.get：读取key对应的键值，找不到返回undefined\n### 2.map.has：返回布尔值，表示某个键是否在当前Map对象之中\n### 3.map.delete：删除某个键，成功返回true，失败返回false\n### 4.map.clear：清除所有成员，无返回值\n### 5.keys：返回键名\n### 6.values：返回键值\n### 7.entries：返回所有成员\n### 8.forEach：遍历Map所有成员\n```\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// 等同于\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n```\n*Map结构的默认遍历器接口为entries方法，即：*\n```\nmap[Symbol.iterator] === map.entries\n```\n## 与其他数据结构的互相转换\n### 1.Map转数组：(···new Map)\n### 2.数组转MAp：new Map(arr)\n### 3.Map转对象：如果所有 Map 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\n```\nfunction strMapToObj(strMap) {\n  let obj = Object.create(null);\n  for (let [k,v] of strMap) {\n    obj[k] = v;\n  }\n  return obj;\n}\n\nconst myMap = new Map()\n  .set('yes', true)\n  .set('no', false);\nstrMapToObj(myMap)\n```\n### 4.对象转Map：\n```\nfunction objToStrMap(obj) {\n  let strMap = new Map();\n  for (let k of Object.keys(obj)) {\n    strMap.set(k, obj[k]);\n  }\n  return strMap;\n}\n\nobjToStrMap({yes: true, no: false})\n```\n### 5.Map转JSON：\n#### Map 的键名都是字符串，这时可以选择转为对象 JSON。\n```\nfunction strMapToJson(strMap) {\n  return JSON.stringify(strMapToObj(strMap));\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToJson(myMap)\n```\n#### Map 的键名有非字符串，这时可以选择转为数组 JSON。\n```\nfunction mapToArrayJson(map) {\n  return JSON.stringify([...map]);\n}\n\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\nmapToArrayJson(myMap)\n```\n### 6.JSON转Map：\n#### JSON 转为 Map，正常情况下，所有键名都是字符串。\n```\nfunction jsonToStrMap(jsonStr) {\n  return objToStrMap(JSON.parse(jsonStr));\n}\n\njsonToStrMap('{\"yes\": true, \"no\": false}')\n```\n#### 有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。\n```\nfunction jsonToMap(jsonStr) {\n  return new Map(JSON.parse(jsonStr));\n}\n\njsonToMap('[[true,7],[{\"foo\":3},[\"abc\"]]]')\n```\n\n```\n\"use strict\";\n/**\n * \n * 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。\n * 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。\n * 示例:\n * 给定 nums = [2, 7, 11, 15], target = 9\n * 因为 nums[0] + nums[1] = 2 + 7 = 9\n * 所以返回 [0, 1]\n * 给定 nums = [3, 4, 2], target = 6\n * 因为 nums[1] + nums[2] = 4 + 2 = 6\n * 所以返回 [1, 2]\n * 给定 nums = [3, 3], target = 6\n * 因为 nums[0] + nums[1] = 3 + 3 = 6\n * 所以返回 [0, 1]\n */\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n/**\n * 思路：在Map中存储key为target-nums[i]的差值，value为索引i\n * 遍历原始数组nums，如果Map中不存在nums[i]，set差值和i\n * 如果存在nums[i],说明Map中的键nums[i]对应的值和当次循环的i为所求\n */\nfunction twoSum (nums, target) {\n    const result = [];\n    const myMap = new Map();\n    if(nums == null || nums.length <= 1) {\n        return false;\n    }\n    for(let i = 0,len = nums.length; i < len; i++) {\n        if(myMap.has(nums[i])) {\n            result[0] = myMap.get(nums[i]);\n            result[1] = i;\n        } else {\n            myMap.set(target - nums[i], i);\n        }\n    }\n    console.log(result);\n    return result;\n}\ntwoSum([3,3],6);\n```","source":"_posts/由一道算法带进ES6之SetMap.md","raw":"---\ntitle: 由一道算法带进ES6之SetMap\ndate: 2018-05-08 17:00:42\ncategories: ES6 \ntags: \n- Set \n- Map\n---\n\n# Set:\n## 构造函数（可生成Set数据结构），类似数组，成员值唯一。\n\n## Set实例具有的属性：\n### 1.Set.prototype.constructor:默认Set\n### 2.Set.prototype.size:成员总数\n\n<!-- more -->\n\n## Set实例的操作和遍历方法：\n### 1.add(value)：添加，返回Set结构\n### 2.delete(value)：删除，返回布尔值，表示是否删除成功\n### 3.has(value)：返回布尔值，表示是否为Set成员\n### 4.clear()：清除所有成员，无返回值\n### 5.keys()：返回键名\n### 6.values()：返回键值\n### 7.entries()：返回键值对\n### 8.forEach()：使用回调函数遍历每个成员\n\n## 注意：\n#### 1.用于数组去重\n```\nnew Set(arr)\n```\n#### 2.向Set加入值时不会发生类型转换，比较时采用类似 === 的算法比较，区别在于Set中认为NaN等于自身（向Set中加入两个NaN时只能加入一个），=== 中认为NaN!==NaN\n#### 3.Set的遍历顺序是插入顺序，使用Set保存一个回调函数列表，调用时就能保证按照加入顺序调用\n#### 4.keys()和values()返回一致，因为Set只有键值（或者说键名和键值一样）\n#### 5.Set结构的实例默认可遍历，默认生成函数为values，可以直接用for···of···遍历\n```\nSet.prototype[Symbole.iterator] === Set.prototype.values\n```\n#### 6.扩展运算符内部使用for···of循环，也可以用来遍历。扩展运算符和Set结构一起可以用作数组去重\n\n##### eg1：\n```\nlet set = new Set(arr);\nlet result = [···set];\n```\n##### eg2：\n```\nlet arr = [1,4,2,2,4,5,3];\nlet result = [···new Set(arr)];\n```\n\n#### 7.使用Set实现并集、交集、差集\n```\nlet a = new Set([1, 2, 3]);\nlet b = new Set([4, 3, 2]);\n\n// 并集 \nlet union = new Set([...a, ...b]); \n// Set {1, 2, 3, 4}\n\n// 交集\nlet intersect = new Set([...a].filter(x => b.has(x))); \n// Set {2, 3}\n\n// 差集\nlet difference = new Set([...a].filter(x => !b.has(x)));  \n// Set {1}\n\n```\n\n# Map:\n## JS对象，键值对集合（Hash结构）。\n\n## 注意：\n\n### 1.Map构造函数接受数组作为参数\n### 2.Set和Map都可以用来生成新的Map\n### 3.如果对同一个键多次赋值，后面的值将覆盖前面的值，如果读取一个未知的键值，返回undefined \n\n```\nconst map = new Map();\n\nmap\n.set(1, 'aaa')\n.set(1, 'bbb');\n\nmap.get(1) // \"bbb\"\n\nnew Map().get('asfddfsasadf')\n// undefined\n```\n\n#### 4.只有对同一个对象的引用，Map 结构才将其视为同一个键；同理，同样的值的两个实例，在Map结构中被视为两个键\n\n```\nconst map = new Map();\n\nmap.set(['a'], 555);\nmap.get(['a']) // undefined\n\n```\n\n```\nconst map = new Map();\n\nconst k1 = ['a'];\nconst k2 = ['a'];\n\nmap\n.set(k1, 111)\n.set(k2, 222);\n\nmap.get(k1) // 111\nmap.get(k2) // 222\n```\n*Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（crash）的问题*\n\n#### 5.如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键\n```\nlet map = new Map();\n\nmap.set(-0, 123);\nmap.get(+0) // 123\n\nmap.set(true, 1);\nmap.set('true', 2);\nmap.get(true) // 1\n\nmap.set(undefined, 3);\nmap.set(null, 4);\nmap.get(undefined) // 3\n\nmap.set(NaN, 123);\nmap.get(NaN) // 123\n\n```\n\n## Map实例的属性\n### 1.map.size：返回Map结构的成员总数\n### 2.map.set：设置键名key对应的键值为value，返回Map结构，如果key值已存在，则value会被更新，否则生成该key\n*set方法返回的是当前的Map对象，因此可以采用链式写法*\n\n## Map实例的操作和遍历方法\n### 1.map.get：读取key对应的键值，找不到返回undefined\n### 2.map.has：返回布尔值，表示某个键是否在当前Map对象之中\n### 3.map.delete：删除某个键，成功返回true，失败返回false\n### 4.map.clear：清除所有成员，无返回值\n### 5.keys：返回键名\n### 6.values：返回键值\n### 7.entries：返回所有成员\n### 8.forEach：遍历Map所有成员\n```\nfor (let [key, value] of map.entries()) {\n  console.log(key, value);\n}\n// 等同于\nfor (let [key, value] of map) {\n  console.log(key, value);\n}\n```\n*Map结构的默认遍历器接口为entries方法，即：*\n```\nmap[Symbol.iterator] === map.entries\n```\n## 与其他数据结构的互相转换\n### 1.Map转数组：(···new Map)\n### 2.数组转MAp：new Map(arr)\n### 3.Map转对象：如果所有 Map 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\n```\nfunction strMapToObj(strMap) {\n  let obj = Object.create(null);\n  for (let [k,v] of strMap) {\n    obj[k] = v;\n  }\n  return obj;\n}\n\nconst myMap = new Map()\n  .set('yes', true)\n  .set('no', false);\nstrMapToObj(myMap)\n```\n### 4.对象转Map：\n```\nfunction objToStrMap(obj) {\n  let strMap = new Map();\n  for (let k of Object.keys(obj)) {\n    strMap.set(k, obj[k]);\n  }\n  return strMap;\n}\n\nobjToStrMap({yes: true, no: false})\n```\n### 5.Map转JSON：\n#### Map 的键名都是字符串，这时可以选择转为对象 JSON。\n```\nfunction strMapToJson(strMap) {\n  return JSON.stringify(strMapToObj(strMap));\n}\n\nlet myMap = new Map().set('yes', true).set('no', false);\nstrMapToJson(myMap)\n```\n#### Map 的键名有非字符串，这时可以选择转为数组 JSON。\n```\nfunction mapToArrayJson(map) {\n  return JSON.stringify([...map]);\n}\n\nlet myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);\nmapToArrayJson(myMap)\n```\n### 6.JSON转Map：\n#### JSON 转为 Map，正常情况下，所有键名都是字符串。\n```\nfunction jsonToStrMap(jsonStr) {\n  return objToStrMap(JSON.parse(jsonStr));\n}\n\njsonToStrMap('{\"yes\": true, \"no\": false}')\n```\n#### 有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。\n```\nfunction jsonToMap(jsonStr) {\n  return new Map(JSON.parse(jsonStr));\n}\n\njsonToMap('[[true,7],[{\"foo\":3},[\"abc\"]]]')\n```\n\n```\n\"use strict\";\n/**\n * \n * 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。\n * 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。\n * 示例:\n * 给定 nums = [2, 7, 11, 15], target = 9\n * 因为 nums[0] + nums[1] = 2 + 7 = 9\n * 所以返回 [0, 1]\n * 给定 nums = [3, 4, 2], target = 6\n * 因为 nums[1] + nums[2] = 4 + 2 = 6\n * 所以返回 [1, 2]\n * 给定 nums = [3, 3], target = 6\n * 因为 nums[0] + nums[1] = 3 + 3 = 6\n * 所以返回 [0, 1]\n */\n/**\n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\n/**\n * 思路：在Map中存储key为target-nums[i]的差值，value为索引i\n * 遍历原始数组nums，如果Map中不存在nums[i]，set差值和i\n * 如果存在nums[i],说明Map中的键nums[i]对应的值和当次循环的i为所求\n */\nfunction twoSum (nums, target) {\n    const result = [];\n    const myMap = new Map();\n    if(nums == null || nums.length <= 1) {\n        return false;\n    }\n    for(let i = 0,len = nums.length; i < len; i++) {\n        if(myMap.has(nums[i])) {\n            result[0] = myMap.get(nums[i]);\n            result[1] = i;\n        } else {\n            myMap.set(target - nums[i], i);\n        }\n    }\n    console.log(result);\n    return result;\n}\ntwoSum([3,3],6);\n```","slug":"由一道算法带进ES6之SetMap","published":1,"updated":"2019-02-22T08:37:33.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugroy0011vrieccw47owi","content":"<h1 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set:\"></a>Set:</h1><h2 id=\"构造函数（可生成Set数据结构），类似数组，成员值唯一。\"><a href=\"#构造函数（可生成Set数据结构），类似数组，成员值唯一。\" class=\"headerlink\" title=\"构造函数（可生成Set数据结构），类似数组，成员值唯一。\"></a>构造函数（可生成Set数据结构），类似数组，成员值唯一。</h2><h2 id=\"Set实例具有的属性：\"><a href=\"#Set实例具有的属性：\" class=\"headerlink\" title=\"Set实例具有的属性：\"></a>Set实例具有的属性：</h2><h3 id=\"1-Set-prototype-constructor-默认Set\"><a href=\"#1-Set-prototype-constructor-默认Set\" class=\"headerlink\" title=\"1.Set.prototype.constructor:默认Set\"></a>1.Set.prototype.constructor:默认Set</h3><h3 id=\"2-Set-prototype-size-成员总数\"><a href=\"#2-Set-prototype-size-成员总数\" class=\"headerlink\" title=\"2.Set.prototype.size:成员总数\"></a>2.Set.prototype.size:成员总数</h3><a id=\"more\"></a>\n<h2 id=\"Set实例的操作和遍历方法：\"><a href=\"#Set实例的操作和遍历方法：\" class=\"headerlink\" title=\"Set实例的操作和遍历方法：\"></a>Set实例的操作和遍历方法：</h2><h3 id=\"1-add-value-：添加，返回Set结构\"><a href=\"#1-add-value-：添加，返回Set结构\" class=\"headerlink\" title=\"1.add(value)：添加，返回Set结构\"></a>1.add(value)：添加，返回Set结构</h3><h3 id=\"2-delete-value-：删除，返回布尔值，表示是否删除成功\"><a href=\"#2-delete-value-：删除，返回布尔值，表示是否删除成功\" class=\"headerlink\" title=\"2.delete(value)：删除，返回布尔值，表示是否删除成功\"></a>2.delete(value)：删除，返回布尔值，表示是否删除成功</h3><h3 id=\"3-has-value-：返回布尔值，表示是否为Set成员\"><a href=\"#3-has-value-：返回布尔值，表示是否为Set成员\" class=\"headerlink\" title=\"3.has(value)：返回布尔值，表示是否为Set成员\"></a>3.has(value)：返回布尔值，表示是否为Set成员</h3><h3 id=\"4-clear-：清除所有成员，无返回值\"><a href=\"#4-clear-：清除所有成员，无返回值\" class=\"headerlink\" title=\"4.clear()：清除所有成员，无返回值\"></a>4.clear()：清除所有成员，无返回值</h3><h3 id=\"5-keys-：返回键名\"><a href=\"#5-keys-：返回键名\" class=\"headerlink\" title=\"5.keys()：返回键名\"></a>5.keys()：返回键名</h3><h3 id=\"6-values-：返回键值\"><a href=\"#6-values-：返回键值\" class=\"headerlink\" title=\"6.values()：返回键值\"></a>6.values()：返回键值</h3><h3 id=\"7-entries-：返回键值对\"><a href=\"#7-entries-：返回键值对\" class=\"headerlink\" title=\"7.entries()：返回键值对\"></a>7.entries()：返回键值对</h3><h3 id=\"8-forEach-：使用回调函数遍历每个成员\"><a href=\"#8-forEach-：使用回调函数遍历每个成员\" class=\"headerlink\" title=\"8.forEach()：使用回调函数遍历每个成员\"></a>8.forEach()：使用回调函数遍历每个成员</h3><h2 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h2><h4 id=\"1-用于数组去重\"><a href=\"#1-用于数组去重\" class=\"headerlink\" title=\"1.用于数组去重\"></a>1.用于数组去重</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Set(arr)</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-向Set加入值时不会发生类型转换，比较时采用类似-的算法比较，区别在于Set中认为NaN等于自身（向Set中加入两个NaN时只能加入一个），-中认为NaN-NaN\"><a href=\"#2-向Set加入值时不会发生类型转换，比较时采用类似-的算法比较，区别在于Set中认为NaN等于自身（向Set中加入两个NaN时只能加入一个），-中认为NaN-NaN\" class=\"headerlink\" title=\"2.向Set加入值时不会发生类型转换，比较时采用类似 === 的算法比较，区别在于Set中认为NaN等于自身（向Set中加入两个NaN时只能加入一个），=== 中认为NaN!==NaN\"></a>2.向Set加入值时不会发生类型转换，比较时采用类似 === 的算法比较，区别在于Set中认为NaN等于自身（向Set中加入两个NaN时只能加入一个），=== 中认为NaN!==NaN</h4><h4 id=\"3-Set的遍历顺序是插入顺序，使用Set保存一个回调函数列表，调用时就能保证按照加入顺序调用\"><a href=\"#3-Set的遍历顺序是插入顺序，使用Set保存一个回调函数列表，调用时就能保证按照加入顺序调用\" class=\"headerlink\" title=\"3.Set的遍历顺序是插入顺序，使用Set保存一个回调函数列表，调用时就能保证按照加入顺序调用\"></a>3.Set的遍历顺序是插入顺序，使用Set保存一个回调函数列表，调用时就能保证按照加入顺序调用</h4><h4 id=\"4-keys-和values-返回一致，因为Set只有键值（或者说键名和键值一样）\"><a href=\"#4-keys-和values-返回一致，因为Set只有键值（或者说键名和键值一样）\" class=\"headerlink\" title=\"4.keys()和values()返回一致，因为Set只有键值（或者说键名和键值一样）\"></a>4.keys()和values()返回一致，因为Set只有键值（或者说键名和键值一样）</h4><h4 id=\"5-Set结构的实例默认可遍历，默认生成函数为values，可以直接用for···of···遍历\"><a href=\"#5-Set结构的实例默认可遍历，默认生成函数为values，可以直接用for···of···遍历\" class=\"headerlink\" title=\"5.Set结构的实例默认可遍历，默认生成函数为values，可以直接用for···of···遍历\"></a>5.Set结构的实例默认可遍历，默认生成函数为values，可以直接用for···of···遍历</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set.prototype[Symbole.iterator] === Set.prototype.values</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-扩展运算符内部使用for···of循环，也可以用来遍历。扩展运算符和Set结构一起可以用作数组去重\"><a href=\"#6-扩展运算符内部使用for···of循环，也可以用来遍历。扩展运算符和Set结构一起可以用作数组去重\" class=\"headerlink\" title=\"6.扩展运算符内部使用for···of循环，也可以用来遍历。扩展运算符和Set结构一起可以用作数组去重\"></a>6.扩展运算符内部使用for···of循环，也可以用来遍历。扩展运算符和Set结构一起可以用作数组去重</h4><h5 id=\"eg1：\"><a href=\"#eg1：\" class=\"headerlink\" title=\"eg1：\"></a>eg1：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set = new Set(arr);</span><br><span class=\"line\">let result = [···set];</span><br></pre></td></tr></table></figure>\n<h5 id=\"eg2：\"><a href=\"#eg2：\" class=\"headerlink\" title=\"eg2：\"></a>eg2：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,4,2,2,4,5,3];</span><br><span class=\"line\">let result = [···new Set(arr)];</span><br></pre></td></tr></table></figure>\n<h4 id=\"7-使用Set实现并集、交集、差集\"><a href=\"#7-使用Set实现并集、交集、差集\" class=\"headerlink\" title=\"7.使用Set实现并集、交集、差集\"></a>7.使用Set实现并集、交集、差集</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = new Set([1, 2, 3]);</span><br><span class=\"line\">let b = new Set([4, 3, 2]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 并集 </span><br><span class=\"line\">let union = new Set([...a, ...b]); </span><br><span class=\"line\">// Set &#123;1, 2, 3, 4&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 交集</span><br><span class=\"line\">let intersect = new Set([...a].filter(x =&gt; b.has(x))); </span><br><span class=\"line\">// Set &#123;2, 3&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 差集</span><br><span class=\"line\">let difference = new Set([...a].filter(x =&gt; !b.has(x)));  </span><br><span class=\"line\">// Set &#123;1&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map:\"></a>Map:</h1><h2 id=\"JS对象，键值对集合（Hash结构）。\"><a href=\"#JS对象，键值对集合（Hash结构）。\" class=\"headerlink\" title=\"JS对象，键值对集合（Hash结构）。\"></a>JS对象，键值对集合（Hash结构）。</h2><h2 id=\"注意：-1\"><a href=\"#注意：-1\" class=\"headerlink\" title=\"注意：\"></a>注意：</h2><h3 id=\"1-Map构造函数接受数组作为参数\"><a href=\"#1-Map构造函数接受数组作为参数\" class=\"headerlink\" title=\"1.Map构造函数接受数组作为参数\"></a>1.Map构造函数接受数组作为参数</h3><h3 id=\"2-Set和Map都可以用来生成新的Map\"><a href=\"#2-Set和Map都可以用来生成新的Map\" class=\"headerlink\" title=\"2.Set和Map都可以用来生成新的Map\"></a>2.Set和Map都可以用来生成新的Map</h3><h3 id=\"3-如果对同一个键多次赋值，后面的值将覆盖前面的值，如果读取一个未知的键值，返回undefined\"><a href=\"#3-如果对同一个键多次赋值，后面的值将覆盖前面的值，如果读取一个未知的键值，返回undefined\" class=\"headerlink\" title=\"3.如果对同一个键多次赋值，后面的值将覆盖前面的值，如果读取一个未知的键值，返回undefined\"></a>3.如果对同一个键多次赋值，后面的值将覆盖前面的值，如果读取一个未知的键值，返回undefined</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map</span><br><span class=\"line\">.set(1, &apos;aaa&apos;)</span><br><span class=\"line\">.set(1, &apos;bbb&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(1) // &quot;bbb&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">new Map().get(&apos;asfddfsasadf&apos;)</span><br><span class=\"line\">// undefined</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-只有对同一个对象的引用，Map-结构才将其视为同一个键；同理，同样的值的两个实例，在Map结构中被视为两个键\"><a href=\"#4-只有对同一个对象的引用，Map-结构才将其视为同一个键；同理，同样的值的两个实例，在Map结构中被视为两个键\" class=\"headerlink\" title=\"4.只有对同一个对象的引用，Map 结构才将其视为同一个键；同理，同样的值的两个实例，在Map结构中被视为两个键\"></a>4.只有对同一个对象的引用，Map 结构才将其视为同一个键；同理，同样的值的两个实例，在Map结构中被视为两个键</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set([&apos;a&apos;], 555);</span><br><span class=\"line\">map.get([&apos;a&apos;]) // undefined</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">const k1 = [&apos;a&apos;];</span><br><span class=\"line\">const k2 = [&apos;a&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">map</span><br><span class=\"line\">.set(k1, 111)</span><br><span class=\"line\">.set(k2, 222);</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(k1) // 111</span><br><span class=\"line\">map.get(k2) // 222</span><br></pre></td></tr></table></figure>\n<p><em>Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（crash）的问题</em></p>\n<h4 id=\"5-如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键\"><a href=\"#5-如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键\" class=\"headerlink\" title=\"5.如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键\"></a>5.如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(-0, 123);</span><br><span class=\"line\">map.get(+0) // 123</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(true, 1);</span><br><span class=\"line\">map.set(&apos;true&apos;, 2);</span><br><span class=\"line\">map.get(true) // 1</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(undefined, 3);</span><br><span class=\"line\">map.set(null, 4);</span><br><span class=\"line\">map.get(undefined) // 3</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(NaN, 123);</span><br><span class=\"line\">map.get(NaN) // 123</span><br></pre></td></tr></table></figure>\n<h2 id=\"Map实例的属性\"><a href=\"#Map实例的属性\" class=\"headerlink\" title=\"Map实例的属性\"></a>Map实例的属性</h2><h3 id=\"1-map-size：返回Map结构的成员总数\"><a href=\"#1-map-size：返回Map结构的成员总数\" class=\"headerlink\" title=\"1.map.size：返回Map结构的成员总数\"></a>1.map.size：返回Map结构的成员总数</h3><h3 id=\"2-map-set：设置键名key对应的键值为value，返回Map结构，如果key值已存在，则value会被更新，否则生成该key\"><a href=\"#2-map-set：设置键名key对应的键值为value，返回Map结构，如果key值已存在，则value会被更新，否则生成该key\" class=\"headerlink\" title=\"2.map.set：设置键名key对应的键值为value，返回Map结构，如果key值已存在，则value会被更新，否则生成该key\"></a>2.map.set：设置键名key对应的键值为value，返回Map结构，如果key值已存在，则value会被更新，否则生成该key</h3><p><em>set方法返回的是当前的Map对象，因此可以采用链式写法</em></p>\n<h2 id=\"Map实例的操作和遍历方法\"><a href=\"#Map实例的操作和遍历方法\" class=\"headerlink\" title=\"Map实例的操作和遍历方法\"></a>Map实例的操作和遍历方法</h2><h3 id=\"1-map-get：读取key对应的键值，找不到返回undefined\"><a href=\"#1-map-get：读取key对应的键值，找不到返回undefined\" class=\"headerlink\" title=\"1.map.get：读取key对应的键值，找不到返回undefined\"></a>1.map.get：读取key对应的键值，找不到返回undefined</h3><h3 id=\"2-map-has：返回布尔值，表示某个键是否在当前Map对象之中\"><a href=\"#2-map-has：返回布尔值，表示某个键是否在当前Map对象之中\" class=\"headerlink\" title=\"2.map.has：返回布尔值，表示某个键是否在当前Map对象之中\"></a>2.map.has：返回布尔值，表示某个键是否在当前Map对象之中</h3><h3 id=\"3-map-delete：删除某个键，成功返回true，失败返回false\"><a href=\"#3-map-delete：删除某个键，成功返回true，失败返回false\" class=\"headerlink\" title=\"3.map.delete：删除某个键，成功返回true，失败返回false\"></a>3.map.delete：删除某个键，成功返回true，失败返回false</h3><h3 id=\"4-map-clear：清除所有成员，无返回值\"><a href=\"#4-map-clear：清除所有成员，无返回值\" class=\"headerlink\" title=\"4.map.clear：清除所有成员，无返回值\"></a>4.map.clear：清除所有成员，无返回值</h3><h3 id=\"5-keys：返回键名\"><a href=\"#5-keys：返回键名\" class=\"headerlink\" title=\"5.keys：返回键名\"></a>5.keys：返回键名</h3><h3 id=\"6-values：返回键值\"><a href=\"#6-values：返回键值\" class=\"headerlink\" title=\"6.values：返回键值\"></a>6.values：返回键值</h3><h3 id=\"7-entries：返回所有成员\"><a href=\"#7-entries：返回所有成员\" class=\"headerlink\" title=\"7.entries：返回所有成员\"></a>7.entries：返回所有成员</h3><h3 id=\"8-forEach：遍历Map所有成员\"><a href=\"#8-forEach：遍历Map所有成员\" class=\"headerlink\" title=\"8.forEach：遍历Map所有成员\"></a>8.forEach：遍历Map所有成员</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (let [key, value] of map.entries()) &#123;</span><br><span class=\"line\">  console.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">for (let [key, value] of map) &#123;</span><br><span class=\"line\">  console.log(key, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>Map结构的默认遍历器接口为entries方法，即：</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map[Symbol.iterator] === map.entries</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"与其他数据结构的互相转换\"><a href=\"#与其他数据结构的互相转换\" class=\"headerlink\" title=\"与其他数据结构的互相转换\"></a>与其他数据结构的互相转换</h2><h3 id=\"1-Map转数组：-···new-Map\"><a href=\"#1-Map转数组：-···new-Map\" class=\"headerlink\" title=\"1.Map转数组：(···new Map)\"></a>1.Map转数组：(···new Map)</h3><h3 id=\"2-数组转MAp：new-Map-arr\"><a href=\"#2-数组转MAp：new-Map-arr\" class=\"headerlink\" title=\"2.数组转MAp：new Map(arr)\"></a>2.数组转MAp：new Map(arr)</h3><h3 id=\"3-Map转对象：如果所有-Map-的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\"><a href=\"#3-Map转对象：如果所有-Map-的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\" class=\"headerlink\" title=\"3.Map转对象：如果所有 Map 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\"></a>3.Map转对象：如果所有 Map 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function strMapToObj(strMap) &#123;</span><br><span class=\"line\">  let obj = Object.create(null);</span><br><span class=\"line\">  for (let [k,v] of strMap) &#123;</span><br><span class=\"line\">    obj[k] = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const myMap = new Map()</span><br><span class=\"line\">  .set(&apos;yes&apos;, true)</span><br><span class=\"line\">  .set(&apos;no&apos;, false);</span><br><span class=\"line\">strMapToObj(myMap)</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-对象转Map：\"><a href=\"#4-对象转Map：\" class=\"headerlink\" title=\"4.对象转Map：\"></a>4.对象转Map：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function objToStrMap(obj) &#123;</span><br><span class=\"line\">  let strMap = new Map();</span><br><span class=\"line\">  for (let k of Object.keys(obj)) &#123;</span><br><span class=\"line\">    strMap.set(k, obj[k]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return strMap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">objToStrMap(&#123;yes: true, no: false&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-Map转JSON：\"><a href=\"#5-Map转JSON：\" class=\"headerlink\" title=\"5.Map转JSON：\"></a>5.Map转JSON：</h3><h4 id=\"Map-的键名都是字符串，这时可以选择转为对象-JSON。\"><a href=\"#Map-的键名都是字符串，这时可以选择转为对象-JSON。\" class=\"headerlink\" title=\"Map 的键名都是字符串，这时可以选择转为对象 JSON。\"></a>Map 的键名都是字符串，这时可以选择转为对象 JSON。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function strMapToJson(strMap) &#123;</span><br><span class=\"line\">  return JSON.stringify(strMapToObj(strMap));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</span><br><span class=\"line\">strMapToJson(myMap)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Map-的键名有非字符串，这时可以选择转为数组-JSON。\"><a href=\"#Map-的键名有非字符串，这时可以选择转为数组-JSON。\" class=\"headerlink\" title=\"Map 的键名有非字符串，这时可以选择转为数组 JSON。\"></a>Map 的键名有非字符串，这时可以选择转为数组 JSON。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function mapToArrayJson(map) &#123;</span><br><span class=\"line\">  return JSON.stringify([...map]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class=\"line\">mapToArrayJson(myMap)</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-JSON转Map：\"><a href=\"#6-JSON转Map：\" class=\"headerlink\" title=\"6.JSON转Map：\"></a>6.JSON转Map：</h3><h4 id=\"JSON-转为-Map，正常情况下，所有键名都是字符串。\"><a href=\"#JSON-转为-Map，正常情况下，所有键名都是字符串。\" class=\"headerlink\" title=\"JSON 转为 Map，正常情况下，所有键名都是字符串。\"></a>JSON 转为 Map，正常情况下，所有键名都是字符串。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function jsonToStrMap(jsonStr) &#123;</span><br><span class=\"line\">  return objToStrMap(JSON.parse(jsonStr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"有一种特殊情况，整个-JSON-就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为-Map。这往往是-Map-转为数组-JSON-的逆操作。\"><a href=\"#有一种特殊情况，整个-JSON-就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为-Map。这往往是-Map-转为数组-JSON-的逆操作。\" class=\"headerlink\" title=\"有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。\"></a>有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function jsonToMap(jsonStr) &#123;</span><br><span class=\"line\">  return new Map(JSON.parse(jsonStr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jsonToMap(&apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</span><br><span class=\"line\"> * 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</span><br><span class=\"line\"> * 示例:</span><br><span class=\"line\"> * 给定 nums = [2, 7, 11, 15], target = 9</span><br><span class=\"line\"> * 因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class=\"line\"> * 所以返回 [0, 1]</span><br><span class=\"line\"> * 给定 nums = [3, 4, 2], target = 6</span><br><span class=\"line\"> * 因为 nums[1] + nums[2] = 4 + 2 = 6</span><br><span class=\"line\"> * 所以返回 [1, 2]</span><br><span class=\"line\"> * 给定 nums = [3, 3], target = 6</span><br><span class=\"line\"> * 因为 nums[0] + nums[1] = 3 + 3 = 6</span><br><span class=\"line\"> * 所以返回 [0, 1]</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;number[]&#125; nums</span><br><span class=\"line\"> * @param &#123;number&#125; target</span><br><span class=\"line\"> * @return &#123;number[]&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 思路：在Map中存储key为target-nums[i]的差值，value为索引i</span><br><span class=\"line\"> * 遍历原始数组nums，如果Map中不存在nums[i]，set差值和i</span><br><span class=\"line\"> * 如果存在nums[i],说明Map中的键nums[i]对应的值和当次循环的i为所求</span><br><span class=\"line\"> */</span><br><span class=\"line\">function twoSum (nums, target) &#123;</span><br><span class=\"line\">    const result = [];</span><br><span class=\"line\">    const myMap = new Map();</span><br><span class=\"line\">    if(nums == null || nums.length &lt;= 1) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for(let i = 0,len = nums.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        if(myMap.has(nums[i])) &#123;</span><br><span class=\"line\">            result[0] = myMap.get(nums[i]);</span><br><span class=\"line\">            result[1] = i;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            myMap.set(target - nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(result);</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">twoSum([3,3],6);</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h1 id=\"Set\"><a href=\"#Set\" class=\"headerlink\" title=\"Set:\"></a>Set:</h1><h2 id=\"构造函数（可生成Set数据结构），类似数组，成员值唯一。\"><a href=\"#构造函数（可生成Set数据结构），类似数组，成员值唯一。\" class=\"headerlink\" title=\"构造函数（可生成Set数据结构），类似数组，成员值唯一。\"></a>构造函数（可生成Set数据结构），类似数组，成员值唯一。</h2><h2 id=\"Set实例具有的属性：\"><a href=\"#Set实例具有的属性：\" class=\"headerlink\" title=\"Set实例具有的属性：\"></a>Set实例具有的属性：</h2><h3 id=\"1-Set-prototype-constructor-默认Set\"><a href=\"#1-Set-prototype-constructor-默认Set\" class=\"headerlink\" title=\"1.Set.prototype.constructor:默认Set\"></a>1.Set.prototype.constructor:默认Set</h3><h3 id=\"2-Set-prototype-size-成员总数\"><a href=\"#2-Set-prototype-size-成员总数\" class=\"headerlink\" title=\"2.Set.prototype.size:成员总数\"></a>2.Set.prototype.size:成员总数</h3>","more":"<h2 id=\"Set实例的操作和遍历方法：\"><a href=\"#Set实例的操作和遍历方法：\" class=\"headerlink\" title=\"Set实例的操作和遍历方法：\"></a>Set实例的操作和遍历方法：</h2><h3 id=\"1-add-value-：添加，返回Set结构\"><a href=\"#1-add-value-：添加，返回Set结构\" class=\"headerlink\" title=\"1.add(value)：添加，返回Set结构\"></a>1.add(value)：添加，返回Set结构</h3><h3 id=\"2-delete-value-：删除，返回布尔值，表示是否删除成功\"><a href=\"#2-delete-value-：删除，返回布尔值，表示是否删除成功\" class=\"headerlink\" title=\"2.delete(value)：删除，返回布尔值，表示是否删除成功\"></a>2.delete(value)：删除，返回布尔值，表示是否删除成功</h3><h3 id=\"3-has-value-：返回布尔值，表示是否为Set成员\"><a href=\"#3-has-value-：返回布尔值，表示是否为Set成员\" class=\"headerlink\" title=\"3.has(value)：返回布尔值，表示是否为Set成员\"></a>3.has(value)：返回布尔值，表示是否为Set成员</h3><h3 id=\"4-clear-：清除所有成员，无返回值\"><a href=\"#4-clear-：清除所有成员，无返回值\" class=\"headerlink\" title=\"4.clear()：清除所有成员，无返回值\"></a>4.clear()：清除所有成员，无返回值</h3><h3 id=\"5-keys-：返回键名\"><a href=\"#5-keys-：返回键名\" class=\"headerlink\" title=\"5.keys()：返回键名\"></a>5.keys()：返回键名</h3><h3 id=\"6-values-：返回键值\"><a href=\"#6-values-：返回键值\" class=\"headerlink\" title=\"6.values()：返回键值\"></a>6.values()：返回键值</h3><h3 id=\"7-entries-：返回键值对\"><a href=\"#7-entries-：返回键值对\" class=\"headerlink\" title=\"7.entries()：返回键值对\"></a>7.entries()：返回键值对</h3><h3 id=\"8-forEach-：使用回调函数遍历每个成员\"><a href=\"#8-forEach-：使用回调函数遍历每个成员\" class=\"headerlink\" title=\"8.forEach()：使用回调函数遍历每个成员\"></a>8.forEach()：使用回调函数遍历每个成员</h3><h2 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h2><h4 id=\"1-用于数组去重\"><a href=\"#1-用于数组去重\" class=\"headerlink\" title=\"1.用于数组去重\"></a>1.用于数组去重</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Set(arr)</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-向Set加入值时不会发生类型转换，比较时采用类似-的算法比较，区别在于Set中认为NaN等于自身（向Set中加入两个NaN时只能加入一个），-中认为NaN-NaN\"><a href=\"#2-向Set加入值时不会发生类型转换，比较时采用类似-的算法比较，区别在于Set中认为NaN等于自身（向Set中加入两个NaN时只能加入一个），-中认为NaN-NaN\" class=\"headerlink\" title=\"2.向Set加入值时不会发生类型转换，比较时采用类似 === 的算法比较，区别在于Set中认为NaN等于自身（向Set中加入两个NaN时只能加入一个），=== 中认为NaN!==NaN\"></a>2.向Set加入值时不会发生类型转换，比较时采用类似 === 的算法比较，区别在于Set中认为NaN等于自身（向Set中加入两个NaN时只能加入一个），=== 中认为NaN!==NaN</h4><h4 id=\"3-Set的遍历顺序是插入顺序，使用Set保存一个回调函数列表，调用时就能保证按照加入顺序调用\"><a href=\"#3-Set的遍历顺序是插入顺序，使用Set保存一个回调函数列表，调用时就能保证按照加入顺序调用\" class=\"headerlink\" title=\"3.Set的遍历顺序是插入顺序，使用Set保存一个回调函数列表，调用时就能保证按照加入顺序调用\"></a>3.Set的遍历顺序是插入顺序，使用Set保存一个回调函数列表，调用时就能保证按照加入顺序调用</h4><h4 id=\"4-keys-和values-返回一致，因为Set只有键值（或者说键名和键值一样）\"><a href=\"#4-keys-和values-返回一致，因为Set只有键值（或者说键名和键值一样）\" class=\"headerlink\" title=\"4.keys()和values()返回一致，因为Set只有键值（或者说键名和键值一样）\"></a>4.keys()和values()返回一致，因为Set只有键值（或者说键名和键值一样）</h4><h4 id=\"5-Set结构的实例默认可遍历，默认生成函数为values，可以直接用for···of···遍历\"><a href=\"#5-Set结构的实例默认可遍历，默认生成函数为values，可以直接用for···of···遍历\" class=\"headerlink\" title=\"5.Set结构的实例默认可遍历，默认生成函数为values，可以直接用for···of···遍历\"></a>5.Set结构的实例默认可遍历，默认生成函数为values，可以直接用for···of···遍历</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set.prototype[Symbole.iterator] === Set.prototype.values</span><br></pre></td></tr></table></figure>\n<h4 id=\"6-扩展运算符内部使用for···of循环，也可以用来遍历。扩展运算符和Set结构一起可以用作数组去重\"><a href=\"#6-扩展运算符内部使用for···of循环，也可以用来遍历。扩展运算符和Set结构一起可以用作数组去重\" class=\"headerlink\" title=\"6.扩展运算符内部使用for···of循环，也可以用来遍历。扩展运算符和Set结构一起可以用作数组去重\"></a>6.扩展运算符内部使用for···of循环，也可以用来遍历。扩展运算符和Set结构一起可以用作数组去重</h4><h5 id=\"eg1：\"><a href=\"#eg1：\" class=\"headerlink\" title=\"eg1：\"></a>eg1：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set = new Set(arr);</span><br><span class=\"line\">let result = [···set];</span><br></pre></td></tr></table></figure>\n<h5 id=\"eg2：\"><a href=\"#eg2：\" class=\"headerlink\" title=\"eg2：\"></a>eg2：</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,4,2,2,4,5,3];</span><br><span class=\"line\">let result = [···new Set(arr)];</span><br></pre></td></tr></table></figure>\n<h4 id=\"7-使用Set实现并集、交集、差集\"><a href=\"#7-使用Set实现并集、交集、差集\" class=\"headerlink\" title=\"7.使用Set实现并集、交集、差集\"></a>7.使用Set实现并集、交集、差集</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = new Set([1, 2, 3]);</span><br><span class=\"line\">let b = new Set([4, 3, 2]);</span><br><span class=\"line\"></span><br><span class=\"line\">// 并集 </span><br><span class=\"line\">let union = new Set([...a, ...b]); </span><br><span class=\"line\">// Set &#123;1, 2, 3, 4&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 交集</span><br><span class=\"line\">let intersect = new Set([...a].filter(x =&gt; b.has(x))); </span><br><span class=\"line\">// Set &#123;2, 3&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 差集</span><br><span class=\"line\">let difference = new Set([...a].filter(x =&gt; !b.has(x)));  </span><br><span class=\"line\">// Set &#123;1&#125;</span><br></pre></td></tr></table></figure>\n<h1 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map:\"></a>Map:</h1><h2 id=\"JS对象，键值对集合（Hash结构）。\"><a href=\"#JS对象，键值对集合（Hash结构）。\" class=\"headerlink\" title=\"JS对象，键值对集合（Hash结构）。\"></a>JS对象，键值对集合（Hash结构）。</h2><h2 id=\"注意：-1\"><a href=\"#注意：-1\" class=\"headerlink\" title=\"注意：\"></a>注意：</h2><h3 id=\"1-Map构造函数接受数组作为参数\"><a href=\"#1-Map构造函数接受数组作为参数\" class=\"headerlink\" title=\"1.Map构造函数接受数组作为参数\"></a>1.Map构造函数接受数组作为参数</h3><h3 id=\"2-Set和Map都可以用来生成新的Map\"><a href=\"#2-Set和Map都可以用来生成新的Map\" class=\"headerlink\" title=\"2.Set和Map都可以用来生成新的Map\"></a>2.Set和Map都可以用来生成新的Map</h3><h3 id=\"3-如果对同一个键多次赋值，后面的值将覆盖前面的值，如果读取一个未知的键值，返回undefined\"><a href=\"#3-如果对同一个键多次赋值，后面的值将覆盖前面的值，如果读取一个未知的键值，返回undefined\" class=\"headerlink\" title=\"3.如果对同一个键多次赋值，后面的值将覆盖前面的值，如果读取一个未知的键值，返回undefined\"></a>3.如果对同一个键多次赋值，后面的值将覆盖前面的值，如果读取一个未知的键值，返回undefined</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map</span><br><span class=\"line\">.set(1, &apos;aaa&apos;)</span><br><span class=\"line\">.set(1, &apos;bbb&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(1) // &quot;bbb&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">new Map().get(&apos;asfddfsasadf&apos;)</span><br><span class=\"line\">// undefined</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-只有对同一个对象的引用，Map-结构才将其视为同一个键；同理，同样的值的两个实例，在Map结构中被视为两个键\"><a href=\"#4-只有对同一个对象的引用，Map-结构才将其视为同一个键；同理，同样的值的两个实例，在Map结构中被视为两个键\" class=\"headerlink\" title=\"4.只有对同一个对象的引用，Map 结构才将其视为同一个键；同理，同样的值的两个实例，在Map结构中被视为两个键\"></a>4.只有对同一个对象的引用，Map 结构才将其视为同一个键；同理，同样的值的两个实例，在Map结构中被视为两个键</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set([&apos;a&apos;], 555);</span><br><span class=\"line\">map.get([&apos;a&apos;]) // undefined</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">const k1 = [&apos;a&apos;];</span><br><span class=\"line\">const k2 = [&apos;a&apos;];</span><br><span class=\"line\"></span><br><span class=\"line\">map</span><br><span class=\"line\">.set(k1, 111)</span><br><span class=\"line\">.set(k2, 222);</span><br><span class=\"line\"></span><br><span class=\"line\">map.get(k1) // 111</span><br><span class=\"line\">map.get(k2) // 222</span><br></pre></td></tr></table></figure>\n<p><em>Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（crash）的问题</em></p>\n<h4 id=\"5-如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键\"><a href=\"#5-如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键\" class=\"headerlink\" title=\"5.如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键\"></a>5.如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(-0, 123);</span><br><span class=\"line\">map.get(+0) // 123</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(true, 1);</span><br><span class=\"line\">map.set(&apos;true&apos;, 2);</span><br><span class=\"line\">map.get(true) // 1</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(undefined, 3);</span><br><span class=\"line\">map.set(null, 4);</span><br><span class=\"line\">map.get(undefined) // 3</span><br><span class=\"line\"></span><br><span class=\"line\">map.set(NaN, 123);</span><br><span class=\"line\">map.get(NaN) // 123</span><br></pre></td></tr></table></figure>\n<h2 id=\"Map实例的属性\"><a href=\"#Map实例的属性\" class=\"headerlink\" title=\"Map实例的属性\"></a>Map实例的属性</h2><h3 id=\"1-map-size：返回Map结构的成员总数\"><a href=\"#1-map-size：返回Map结构的成员总数\" class=\"headerlink\" title=\"1.map.size：返回Map结构的成员总数\"></a>1.map.size：返回Map结构的成员总数</h3><h3 id=\"2-map-set：设置键名key对应的键值为value，返回Map结构，如果key值已存在，则value会被更新，否则生成该key\"><a href=\"#2-map-set：设置键名key对应的键值为value，返回Map结构，如果key值已存在，则value会被更新，否则生成该key\" class=\"headerlink\" title=\"2.map.set：设置键名key对应的键值为value，返回Map结构，如果key值已存在，则value会被更新，否则生成该key\"></a>2.map.set：设置键名key对应的键值为value，返回Map结构，如果key值已存在，则value会被更新，否则生成该key</h3><p><em>set方法返回的是当前的Map对象，因此可以采用链式写法</em></p>\n<h2 id=\"Map实例的操作和遍历方法\"><a href=\"#Map实例的操作和遍历方法\" class=\"headerlink\" title=\"Map实例的操作和遍历方法\"></a>Map实例的操作和遍历方法</h2><h3 id=\"1-map-get：读取key对应的键值，找不到返回undefined\"><a href=\"#1-map-get：读取key对应的键值，找不到返回undefined\" class=\"headerlink\" title=\"1.map.get：读取key对应的键值，找不到返回undefined\"></a>1.map.get：读取key对应的键值，找不到返回undefined</h3><h3 id=\"2-map-has：返回布尔值，表示某个键是否在当前Map对象之中\"><a href=\"#2-map-has：返回布尔值，表示某个键是否在当前Map对象之中\" class=\"headerlink\" title=\"2.map.has：返回布尔值，表示某个键是否在当前Map对象之中\"></a>2.map.has：返回布尔值，表示某个键是否在当前Map对象之中</h3><h3 id=\"3-map-delete：删除某个键，成功返回true，失败返回false\"><a href=\"#3-map-delete：删除某个键，成功返回true，失败返回false\" class=\"headerlink\" title=\"3.map.delete：删除某个键，成功返回true，失败返回false\"></a>3.map.delete：删除某个键，成功返回true，失败返回false</h3><h3 id=\"4-map-clear：清除所有成员，无返回值\"><a href=\"#4-map-clear：清除所有成员，无返回值\" class=\"headerlink\" title=\"4.map.clear：清除所有成员，无返回值\"></a>4.map.clear：清除所有成员，无返回值</h3><h3 id=\"5-keys：返回键名\"><a href=\"#5-keys：返回键名\" class=\"headerlink\" title=\"5.keys：返回键名\"></a>5.keys：返回键名</h3><h3 id=\"6-values：返回键值\"><a href=\"#6-values：返回键值\" class=\"headerlink\" title=\"6.values：返回键值\"></a>6.values：返回键值</h3><h3 id=\"7-entries：返回所有成员\"><a href=\"#7-entries：返回所有成员\" class=\"headerlink\" title=\"7.entries：返回所有成员\"></a>7.entries：返回所有成员</h3><h3 id=\"8-forEach：遍历Map所有成员\"><a href=\"#8-forEach：遍历Map所有成员\" class=\"headerlink\" title=\"8.forEach：遍历Map所有成员\"></a>8.forEach：遍历Map所有成员</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (let [key, value] of map.entries()) &#123;</span><br><span class=\"line\">  console.log(key, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">// 等同于</span><br><span class=\"line\">for (let [key, value] of map) &#123;</span><br><span class=\"line\">  console.log(key, value);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><em>Map结构的默认遍历器接口为entries方法，即：</em><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map[Symbol.iterator] === map.entries</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"与其他数据结构的互相转换\"><a href=\"#与其他数据结构的互相转换\" class=\"headerlink\" title=\"与其他数据结构的互相转换\"></a>与其他数据结构的互相转换</h2><h3 id=\"1-Map转数组：-···new-Map\"><a href=\"#1-Map转数组：-···new-Map\" class=\"headerlink\" title=\"1.Map转数组：(···new Map)\"></a>1.Map转数组：(···new Map)</h3><h3 id=\"2-数组转MAp：new-Map-arr\"><a href=\"#2-数组转MAp：new-Map-arr\" class=\"headerlink\" title=\"2.数组转MAp：new Map(arr)\"></a>2.数组转MAp：new Map(arr)</h3><h3 id=\"3-Map转对象：如果所有-Map-的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\"><a href=\"#3-Map转对象：如果所有-Map-的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\" class=\"headerlink\" title=\"3.Map转对象：如果所有 Map 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。\"></a>3.Map转对象：如果所有 Map 的键都是字符串，它可以无损地转为对象。如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function strMapToObj(strMap) &#123;</span><br><span class=\"line\">  let obj = Object.create(null);</span><br><span class=\"line\">  for (let [k,v] of strMap) &#123;</span><br><span class=\"line\">    obj[k] = v;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">const myMap = new Map()</span><br><span class=\"line\">  .set(&apos;yes&apos;, true)</span><br><span class=\"line\">  .set(&apos;no&apos;, false);</span><br><span class=\"line\">strMapToObj(myMap)</span><br></pre></td></tr></table></figure>\n<h3 id=\"4-对象转Map：\"><a href=\"#4-对象转Map：\" class=\"headerlink\" title=\"4.对象转Map：\"></a>4.对象转Map：</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function objToStrMap(obj) &#123;</span><br><span class=\"line\">  let strMap = new Map();</span><br><span class=\"line\">  for (let k of Object.keys(obj)) &#123;</span><br><span class=\"line\">    strMap.set(k, obj[k]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return strMap;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">objToStrMap(&#123;yes: true, no: false&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"5-Map转JSON：\"><a href=\"#5-Map转JSON：\" class=\"headerlink\" title=\"5.Map转JSON：\"></a>5.Map转JSON：</h3><h4 id=\"Map-的键名都是字符串，这时可以选择转为对象-JSON。\"><a href=\"#Map-的键名都是字符串，这时可以选择转为对象-JSON。\" class=\"headerlink\" title=\"Map 的键名都是字符串，这时可以选择转为对象 JSON。\"></a>Map 的键名都是字符串，这时可以选择转为对象 JSON。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function strMapToJson(strMap) &#123;</span><br><span class=\"line\">  return JSON.stringify(strMapToObj(strMap));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let myMap = new Map().set(&apos;yes&apos;, true).set(&apos;no&apos;, false);</span><br><span class=\"line\">strMapToJson(myMap)</span><br></pre></td></tr></table></figure>\n<h4 id=\"Map-的键名有非字符串，这时可以选择转为数组-JSON。\"><a href=\"#Map-的键名有非字符串，这时可以选择转为数组-JSON。\" class=\"headerlink\" title=\"Map 的键名有非字符串，这时可以选择转为数组 JSON。\"></a>Map 的键名有非字符串，这时可以选择转为数组 JSON。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function mapToArrayJson(map) &#123;</span><br><span class=\"line\">  return JSON.stringify([...map]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let myMap = new Map().set(true, 7).set(&#123;foo: 3&#125;, [&apos;abc&apos;]);</span><br><span class=\"line\">mapToArrayJson(myMap)</span><br></pre></td></tr></table></figure>\n<h3 id=\"6-JSON转Map：\"><a href=\"#6-JSON转Map：\" class=\"headerlink\" title=\"6.JSON转Map：\"></a>6.JSON转Map：</h3><h4 id=\"JSON-转为-Map，正常情况下，所有键名都是字符串。\"><a href=\"#JSON-转为-Map，正常情况下，所有键名都是字符串。\" class=\"headerlink\" title=\"JSON 转为 Map，正常情况下，所有键名都是字符串。\"></a>JSON 转为 Map，正常情况下，所有键名都是字符串。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function jsonToStrMap(jsonStr) &#123;</span><br><span class=\"line\">  return objToStrMap(JSON.parse(jsonStr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jsonToStrMap(&apos;&#123;&quot;yes&quot;: true, &quot;no&quot;: false&#125;&apos;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"有一种特殊情况，整个-JSON-就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为-Map。这往往是-Map-转为数组-JSON-的逆操作。\"><a href=\"#有一种特殊情况，整个-JSON-就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为-Map。这往往是-Map-转为数组-JSON-的逆操作。\" class=\"headerlink\" title=\"有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。\"></a>有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function jsonToMap(jsonStr) &#123;</span><br><span class=\"line\">  return new Map(JSON.parse(jsonStr));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">jsonToMap(&apos;[[true,7],[&#123;&quot;foo&quot;:3&#125;,[&quot;abc&quot;]]]&apos;)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;use strict&quot;;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * </span><br><span class=\"line\"> * 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。</span><br><span class=\"line\"> * 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。</span><br><span class=\"line\"> * 示例:</span><br><span class=\"line\"> * 给定 nums = [2, 7, 11, 15], target = 9</span><br><span class=\"line\"> * 因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class=\"line\"> * 所以返回 [0, 1]</span><br><span class=\"line\"> * 给定 nums = [3, 4, 2], target = 6</span><br><span class=\"line\"> * 因为 nums[1] + nums[2] = 4 + 2 = 6</span><br><span class=\"line\"> * 所以返回 [1, 2]</span><br><span class=\"line\"> * 给定 nums = [3, 3], target = 6</span><br><span class=\"line\"> * 因为 nums[0] + nums[1] = 3 + 3 = 6</span><br><span class=\"line\"> * 所以返回 [0, 1]</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * @param &#123;number[]&#125; nums</span><br><span class=\"line\"> * @param &#123;number&#125; target</span><br><span class=\"line\"> * @return &#123;number[]&#125;</span><br><span class=\"line\"> */</span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 思路：在Map中存储key为target-nums[i]的差值，value为索引i</span><br><span class=\"line\"> * 遍历原始数组nums，如果Map中不存在nums[i]，set差值和i</span><br><span class=\"line\"> * 如果存在nums[i],说明Map中的键nums[i]对应的值和当次循环的i为所求</span><br><span class=\"line\"> */</span><br><span class=\"line\">function twoSum (nums, target) &#123;</span><br><span class=\"line\">    const result = [];</span><br><span class=\"line\">    const myMap = new Map();</span><br><span class=\"line\">    if(nums == null || nums.length &lt;= 1) &#123;</span><br><span class=\"line\">        return false;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    for(let i = 0,len = nums.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        if(myMap.has(nums[i])) &#123;</span><br><span class=\"line\">            result[0] = myMap.get(nums[i]);</span><br><span class=\"line\">            result[1] = i;</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            myMap.set(target - nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(result);</span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">twoSum([3,3],6);</span><br></pre></td></tr></table></figure>"},{"title":"腾讯now直播一面笔试题再探","date":"2018-05-18T08:36:01.000Z","about":null,"_content":"\nemmmmm，现在回过头来看腾讯面试题了，哇~ 想想当时的寄己，真的是基础不过关，也就只能现在弥补了！\n看题——\n\n```\n写一个构造方法Point，要求实现以下功能：\nlet point = new Point(100, 100);\nlet anotherPoint = point.move(-10, 10);\nconsole.info(anotherPoint.coor); // {x: 90, y:110}\nconsole.info(point.coor); // {x: 100, y: 100}\n```\n<!--more-->\n\n> 首先说一下思路：Point类有一个成员方法move()和coor()，move()接收两个参数(a, b)，并且返回一个新的Point对象，新对象的值是(当前对象+a, 当前对象+b)，coor()返回当前对象的值。\n\n\n```\n// 方法一\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n        \n    get coor() {\n        return {\n            x: this.x,\n            y: this.y\n        }\n    }\n\n    move(a, b) {\n        return new Point(this.x + a, this.y + b);\n    }\n}\n    \nlet point = new Point(100,100);\nlet anotherPoint = point.move(-10,10);\nconsole.info(anotherPoint.coor); // { x: 90, y: 110 }\nconsole.info(point.coor); // { x: 100, y: 100 }\n```\n\n```\n// 方法二\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.coor = {\n            x: this.x,\n            y: this.y\n        }\n    }\n\n    move(a, b) {\n        return new Point(this.x + a, this.y + b);\n    }\n}\n\nlet point = new Point(100,100);\nlet anotherPoint = point.move(-10,10);\nconsole.info(anotherPoint.coor); // { x: 90, y: 110 }\nconsole.info(point.coor); // { x: 100, y: 100 }\n```\n\n","source":"_posts/腾讯now直播一面笔试题再探.md","raw":"---\ntitle: 腾讯now直播一面笔试题再探\ndate: 2018-05-18 16:36:01\ntags:\n- 类\n- 对象\ncategories: ES5 ES6\nabout:\n---\n\nemmmmm，现在回过头来看腾讯面试题了，哇~ 想想当时的寄己，真的是基础不过关，也就只能现在弥补了！\n看题——\n\n```\n写一个构造方法Point，要求实现以下功能：\nlet point = new Point(100, 100);\nlet anotherPoint = point.move(-10, 10);\nconsole.info(anotherPoint.coor); // {x: 90, y:110}\nconsole.info(point.coor); // {x: 100, y: 100}\n```\n<!--more-->\n\n> 首先说一下思路：Point类有一个成员方法move()和coor()，move()接收两个参数(a, b)，并且返回一个新的Point对象，新对象的值是(当前对象+a, 当前对象+b)，coor()返回当前对象的值。\n\n\n```\n// 方法一\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n        \n    get coor() {\n        return {\n            x: this.x,\n            y: this.y\n        }\n    }\n\n    move(a, b) {\n        return new Point(this.x + a, this.y + b);\n    }\n}\n    \nlet point = new Point(100,100);\nlet anotherPoint = point.move(-10,10);\nconsole.info(anotherPoint.coor); // { x: 90, y: 110 }\nconsole.info(point.coor); // { x: 100, y: 100 }\n```\n\n```\n// 方法二\nclass Point {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n        this.coor = {\n            x: this.x,\n            y: this.y\n        }\n    }\n\n    move(a, b) {\n        return new Point(this.x + a, this.y + b);\n    }\n}\n\nlet point = new Point(100,100);\nlet anotherPoint = point.move(-10,10);\nconsole.info(anotherPoint.coor); // { x: 90, y: 110 }\nconsole.info(point.coor); // { x: 100, y: 100 }\n```\n\n","slug":"腾讯now直播一面笔试题再探","published":1,"updated":"2019-02-22T08:37:33.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugroz0014vrie7nkvgr3y","content":"<p>emmmmm，现在回过头来看腾讯面试题了，哇~ 想想当时的寄己，真的是基础不过关，也就只能现在弥补了！<br>看题——</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">写一个构造方法Point，要求实现以下功能：</span><br><span class=\"line\">let point = new Point(100, 100);</span><br><span class=\"line\">let anotherPoint = point.move(-10, 10);</span><br><span class=\"line\">console.info(anotherPoint.coor); // &#123;x: 90, y:110&#125;</span><br><span class=\"line\">console.info(point.coor); // &#123;x: 100, y: 100&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<blockquote>\n<p>首先说一下思路：Point类有一个成员方法move()和coor()，move()接收两个参数(a, b)，并且返回一个新的Point对象，新对象的值是(当前对象+a, 当前对象+b)，coor()返回当前对象的值。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 方法一</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\">    constructor(x, y) &#123;</span><br><span class=\"line\">        this.x = x;</span><br><span class=\"line\">        this.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    get coor() &#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            x: this.x,</span><br><span class=\"line\">            y: this.y</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    move(a, b) &#123;</span><br><span class=\"line\">        return new Point(this.x + a, this.y + b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">let point = new Point(100,100);</span><br><span class=\"line\">let anotherPoint = point.move(-10,10);</span><br><span class=\"line\">console.info(anotherPoint.coor); // &#123; x: 90, y: 110 &#125;</span><br><span class=\"line\">console.info(point.coor); // &#123; x: 100, y: 100 &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 方法二</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\">    constructor(x, y) &#123;</span><br><span class=\"line\">        this.x = x;</span><br><span class=\"line\">        this.y = y;</span><br><span class=\"line\">        this.coor = &#123;</span><br><span class=\"line\">            x: this.x,</span><br><span class=\"line\">            y: this.y</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    move(a, b) &#123;</span><br><span class=\"line\">        return new Point(this.x + a, this.y + b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let point = new Point(100,100);</span><br><span class=\"line\">let anotherPoint = point.move(-10,10);</span><br><span class=\"line\">console.info(anotherPoint.coor); // &#123; x: 90, y: 110 &#125;</span><br><span class=\"line\">console.info(point.coor); // &#123; x: 100, y: 100 &#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>emmmmm，现在回过头来看腾讯面试题了，哇~ 想想当时的寄己，真的是基础不过关，也就只能现在弥补了！<br>看题——</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">写一个构造方法Point，要求实现以下功能：</span><br><span class=\"line\">let point = new Point(100, 100);</span><br><span class=\"line\">let anotherPoint = point.move(-10, 10);</span><br><span class=\"line\">console.info(anotherPoint.coor); // &#123;x: 90, y:110&#125;</span><br><span class=\"line\">console.info(point.coor); // &#123;x: 100, y: 100&#125;</span><br></pre></td></tr></table></figure>","more":"<blockquote>\n<p>首先说一下思路：Point类有一个成员方法move()和coor()，move()接收两个参数(a, b)，并且返回一个新的Point对象，新对象的值是(当前对象+a, 当前对象+b)，coor()返回当前对象的值。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 方法一</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\">    constructor(x, y) &#123;</span><br><span class=\"line\">        this.x = x;</span><br><span class=\"line\">        this.y = y;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">        </span><br><span class=\"line\">    get coor() &#123;</span><br><span class=\"line\">        return &#123;</span><br><span class=\"line\">            x: this.x,</span><br><span class=\"line\">            y: this.y</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    move(a, b) &#123;</span><br><span class=\"line\">        return new Point(this.x + a, this.y + b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">let point = new Point(100,100);</span><br><span class=\"line\">let anotherPoint = point.move(-10,10);</span><br><span class=\"line\">console.info(anotherPoint.coor); // &#123; x: 90, y: 110 &#125;</span><br><span class=\"line\">console.info(point.coor); // &#123; x: 100, y: 100 &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 方法二</span><br><span class=\"line\">class Point &#123;</span><br><span class=\"line\">    constructor(x, y) &#123;</span><br><span class=\"line\">        this.x = x;</span><br><span class=\"line\">        this.y = y;</span><br><span class=\"line\">        this.coor = &#123;</span><br><span class=\"line\">            x: this.x,</span><br><span class=\"line\">            y: this.y</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    move(a, b) &#123;</span><br><span class=\"line\">        return new Point(this.x + a, this.y + b);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let point = new Point(100,100);</span><br><span class=\"line\">let anotherPoint = point.move(-10,10);</span><br><span class=\"line\">console.info(anotherPoint.coor); // &#123; x: 90, y: 110 &#125;</span><br><span class=\"line\">console.info(point.coor); // &#123; x: 100, y: 100 &#125;</span><br></pre></td></tr></table></figure>"},{"title":"解锁js数组去重的多种方法","date":"2018-06-01T06:54:08.000Z","about":null,"_content":"\n方法一：双重循环+新建数组(1)\n\n思路：新建一个数组存放返回的去重后的数组，设置一个标志来标识原数组和新数组中的元素是否重复，外层循环控制趟数，内层循环控制新数组和原数组元素的比较，如果新数组和原数组的元素相同，标志位置true，并跳出当前循环，如果新数组和原数组元素不同，执行完当前循环后，将外层循环变量指向的元素push进新数组\n\n<!--more-->\n\n```\nfunction unique(arr) {\n    const res = [];\n    let isRepeat;\n\n    for(let i = 0, len = arr.length; i < len; i++) {\n        isRepeat = false;\n        for(let j = 0, resLen = res.length; j < resLen; j++) {\n            if(arr[i] === res[j]) {\n                isRepeat = true;\n                break;\n            }\n        }\n        if(!isRepeat) {\n            res.push(arr[i]);\n        }\n    }\n\n    console.log(res);\n    return res;\n}\n```\n\n方法二：双重循环+新建数组(2)\n\n思路：新建一个数组存放返回的去重后的数组，设置一个标志来标识原数组和新数组中的元素是否重复，外层控制趟数，内层比较，如果外层循环指向的元素和内层循环指向的元素相同，将标志位置true，并且跳出当前循环，但是不往新数组push外层循环变量指向的元素，继续下一趟循环，直到外层循环指向的变量和内层循环循环完之后都没有遇到相同元素，则把外层循环变量指向的元素push进新数组\n```\nfunction unique(arr) {\n    const res = [];\n    const len = arr.length;\n    let isRepeat;\n\n    for(let i = 0; i < len; i++) {\n        isRepeat = false;\n        for(let j = i + 1; j < len; j++) {\n            if(arr[i] === arr[j]) {\n                isRepeat = true;\n                break;\n            }     \n        }\n        if(!isRepeat) {\n            res.push(arr[i]);\n        }\n    }\n    console.log(res);\n    return res;\n}\n```\n\n方法三：双重循环+新建数组(3)\n\n思路：新建一个数组存放返回的去重后的数组，外层循环\n```\nfunction unique(arr) {\n    const res = [];\n    const len = arr.length;\n\n    for(let i = 0; i < len; i++) {\n        for(let j = i + 1; j < len; j++) {\n            if(arr[i] === arr[j]) {\n                j = ++i;\n            }\n        }\n        res.push(arr[i]);\n    }\n\n    console.log(res);\n    return res;\n}\n```\n\n方法四：新建数组+indexOf()\n\n思路：forEach遍历数组元素，利用indexOf()返回数组元素的索引来判断新数组中是否有当前遍历的元素的索引，如果没有的话，直接将当前元素push进新数组\n```\nfunction unique(arr) {\n    const res = [];\n    \n    arr.forEach(item => {\n        if(res.indexOf(item) === -1) {\n            res.push(item);\n        }\n    });\n\n    console.log(res);\n    return res;\n}\n```\n\n方法五：新建数组+filter+indexOf()\n\n思路：利用filter过滤功能简化外层循环，利用indexOf返回数组中元素第一次出现的位置，如果和filter过滤的索引相同的话就把当前元素push进新数组，如果不同就被过滤掉\n```\nfunction unique(arr) {\n    var res = [];\n\n    arr.filter((item, index) => {\n        if(arr.indexOf(item) === index) {\n            res.push(item);\n        }\n    });\n\n    console.log(res);\n    return res;\n}\n```\n\n方法六：新建数组+排序+单层循环\n\n思路：对要去重的数组先进行排序，然后新建数组用来存放去重后的数组，在原数数组中遍历和新数组每一次的最后一个元素去比较，如果当前遍历的元素和新数组的最后一个元素不同，把当前遍历的元素push进新数组\n```\nfunction unique(arr) {\n    const res = [];\n    arr.sort();\n\n    for(let i = 0, len = arr.length; i < len; i++) {\n        if(arr[i] !== res[res.length - 1]) {\n            res.push(arr[i]);\n        }\n    }\n\n    console.log(res);\n    return res;\n}\n```\n\n方法七：新建数组+排序+单层循环\n\n思路：对要去重的数组先进行排序，然后新建数组用来存放去重后的数组，循环遍历原数组，如果第i项和第i+1项元素不同的话，将第i项push进新数组，如果相同的话进行下一次循环\n```\nfunction unique(arr) {\n    const res = [];\n    arr.sort();\n\n    for(let i = 0, len = arr.length; i < len; i++) {\n        if(arr[i] !== arr[i+1]) {\n            res.push(arr[i]);\n        }\n    }\n\n    console.log(res);\n    return res;\n}\n```\n\n方法八：新建数组+单层循环+includes()\n\n思路：新建数组用来存放去重后的数组，forEach遍历数组，如果新数组中不包含当前遍历的元素，就把当前遍历的元素push进新数组\n\n注：includes用来判断一个数组中是否包含一个指定项，返回值为布尔值\n```\nfunction unique(arr) {\n    const res = [];\n\n    arr.forEach(item => {\n        if(!res.includes(item)) {\n            res.push(item);\n        }\n    });\n\n    console.log(res);\n    return res;\n}\n```\n\n方法九：排序+reduce()\n\n思路：reduce() 方法对数组中的每个元素（从左到右）执行回调，将其减少为单个值。回调函数的两个参数，init作为回调的第一个调用的第一个参数的值，currentValue为数组中正在处理的当前元素\n```\nfunction unique(arr) {\n\n    console.log(arr.sort().reduce((init, currentValue) => {\n        if(init.length === 0 || init[init.length - 1] !== currentValue) {\n            init.push(currentValue);\n        }\n\n        return init;\n    }, [])); \n}\n```\n\n方法十：Object键值对\n\n思路：利用对象的key不可以重复。但是这里要注意三个问题：\n\n1.无法区分隐式转换成字符串后一样的值，比如1和‘1’\n\n2.无法处理复杂数据类型，比如对象（因为对象作为key会变为[object objec]）\n\n3.特殊数据，比如‘proto’，因为对象的proto属性无法被重写\n\n```\nfunction unique(arr) {\n    const res = [];\n    const obj = {};\n\n    for(let i = 0, len = arr.length; i < len; i++) {\n        // 使用JSON.stringify()进行序列化\n        if(!obj[typeof arr[i] + JSON.stringify(arr[i])]) {\n            // 将对象序列化之后作为key来使用\n            obj[typeof arr[i] + JSON.stringify(arr[i])] = true;\n            res.push(arr[i]);\n        }\n    }\n\n    console.log(res);\n    return res;\n}\n```\n方法十一：ES6 Map(1)\n```\nfunction unique(arr) {\n    const res = [];\n    const temp = new Map();\n\n    for(let i = 0, len = arr.length; i < len; i++) {\n        if(!temp.get(arr[i])) {\n            temp.set(arr[i], 1);\n            res.push(arr[i]);\n        }\n    }\n\n    console.log(res);\n    return res;\n}\n```\n\n方法十二：ES6 Map(2)\n```\nfunction unique(arr) {\n    const temp = new Map();\n\n    console.log(arr.filter(item => {\n        return !temp.has(item) && temp.set(item, 1);\n    }));\n}\n```\n\n方法十三：ES6 Set(1)\n```\nfunction unique(arr) {\n    console.log(Array.from(new Set(arr)))\n    return Array.from(new Set(arr));\n}\n```\n\n方法十四：ES6 Set(2)\n\n```\nconst unique = (arr) => [...new Set(arr)]\n```\n","source":"_posts/解锁js数组去重的多种方法.md","raw":"---\ntitle: 解锁js数组去重的多种方法\ndate: 2018-06-01 14:54:08\ntags:\n- 数组去重\ncategories: JS手撕\nabout:\n---\n\n方法一：双重循环+新建数组(1)\n\n思路：新建一个数组存放返回的去重后的数组，设置一个标志来标识原数组和新数组中的元素是否重复，外层循环控制趟数，内层循环控制新数组和原数组元素的比较，如果新数组和原数组的元素相同，标志位置true，并跳出当前循环，如果新数组和原数组元素不同，执行完当前循环后，将外层循环变量指向的元素push进新数组\n\n<!--more-->\n\n```\nfunction unique(arr) {\n    const res = [];\n    let isRepeat;\n\n    for(let i = 0, len = arr.length; i < len; i++) {\n        isRepeat = false;\n        for(let j = 0, resLen = res.length; j < resLen; j++) {\n            if(arr[i] === res[j]) {\n                isRepeat = true;\n                break;\n            }\n        }\n        if(!isRepeat) {\n            res.push(arr[i]);\n        }\n    }\n\n    console.log(res);\n    return res;\n}\n```\n\n方法二：双重循环+新建数组(2)\n\n思路：新建一个数组存放返回的去重后的数组，设置一个标志来标识原数组和新数组中的元素是否重复，外层控制趟数，内层比较，如果外层循环指向的元素和内层循环指向的元素相同，将标志位置true，并且跳出当前循环，但是不往新数组push外层循环变量指向的元素，继续下一趟循环，直到外层循环指向的变量和内层循环循环完之后都没有遇到相同元素，则把外层循环变量指向的元素push进新数组\n```\nfunction unique(arr) {\n    const res = [];\n    const len = arr.length;\n    let isRepeat;\n\n    for(let i = 0; i < len; i++) {\n        isRepeat = false;\n        for(let j = i + 1; j < len; j++) {\n            if(arr[i] === arr[j]) {\n                isRepeat = true;\n                break;\n            }     \n        }\n        if(!isRepeat) {\n            res.push(arr[i]);\n        }\n    }\n    console.log(res);\n    return res;\n}\n```\n\n方法三：双重循环+新建数组(3)\n\n思路：新建一个数组存放返回的去重后的数组，外层循环\n```\nfunction unique(arr) {\n    const res = [];\n    const len = arr.length;\n\n    for(let i = 0; i < len; i++) {\n        for(let j = i + 1; j < len; j++) {\n            if(arr[i] === arr[j]) {\n                j = ++i;\n            }\n        }\n        res.push(arr[i]);\n    }\n\n    console.log(res);\n    return res;\n}\n```\n\n方法四：新建数组+indexOf()\n\n思路：forEach遍历数组元素，利用indexOf()返回数组元素的索引来判断新数组中是否有当前遍历的元素的索引，如果没有的话，直接将当前元素push进新数组\n```\nfunction unique(arr) {\n    const res = [];\n    \n    arr.forEach(item => {\n        if(res.indexOf(item) === -1) {\n            res.push(item);\n        }\n    });\n\n    console.log(res);\n    return res;\n}\n```\n\n方法五：新建数组+filter+indexOf()\n\n思路：利用filter过滤功能简化外层循环，利用indexOf返回数组中元素第一次出现的位置，如果和filter过滤的索引相同的话就把当前元素push进新数组，如果不同就被过滤掉\n```\nfunction unique(arr) {\n    var res = [];\n\n    arr.filter((item, index) => {\n        if(arr.indexOf(item) === index) {\n            res.push(item);\n        }\n    });\n\n    console.log(res);\n    return res;\n}\n```\n\n方法六：新建数组+排序+单层循环\n\n思路：对要去重的数组先进行排序，然后新建数组用来存放去重后的数组，在原数数组中遍历和新数组每一次的最后一个元素去比较，如果当前遍历的元素和新数组的最后一个元素不同，把当前遍历的元素push进新数组\n```\nfunction unique(arr) {\n    const res = [];\n    arr.sort();\n\n    for(let i = 0, len = arr.length; i < len; i++) {\n        if(arr[i] !== res[res.length - 1]) {\n            res.push(arr[i]);\n        }\n    }\n\n    console.log(res);\n    return res;\n}\n```\n\n方法七：新建数组+排序+单层循环\n\n思路：对要去重的数组先进行排序，然后新建数组用来存放去重后的数组，循环遍历原数组，如果第i项和第i+1项元素不同的话，将第i项push进新数组，如果相同的话进行下一次循环\n```\nfunction unique(arr) {\n    const res = [];\n    arr.sort();\n\n    for(let i = 0, len = arr.length; i < len; i++) {\n        if(arr[i] !== arr[i+1]) {\n            res.push(arr[i]);\n        }\n    }\n\n    console.log(res);\n    return res;\n}\n```\n\n方法八：新建数组+单层循环+includes()\n\n思路：新建数组用来存放去重后的数组，forEach遍历数组，如果新数组中不包含当前遍历的元素，就把当前遍历的元素push进新数组\n\n注：includes用来判断一个数组中是否包含一个指定项，返回值为布尔值\n```\nfunction unique(arr) {\n    const res = [];\n\n    arr.forEach(item => {\n        if(!res.includes(item)) {\n            res.push(item);\n        }\n    });\n\n    console.log(res);\n    return res;\n}\n```\n\n方法九：排序+reduce()\n\n思路：reduce() 方法对数组中的每个元素（从左到右）执行回调，将其减少为单个值。回调函数的两个参数，init作为回调的第一个调用的第一个参数的值，currentValue为数组中正在处理的当前元素\n```\nfunction unique(arr) {\n\n    console.log(arr.sort().reduce((init, currentValue) => {\n        if(init.length === 0 || init[init.length - 1] !== currentValue) {\n            init.push(currentValue);\n        }\n\n        return init;\n    }, [])); \n}\n```\n\n方法十：Object键值对\n\n思路：利用对象的key不可以重复。但是这里要注意三个问题：\n\n1.无法区分隐式转换成字符串后一样的值，比如1和‘1’\n\n2.无法处理复杂数据类型，比如对象（因为对象作为key会变为[object objec]）\n\n3.特殊数据，比如‘proto’，因为对象的proto属性无法被重写\n\n```\nfunction unique(arr) {\n    const res = [];\n    const obj = {};\n\n    for(let i = 0, len = arr.length; i < len; i++) {\n        // 使用JSON.stringify()进行序列化\n        if(!obj[typeof arr[i] + JSON.stringify(arr[i])]) {\n            // 将对象序列化之后作为key来使用\n            obj[typeof arr[i] + JSON.stringify(arr[i])] = true;\n            res.push(arr[i]);\n        }\n    }\n\n    console.log(res);\n    return res;\n}\n```\n方法十一：ES6 Map(1)\n```\nfunction unique(arr) {\n    const res = [];\n    const temp = new Map();\n\n    for(let i = 0, len = arr.length; i < len; i++) {\n        if(!temp.get(arr[i])) {\n            temp.set(arr[i], 1);\n            res.push(arr[i]);\n        }\n    }\n\n    console.log(res);\n    return res;\n}\n```\n\n方法十二：ES6 Map(2)\n```\nfunction unique(arr) {\n    const temp = new Map();\n\n    console.log(arr.filter(item => {\n        return !temp.has(item) && temp.set(item, 1);\n    }));\n}\n```\n\n方法十三：ES6 Set(1)\n```\nfunction unique(arr) {\n    console.log(Array.from(new Set(arr)))\n    return Array.from(new Set(arr));\n}\n```\n\n方法十四：ES6 Set(2)\n\n```\nconst unique = (arr) => [...new Set(arr)]\n```\n","slug":"解锁js数组去重的多种方法","published":1,"updated":"2019-02-22T08:37:33.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugrp00016vrieqg66vz0x","content":"<p>方法一：双重循环+新建数组(1)</p>\n<p>思路：新建一个数组存放返回的去重后的数组，设置一个标志来标识原数组和新数组中的元素是否重复，外层循环控制趟数，内层循环控制新数组和原数组元素的比较，如果新数组和原数组的元素相同，标志位置true，并跳出当前循环，如果新数组和原数组元素不同，执行完当前循环后，将外层循环变量指向的元素push进新数组</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    let isRepeat;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        isRepeat = false;</span><br><span class=\"line\">        for(let j = 0, resLen = res.length; j &lt; resLen; j++) &#123;</span><br><span class=\"line\">            if(arr[i] === res[j]) &#123;</span><br><span class=\"line\">                isRepeat = true;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(!isRepeat) &#123;</span><br><span class=\"line\">            res.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法二：双重循环+新建数组(2)</p>\n<p>思路：新建一个数组存放返回的去重后的数组，设置一个标志来标识原数组和新数组中的元素是否重复，外层控制趟数，内层比较，如果外层循环指向的元素和内层循环指向的元素相同，将标志位置true，并且跳出当前循环，但是不往新数组push外层循环变量指向的元素，继续下一趟循环，直到外层循环指向的变量和内层循环循环完之后都没有遇到相同元素，则把外层循环变量指向的元素push进新数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    const len = arr.length;</span><br><span class=\"line\">    let isRepeat;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">        isRepeat = false;</span><br><span class=\"line\">        for(let j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">            if(arr[i] === arr[j]) &#123;</span><br><span class=\"line\">                isRepeat = true;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;     </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(!isRepeat) &#123;</span><br><span class=\"line\">            res.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法三：双重循环+新建数组(3)</p>\n<p>思路：新建一个数组存放返回的去重后的数组，外层循环<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    const len = arr.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">        for(let j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">            if(arr[i] === arr[j]) &#123;</span><br><span class=\"line\">                j = ++i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法四：新建数组+indexOf()</p>\n<p>思路：forEach遍历数组元素，利用indexOf()返回数组元素的索引来判断新数组中是否有当前遍历的元素的索引，如果没有的话，直接将当前元素push进新数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    </span><br><span class=\"line\">    arr.forEach(item =&gt; &#123;</span><br><span class=\"line\">        if(res.indexOf(item) === -1) &#123;</span><br><span class=\"line\">            res.push(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法五：新建数组+filter+indexOf()</p>\n<p>思路：利用filter过滤功能简化外层循环，利用indexOf返回数组中元素第一次出现的位置，如果和filter过滤的索引相同的话就把当前元素push进新数组，如果不同就被过滤掉<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    arr.filter((item, index) =&gt; &#123;</span><br><span class=\"line\">        if(arr.indexOf(item) === index) &#123;</span><br><span class=\"line\">            res.push(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法六：新建数组+排序+单层循环</p>\n<p>思路：对要去重的数组先进行排序，然后新建数组用来存放去重后的数组，在原数数组中遍历和新数组每一次的最后一个元素去比较，如果当前遍历的元素和新数组的最后一个元素不同，把当前遍历的元素push进新数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    arr.sort();</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        if(arr[i] !== res[res.length - 1]) &#123;</span><br><span class=\"line\">            res.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法七：新建数组+排序+单层循环</p>\n<p>思路：对要去重的数组先进行排序，然后新建数组用来存放去重后的数组，循环遍历原数组，如果第i项和第i+1项元素不同的话，将第i项push进新数组，如果相同的话进行下一次循环<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    arr.sort();</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        if(arr[i] !== arr[i+1]) &#123;</span><br><span class=\"line\">            res.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法八：新建数组+单层循环+includes()</p>\n<p>思路：新建数组用来存放去重后的数组，forEach遍历数组，如果新数组中不包含当前遍历的元素，就把当前遍历的元素push进新数组</p>\n<p>注：includes用来判断一个数组中是否包含一个指定项，返回值为布尔值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    arr.forEach(item =&gt; &#123;</span><br><span class=\"line\">        if(!res.includes(item)) &#123;</span><br><span class=\"line\">            res.push(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法九：排序+reduce()</p>\n<p>思路：reduce() 方法对数组中的每个元素（从左到右）执行回调，将其减少为单个值。回调函数的两个参数，init作为回调的第一个调用的第一个参数的值，currentValue为数组中正在处理的当前元素<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(arr.sort().reduce((init, currentValue) =&gt; &#123;</span><br><span class=\"line\">        if(init.length === 0 || init[init.length - 1] !== currentValue) &#123;</span><br><span class=\"line\">            init.push(currentValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return init;</span><br><span class=\"line\">    &#125;, [])); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法十：Object键值对</p>\n<p>思路：利用对象的key不可以重复。但是这里要注意三个问题：</p>\n<p>1.无法区分隐式转换成字符串后一样的值，比如1和‘1’</p>\n<p>2.无法处理复杂数据类型，比如对象（因为对象作为key会变为[object objec]）</p>\n<p>3.特殊数据，比如‘proto’，因为对象的proto属性无法被重写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    const obj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        // 使用JSON.stringify()进行序列化</span><br><span class=\"line\">        if(!obj[typeof arr[i] + JSON.stringify(arr[i])]) &#123;</span><br><span class=\"line\">            // 将对象序列化之后作为key来使用</span><br><span class=\"line\">            obj[typeof arr[i] + JSON.stringify(arr[i])] = true;</span><br><span class=\"line\">            res.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法十一：ES6 Map(1)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    const temp = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        if(!temp.get(arr[i])) &#123;</span><br><span class=\"line\">            temp.set(arr[i], 1);</span><br><span class=\"line\">            res.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法十二：ES6 Map(2)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const temp = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(arr.filter(item =&gt; &#123;</span><br><span class=\"line\">        return !temp.has(item) &amp;&amp; temp.set(item, 1);</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法十三：ES6 Set(1)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    console.log(Array.from(new Set(arr)))</span><br><span class=\"line\">    return Array.from(new Set(arr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法十四：ES6 Set(2)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const unique = (arr) =&gt; [...new Set(arr)]</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>方法一：双重循环+新建数组(1)</p>\n<p>思路：新建一个数组存放返回的去重后的数组，设置一个标志来标识原数组和新数组中的元素是否重复，外层循环控制趟数，内层循环控制新数组和原数组元素的比较，如果新数组和原数组的元素相同，标志位置true，并跳出当前循环，如果新数组和原数组元素不同，执行完当前循环后，将外层循环变量指向的元素push进新数组</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    let isRepeat;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        isRepeat = false;</span><br><span class=\"line\">        for(let j = 0, resLen = res.length; j &lt; resLen; j++) &#123;</span><br><span class=\"line\">            if(arr[i] === res[j]) &#123;</span><br><span class=\"line\">                isRepeat = true;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(!isRepeat) &#123;</span><br><span class=\"line\">            res.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法二：双重循环+新建数组(2)</p>\n<p>思路：新建一个数组存放返回的去重后的数组，设置一个标志来标识原数组和新数组中的元素是否重复，外层控制趟数，内层比较，如果外层循环指向的元素和内层循环指向的元素相同，将标志位置true，并且跳出当前循环，但是不往新数组push外层循环变量指向的元素，继续下一趟循环，直到外层循环指向的变量和内层循环循环完之后都没有遇到相同元素，则把外层循环变量指向的元素push进新数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    const len = arr.length;</span><br><span class=\"line\">    let isRepeat;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">        isRepeat = false;</span><br><span class=\"line\">        for(let j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">            if(arr[i] === arr[j]) &#123;</span><br><span class=\"line\">                isRepeat = true;</span><br><span class=\"line\">                break;</span><br><span class=\"line\">            &#125;     </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        if(!isRepeat) &#123;</span><br><span class=\"line\">            res.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法三：双重循环+新建数组(3)</p>\n<p>思路：新建一个数组存放返回的去重后的数组，外层循环<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    const len = arr.length;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0; i &lt; len; i++) &#123;</span><br><span class=\"line\">        for(let j = i + 1; j &lt; len; j++) &#123;</span><br><span class=\"line\">            if(arr[i] === arr[j]) &#123;</span><br><span class=\"line\">                j = ++i;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        res.push(arr[i]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法四：新建数组+indexOf()</p>\n<p>思路：forEach遍历数组元素，利用indexOf()返回数组元素的索引来判断新数组中是否有当前遍历的元素的索引，如果没有的话，直接将当前元素push进新数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    </span><br><span class=\"line\">    arr.forEach(item =&gt; &#123;</span><br><span class=\"line\">        if(res.indexOf(item) === -1) &#123;</span><br><span class=\"line\">            res.push(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法五：新建数组+filter+indexOf()</p>\n<p>思路：利用filter过滤功能简化外层循环，利用indexOf返回数组中元素第一次出现的位置，如果和filter过滤的索引相同的话就把当前元素push进新数组，如果不同就被过滤掉<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    var res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    arr.filter((item, index) =&gt; &#123;</span><br><span class=\"line\">        if(arr.indexOf(item) === index) &#123;</span><br><span class=\"line\">            res.push(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法六：新建数组+排序+单层循环</p>\n<p>思路：对要去重的数组先进行排序，然后新建数组用来存放去重后的数组，在原数数组中遍历和新数组每一次的最后一个元素去比较，如果当前遍历的元素和新数组的最后一个元素不同，把当前遍历的元素push进新数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    arr.sort();</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        if(arr[i] !== res[res.length - 1]) &#123;</span><br><span class=\"line\">            res.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法七：新建数组+排序+单层循环</p>\n<p>思路：对要去重的数组先进行排序，然后新建数组用来存放去重后的数组，循环遍历原数组，如果第i项和第i+1项元素不同的话，将第i项push进新数组，如果相同的话进行下一次循环<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    arr.sort();</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        if(arr[i] !== arr[i+1]) &#123;</span><br><span class=\"line\">            res.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法八：新建数组+单层循环+includes()</p>\n<p>思路：新建数组用来存放去重后的数组，forEach遍历数组，如果新数组中不包含当前遍历的元素，就把当前遍历的元素push进新数组</p>\n<p>注：includes用来判断一个数组中是否包含一个指定项，返回值为布尔值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\"></span><br><span class=\"line\">    arr.forEach(item =&gt; &#123;</span><br><span class=\"line\">        if(!res.includes(item)) &#123;</span><br><span class=\"line\">            res.push(item);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法九：排序+reduce()</p>\n<p>思路：reduce() 方法对数组中的每个元素（从左到右）执行回调，将其减少为单个值。回调函数的两个参数，init作为回调的第一个调用的第一个参数的值，currentValue为数组中正在处理的当前元素<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(arr.sort().reduce((init, currentValue) =&gt; &#123;</span><br><span class=\"line\">        if(init.length === 0 || init[init.length - 1] !== currentValue) &#123;</span><br><span class=\"line\">            init.push(currentValue);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        return init;</span><br><span class=\"line\">    &#125;, [])); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法十：Object键值对</p>\n<p>思路：利用对象的key不可以重复。但是这里要注意三个问题：</p>\n<p>1.无法区分隐式转换成字符串后一样的值，比如1和‘1’</p>\n<p>2.无法处理复杂数据类型，比如对象（因为对象作为key会变为[object objec]）</p>\n<p>3.特殊数据，比如‘proto’，因为对象的proto属性无法被重写</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    const obj = &#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        // 使用JSON.stringify()进行序列化</span><br><span class=\"line\">        if(!obj[typeof arr[i] + JSON.stringify(arr[i])]) &#123;</span><br><span class=\"line\">            // 将对象序列化之后作为key来使用</span><br><span class=\"line\">            obj[typeof arr[i] + JSON.stringify(arr[i])] = true;</span><br><span class=\"line\">            res.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>方法十一：ES6 Map(1)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const res = [];</span><br><span class=\"line\">    const temp = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">    for(let i = 0, len = arr.length; i &lt; len; i++) &#123;</span><br><span class=\"line\">        if(!temp.get(arr[i])) &#123;</span><br><span class=\"line\">            temp.set(arr[i], 1);</span><br><span class=\"line\">            res.push(arr[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(res);</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法十二：ES6 Map(2)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    const temp = new Map();</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(arr.filter(item =&gt; &#123;</span><br><span class=\"line\">        return !temp.has(item) &amp;&amp; temp.set(item, 1);</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法十三：ES6 Set(1)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function unique(arr) &#123;</span><br><span class=\"line\">    console.log(Array.from(new Set(arr)))</span><br><span class=\"line\">    return Array.from(new Set(arr));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>方法十四：ES6 Set(2)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const unique = (arr) =&gt; [...new Set(arr)]</span><br></pre></td></tr></table></figure>"},{"title":"fis3前端工程化工具整理","date":"2018-05-28T13:12:46.000Z","about":null,"_content":"\n### fis3的工作原理：\n> fis3是真正地从前端工程化的角度出发，不单单是个打包工具，它基于文件对象进行构建，每个进入fis3的文件都会被实例化为一个file对象，整个构建流程都对这个对象进行操作完成构建任务。fis3没有入口文件的概念，是根据内置打包阶段生成的资源表定义之后的产出规则。\n\n### fis3的构建流程：\n> fis3将构建流程分为了单文件编译和打包两个阶段。单文件编译又分为了lint、parser、preprocessor、standard、postprocessor、optimizer六个阶段。打包分为prepackager、packager、spriter、postpackager四个阶段。\n<!--more-->\n\n```\nfis.release = function (opt) {\n  var src = fis.util.find(fis.project.root);\n  var files = {};\n  src.forEach(function (f) {\n    var file = new File(f);\n    files[file.subpath] = fis.compile(file);\n  });\n  var packager = fis.matchRules('::package');\n  var keys = Object.keys(packager);\n  var ret = {\n    files: files,\n    map: {}\n  };\n  if (packager.indexOf('prepackager') > -1) {\n    pipe('prepackager', ret);\n  }\n\n  if (packager.indexOf('packager') > -1) {\n    pipe('packager', ret);\n  }\n\n  files.forEach(function (f) {\n    // 打包阶段产出的 map 表替换到文件\n    if (f._isResourceMap) {\n      f._content = f._content.replace(/\\b__RESOURCE_MAP__\\b/g, JSON.stringify(ret.map));\n    }\n  });\n\n  if (packager.indexOf('spriter') > -1) {\n    pipe('spriter', ret);\n  }\n  if (packager.indexOf('postpackager') > -1) {\n    pipe('postpackager', ret);\n  }\n}\n```\n\n> 1. 扫描项目目录拿到文件并初始化出一个文件对象列表\n> 2. 对文件对象中每一个文件进行单文件编译\n> 3. 获取用户设置的package插件，进行打包处理（包括合并图片）\n\n![](https://note.youdao.com/yws/public/resource/977ae713311b47c735d17d0a22726d2a/xmlnote/WEBRESOURCEfbb003f65a629ea378998ad3e27b9108/4523)\n\n单文件编译处理了六个插件扩展点，通过用户配置启用某些插件：\n> 1. lint 代码校验检查，比较特殊，需要release命令命令行添加-l参数\n> 2. parser 预处理阶段，比如less、sass、es6、react前端模板等都在此处预编译处理\n> 3. preprocessor 标准化前处理插件\n> 4. standard 标准化插件，处理内直插件\n> 5. postprocessor 标准化后处理插件\n> 6. optimizer 代码优化\n\n\n打包处理了四个扩展点，通过用户配置启用某些插件：\n> 1. prepackager 打包前处理插件扩展点\n> 2. packager 打包插件扩展点，通过此插件收集文件依赖信息、合并信息产出静态资源映射表\n> 3. spriter 图片合并扩展点，如csssprites\n> 4. postpackager 打包后处理插件扩展点\n\n### fis3的配置文件\n> 通过glob语法match到某些文件，然后对这些文件定义各自的各个阶段的插件处理、发布规则，还能通过media定义不同环境的发布规则。感觉fis3的配置更优雅，可操作性更强。文件在什么阶段使用什么插件在这个阶段发生什么事情都可以很清楚地看到。\n\n```\n/**\n * 【模块划分】\n * 一、特殊文件处理\n * 二、预处理es6+css/less+vue\n * 三、模块化处理\n * 四、优化optimizer\n * 五、media多环境\n */\n\nfis.require('smarty')(fis);\nvar namespace = 'cloan';\nfis.set('namespace', namespace);\nfis.set('templates', '/template/' + namespace);\nfis.set('statics', '/static/' + namespace);\n\n/**\n * 一、特殊文件处理\n */\n\nvar ignoreList = [\n    '*.{md, sh, idea, DS_Store}',\n    'BCLOUD',\n    'BCLOUD.qa',\n    'fis-conf.js',\n    'component.json',\n    '**/example/*',\n    '.git/**'\n].join(',');\n// 1. 忽略release文件\nfis.match('{' + ignoreList + '}', {\n    release: false\n})\n// 2. test文件放到根目录\n    .match('/app/test/(**)', {\n        release: '/test/${namespace}/app/$1'\n    })\n    .match('/test/(**)', {\n        release: '/test/${namespace}/$1'\n    })\n    // 3. /app/static/config/api.js文件里面${appName}替换\n    .match('**/api**.js', {\n        postprocessor: function (content, file, settings) {\n            return content.replace(/\\$\\{appName\\}/g, namespace);\n        }\n    })\n    // 4. 指定tpl为page(与默认不一样)\n    .match('**.tpl', {\n        release: '${templates}/$0',\n        url: '${namespace}/$0',\n        extras: {\n            isPage: true\n        }\n    });\n\n/**\n * 二、预处理es6+css/less+vue\n */\nvar vueList = [\n    'app/component/**.vue',\n    'components/**.vue',\n    'loan-components/**vue'\n].join(',');\n\n// todo: 可以优化为所有的js?\nvar es6List = [\n    '**.vue:js',\n    'app/**.tpl:js',\n    'app/page/**.js',\n    'app/component/**.js',\n    'app/static/config/**.js',\n    'static/js/util/**.js',\n    'components/**.js',\n    'loan-components/**.js',\n    'widget/biz/error-reporter/index.js'\n].join(',');\n\nvar lessList = [\n    '*.less',\n    'components/**.vue:less',\n    'app/component/**.vue:less',\n    'loan-components/**.vue:less',\n    'page/activity/**.css'\n].join(',');\n\n// 1. vue处理\nfis.match('{' + vueList + '}', {\n    isMod: true, // todo:待确定\n    rExt: 'js',\n    useSameNameRequire: true, // todo: 待确定\n    parser: fis.plugin('vue-component', {\n        cssScopeFlag: 'vue-c'\n    })\n})\n// 2. es6 处理\n    .match('{' + es6List + '}', {\n        parser: [\n            fis.plugin('babel-6.x', {\n                plugins: [\n                    'add-module-exports',\n                    'transform-object-assign',\n                    'async-to-promises',\n                    'array-includes'\n                ]\n            })\n        ],\n        rExt: 'js'\n    })\n    // 3. css/less 处理\n    .match('{' + lessList + '}', {\n        parser: [\n            fis.plugin('less-2.x'),\n            fis.plugin('rem', {\n                rem: 37.5,\n                dpr: 1,\n                fontSize2Rem: true\n            })\n        ],\n        rExt: '.css'\n    })\n    // 加前缀。todo: 是否可以去掉less\n    .match('*.{css,less}', {\n        preprocessor: fis.plugin('cssprefixer', {\n            browsers: ['Chrome > 1'],\n            cascade: true\n        }),\n        useSprite: true\n    })\n    .match('*.{png, jpg, svg, gif}', {\n        useHash: true,\n        useSprite: true,\n        optimizer: null\n    });\n\n/**\n * 三、模块化处理\n */\n// 1. path短路径\nfis.hook('commonjs', {\n    // 要加vue\n    extList: [\n        '.js', '.vue'\n    ],\n    paths: {\n        api: '/app/static/config/api.js',\n        constant: '/app/static/config/constant.js',\n        notifyNativeError: '/app/static/config/notify-native-error/index.js',\n        formConfig: '/app/static/config/form/index.js',\n        component: '/app/component'\n    }\n})\n// 2. node_modules\n    .hook('node_modules');\n\n// 3. js模块化处理\nvar modList = [\n    '/node_modules/**.js', // 因为某些js没有模块化\n    '/app/static/config/**.js',\n    '/app/static/js/**.js',\n    '/app/page/**.js',\n    '/app/component/**.js',\n    '/components/**.js',\n    '/loan-components/**.js'\n].join(',');\n\nfis.match('{' + modList + '}', {\n    isMod: true,\n    useHash: true\n})\n    .match(/^\\/page\\/activity\\/activity-static\\/track\\/.*\\.(js)/i, {\n        isMod: false\n    })\n    .match('/components/fin-fg/error-reporter/index.js', {\n        isMod: false\n    });\n\n/**\n * 四、优化optimizer\n */\n// 1. 压缩：\n// 【默认没有压缩】\n// - 组件vue转换成的js\n// - png\n// 【默认有压缩】\n// - tpl\n// - css\nfis.match('*.{js, vue}', {\n    optimizer: fis.plugin('uglify-js', {\n        output: {\n            // smarty 超过200字符会截断\n            /* eslint-disable */\n            max_line_len: 200\n            /* eslint-enable */\n        }\n    })\n})\n    .match('*.png', {\n        optimizer: fis.plugin('png-compressor', {})\n    });\n\n/**\n * 五、media多环境\n */\n\n// 本地环境\n// 开发模式\nfis.media('debug')\n    .match('*.{js, vue, less, css, png, jpg, svg}', {\n        useHash: false,\n        useSprite: false,\n        optimizer: null\n    });\n// 模拟线上\nfis.media('devonline')\n    .match('::packager', {\n        packager: fis.plugin('deps-pack', pkgMap)\n    });\n// 2. 联调环境\n\n/**\n * 不能同步到rd机器检查点\n *\n * 1. less 或者 css相关文件没有文件注释，或者只有根选择器没有内容\n * 2. receiver.php没有部署或者删除\n *\n */\n\n// 联调推到rd机器\nvar rdInfo = [\n    {\n        name: 'rd',\n        path: '/home/work/odp-cloan',\n        receiver: 'http://gzns-nbg-fpu-aug-c02xi2-87.gzns.baidu.com:8080/umoneyweb/receiver.php'\n    },\n    {\n        name: 'rd3',\n        path: '/home/work/odp-cloan3',\n        receiver: 'http://gzns-nbg-fpu-aug-c02xi2-87.gzns.baidu.com:8080/umoneyweb/receiver.php'\n    },\n    {\n        name: 'dev',\n        path: '/home/work/odp',\n        receiver: 'http://gzns-um-c63.epc.baidu.com:9999/receiver.php'\n    }\n];\n// 3. 测试环境+线上环境\nonlineEnv('qa');\nonlineEnv('prod');\n\nfunction onlineEnv(mediaName) {\n    fis.media(mediaName)\n        .match('**/icon/**', {\n            release: '/static/${namespace}/pkg/font/$1'\n        })\n        .match('*.{png, jpg, gif, svg}', {\n            release: '/static/${namespace}/pkg/image/$0'\n        })\n        .match('{components/**.js, app/page/layout.tpl:js, loan-components/**.js}', {\n            parser: [\n                fis.plugin('jdists', {\n                    remove: 'debug,test,dev'\n                }),\n                fis.plugin('babel-6.x', {\n                    plugins: [\n                        'add-module-exports',\n                        'transform-object-assign',\n                        'async-to-promises',\n                        'array-includes'\n                    ]\n                })\n            ]\n        })\n        .match('::packager', {\n            packager: fis.plugin('deps-pack', pkgMap)\n        })\n        .match('**', {\n            deploy: [\n                fis.plugin('skip-packed'),\n                fis.plugin('local-deliver', {\n                    to: fis.get('options.dest') || fis.get('options.d') || './output'\n                })\n            ]\n        });\n\n    if (mediaName === 'prod') {\n        fis.media(mediaName)\n            .match('!*.tpl', {\n                domain: ['https://umoney.bdstatic.com/webroot']\n            });\n    }\n}\n```\n### fis3的输出\n> fis3的打包阶段只搜集所有文件列表以及各种依赖关系，根据打包阶段生成的资源表自定义产出规则。\n\n### fis3可以提供假mock数据\nfis3提供mock假数据模拟协助前端开发，需要放到服务器的/mock/sample.json目录下，确保通过http://127.0.0.1:8080/mock/sample.json可以访问到\n\n```\n{\n \"error\": 0,\n \"message\": \"ok\",\n \"data\": {\n   \"uname\": \"foo\",\n   \"uid\": 1\n }\n}\n```\n准备一个server.conf配置文件放在服务器的/mock/server.conf目录，内容如下：\n\n```\nrewrite ^\\/api\\/user$ /mock/sample.json\n```\n","source":"_posts/fis3前端工程化工具整理.md","raw":"---\ntitle: fis3前端工程化工具整理\ndate: 2018-05-28 21:12:46\ntags: \n- fis3\ncategories: 前端构建工具\nabout:\n---\n\n### fis3的工作原理：\n> fis3是真正地从前端工程化的角度出发，不单单是个打包工具，它基于文件对象进行构建，每个进入fis3的文件都会被实例化为一个file对象，整个构建流程都对这个对象进行操作完成构建任务。fis3没有入口文件的概念，是根据内置打包阶段生成的资源表定义之后的产出规则。\n\n### fis3的构建流程：\n> fis3将构建流程分为了单文件编译和打包两个阶段。单文件编译又分为了lint、parser、preprocessor、standard、postprocessor、optimizer六个阶段。打包分为prepackager、packager、spriter、postpackager四个阶段。\n<!--more-->\n\n```\nfis.release = function (opt) {\n  var src = fis.util.find(fis.project.root);\n  var files = {};\n  src.forEach(function (f) {\n    var file = new File(f);\n    files[file.subpath] = fis.compile(file);\n  });\n  var packager = fis.matchRules('::package');\n  var keys = Object.keys(packager);\n  var ret = {\n    files: files,\n    map: {}\n  };\n  if (packager.indexOf('prepackager') > -1) {\n    pipe('prepackager', ret);\n  }\n\n  if (packager.indexOf('packager') > -1) {\n    pipe('packager', ret);\n  }\n\n  files.forEach(function (f) {\n    // 打包阶段产出的 map 表替换到文件\n    if (f._isResourceMap) {\n      f._content = f._content.replace(/\\b__RESOURCE_MAP__\\b/g, JSON.stringify(ret.map));\n    }\n  });\n\n  if (packager.indexOf('spriter') > -1) {\n    pipe('spriter', ret);\n  }\n  if (packager.indexOf('postpackager') > -1) {\n    pipe('postpackager', ret);\n  }\n}\n```\n\n> 1. 扫描项目目录拿到文件并初始化出一个文件对象列表\n> 2. 对文件对象中每一个文件进行单文件编译\n> 3. 获取用户设置的package插件，进行打包处理（包括合并图片）\n\n![](https://note.youdao.com/yws/public/resource/977ae713311b47c735d17d0a22726d2a/xmlnote/WEBRESOURCEfbb003f65a629ea378998ad3e27b9108/4523)\n\n单文件编译处理了六个插件扩展点，通过用户配置启用某些插件：\n> 1. lint 代码校验检查，比较特殊，需要release命令命令行添加-l参数\n> 2. parser 预处理阶段，比如less、sass、es6、react前端模板等都在此处预编译处理\n> 3. preprocessor 标准化前处理插件\n> 4. standard 标准化插件，处理内直插件\n> 5. postprocessor 标准化后处理插件\n> 6. optimizer 代码优化\n\n\n打包处理了四个扩展点，通过用户配置启用某些插件：\n> 1. prepackager 打包前处理插件扩展点\n> 2. packager 打包插件扩展点，通过此插件收集文件依赖信息、合并信息产出静态资源映射表\n> 3. spriter 图片合并扩展点，如csssprites\n> 4. postpackager 打包后处理插件扩展点\n\n### fis3的配置文件\n> 通过glob语法match到某些文件，然后对这些文件定义各自的各个阶段的插件处理、发布规则，还能通过media定义不同环境的发布规则。感觉fis3的配置更优雅，可操作性更强。文件在什么阶段使用什么插件在这个阶段发生什么事情都可以很清楚地看到。\n\n```\n/**\n * 【模块划分】\n * 一、特殊文件处理\n * 二、预处理es6+css/less+vue\n * 三、模块化处理\n * 四、优化optimizer\n * 五、media多环境\n */\n\nfis.require('smarty')(fis);\nvar namespace = 'cloan';\nfis.set('namespace', namespace);\nfis.set('templates', '/template/' + namespace);\nfis.set('statics', '/static/' + namespace);\n\n/**\n * 一、特殊文件处理\n */\n\nvar ignoreList = [\n    '*.{md, sh, idea, DS_Store}',\n    'BCLOUD',\n    'BCLOUD.qa',\n    'fis-conf.js',\n    'component.json',\n    '**/example/*',\n    '.git/**'\n].join(',');\n// 1. 忽略release文件\nfis.match('{' + ignoreList + '}', {\n    release: false\n})\n// 2. test文件放到根目录\n    .match('/app/test/(**)', {\n        release: '/test/${namespace}/app/$1'\n    })\n    .match('/test/(**)', {\n        release: '/test/${namespace}/$1'\n    })\n    // 3. /app/static/config/api.js文件里面${appName}替换\n    .match('**/api**.js', {\n        postprocessor: function (content, file, settings) {\n            return content.replace(/\\$\\{appName\\}/g, namespace);\n        }\n    })\n    // 4. 指定tpl为page(与默认不一样)\n    .match('**.tpl', {\n        release: '${templates}/$0',\n        url: '${namespace}/$0',\n        extras: {\n            isPage: true\n        }\n    });\n\n/**\n * 二、预处理es6+css/less+vue\n */\nvar vueList = [\n    'app/component/**.vue',\n    'components/**.vue',\n    'loan-components/**vue'\n].join(',');\n\n// todo: 可以优化为所有的js?\nvar es6List = [\n    '**.vue:js',\n    'app/**.tpl:js',\n    'app/page/**.js',\n    'app/component/**.js',\n    'app/static/config/**.js',\n    'static/js/util/**.js',\n    'components/**.js',\n    'loan-components/**.js',\n    'widget/biz/error-reporter/index.js'\n].join(',');\n\nvar lessList = [\n    '*.less',\n    'components/**.vue:less',\n    'app/component/**.vue:less',\n    'loan-components/**.vue:less',\n    'page/activity/**.css'\n].join(',');\n\n// 1. vue处理\nfis.match('{' + vueList + '}', {\n    isMod: true, // todo:待确定\n    rExt: 'js',\n    useSameNameRequire: true, // todo: 待确定\n    parser: fis.plugin('vue-component', {\n        cssScopeFlag: 'vue-c'\n    })\n})\n// 2. es6 处理\n    .match('{' + es6List + '}', {\n        parser: [\n            fis.plugin('babel-6.x', {\n                plugins: [\n                    'add-module-exports',\n                    'transform-object-assign',\n                    'async-to-promises',\n                    'array-includes'\n                ]\n            })\n        ],\n        rExt: 'js'\n    })\n    // 3. css/less 处理\n    .match('{' + lessList + '}', {\n        parser: [\n            fis.plugin('less-2.x'),\n            fis.plugin('rem', {\n                rem: 37.5,\n                dpr: 1,\n                fontSize2Rem: true\n            })\n        ],\n        rExt: '.css'\n    })\n    // 加前缀。todo: 是否可以去掉less\n    .match('*.{css,less}', {\n        preprocessor: fis.plugin('cssprefixer', {\n            browsers: ['Chrome > 1'],\n            cascade: true\n        }),\n        useSprite: true\n    })\n    .match('*.{png, jpg, svg, gif}', {\n        useHash: true,\n        useSprite: true,\n        optimizer: null\n    });\n\n/**\n * 三、模块化处理\n */\n// 1. path短路径\nfis.hook('commonjs', {\n    // 要加vue\n    extList: [\n        '.js', '.vue'\n    ],\n    paths: {\n        api: '/app/static/config/api.js',\n        constant: '/app/static/config/constant.js',\n        notifyNativeError: '/app/static/config/notify-native-error/index.js',\n        formConfig: '/app/static/config/form/index.js',\n        component: '/app/component'\n    }\n})\n// 2. node_modules\n    .hook('node_modules');\n\n// 3. js模块化处理\nvar modList = [\n    '/node_modules/**.js', // 因为某些js没有模块化\n    '/app/static/config/**.js',\n    '/app/static/js/**.js',\n    '/app/page/**.js',\n    '/app/component/**.js',\n    '/components/**.js',\n    '/loan-components/**.js'\n].join(',');\n\nfis.match('{' + modList + '}', {\n    isMod: true,\n    useHash: true\n})\n    .match(/^\\/page\\/activity\\/activity-static\\/track\\/.*\\.(js)/i, {\n        isMod: false\n    })\n    .match('/components/fin-fg/error-reporter/index.js', {\n        isMod: false\n    });\n\n/**\n * 四、优化optimizer\n */\n// 1. 压缩：\n// 【默认没有压缩】\n// - 组件vue转换成的js\n// - png\n// 【默认有压缩】\n// - tpl\n// - css\nfis.match('*.{js, vue}', {\n    optimizer: fis.plugin('uglify-js', {\n        output: {\n            // smarty 超过200字符会截断\n            /* eslint-disable */\n            max_line_len: 200\n            /* eslint-enable */\n        }\n    })\n})\n    .match('*.png', {\n        optimizer: fis.plugin('png-compressor', {})\n    });\n\n/**\n * 五、media多环境\n */\n\n// 本地环境\n// 开发模式\nfis.media('debug')\n    .match('*.{js, vue, less, css, png, jpg, svg}', {\n        useHash: false,\n        useSprite: false,\n        optimizer: null\n    });\n// 模拟线上\nfis.media('devonline')\n    .match('::packager', {\n        packager: fis.plugin('deps-pack', pkgMap)\n    });\n// 2. 联调环境\n\n/**\n * 不能同步到rd机器检查点\n *\n * 1. less 或者 css相关文件没有文件注释，或者只有根选择器没有内容\n * 2. receiver.php没有部署或者删除\n *\n */\n\n// 联调推到rd机器\nvar rdInfo = [\n    {\n        name: 'rd',\n        path: '/home/work/odp-cloan',\n        receiver: 'http://gzns-nbg-fpu-aug-c02xi2-87.gzns.baidu.com:8080/umoneyweb/receiver.php'\n    },\n    {\n        name: 'rd3',\n        path: '/home/work/odp-cloan3',\n        receiver: 'http://gzns-nbg-fpu-aug-c02xi2-87.gzns.baidu.com:8080/umoneyweb/receiver.php'\n    },\n    {\n        name: 'dev',\n        path: '/home/work/odp',\n        receiver: 'http://gzns-um-c63.epc.baidu.com:9999/receiver.php'\n    }\n];\n// 3. 测试环境+线上环境\nonlineEnv('qa');\nonlineEnv('prod');\n\nfunction onlineEnv(mediaName) {\n    fis.media(mediaName)\n        .match('**/icon/**', {\n            release: '/static/${namespace}/pkg/font/$1'\n        })\n        .match('*.{png, jpg, gif, svg}', {\n            release: '/static/${namespace}/pkg/image/$0'\n        })\n        .match('{components/**.js, app/page/layout.tpl:js, loan-components/**.js}', {\n            parser: [\n                fis.plugin('jdists', {\n                    remove: 'debug,test,dev'\n                }),\n                fis.plugin('babel-6.x', {\n                    plugins: [\n                        'add-module-exports',\n                        'transform-object-assign',\n                        'async-to-promises',\n                        'array-includes'\n                    ]\n                })\n            ]\n        })\n        .match('::packager', {\n            packager: fis.plugin('deps-pack', pkgMap)\n        })\n        .match('**', {\n            deploy: [\n                fis.plugin('skip-packed'),\n                fis.plugin('local-deliver', {\n                    to: fis.get('options.dest') || fis.get('options.d') || './output'\n                })\n            ]\n        });\n\n    if (mediaName === 'prod') {\n        fis.media(mediaName)\n            .match('!*.tpl', {\n                domain: ['https://umoney.bdstatic.com/webroot']\n            });\n    }\n}\n```\n### fis3的输出\n> fis3的打包阶段只搜集所有文件列表以及各种依赖关系，根据打包阶段生成的资源表自定义产出规则。\n\n### fis3可以提供假mock数据\nfis3提供mock假数据模拟协助前端开发，需要放到服务器的/mock/sample.json目录下，确保通过http://127.0.0.1:8080/mock/sample.json可以访问到\n\n```\n{\n \"error\": 0,\n \"message\": \"ok\",\n \"data\": {\n   \"uname\": \"foo\",\n   \"uid\": 1\n }\n}\n```\n准备一个server.conf配置文件放在服务器的/mock/server.conf目录，内容如下：\n\n```\nrewrite ^\\/api\\/user$ /mock/sample.json\n```\n","slug":"fis3前端工程化工具整理","published":1,"updated":"2019-02-22T08:37:33.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugrpb002kvriepzbn6zce","content":"<h3 id=\"fis3的工作原理：\"><a href=\"#fis3的工作原理：\" class=\"headerlink\" title=\"fis3的工作原理：\"></a>fis3的工作原理：</h3><blockquote>\n<p>fis3是真正地从前端工程化的角度出发，不单单是个打包工具，它基于文件对象进行构建，每个进入fis3的文件都会被实例化为一个file对象，整个构建流程都对这个对象进行操作完成构建任务。fis3没有入口文件的概念，是根据内置打包阶段生成的资源表定义之后的产出规则。</p>\n</blockquote>\n<h3 id=\"fis3的构建流程：\"><a href=\"#fis3的构建流程：\" class=\"headerlink\" title=\"fis3的构建流程：\"></a>fis3的构建流程：</h3><blockquote>\n<p>fis3将构建流程分为了单文件编译和打包两个阶段。单文件编译又分为了lint、parser、preprocessor、standard、postprocessor、optimizer六个阶段。打包分为prepackager、packager、spriter、postpackager四个阶段。<br><a id=\"more\"></a></p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fis.release = function (opt) &#123;</span><br><span class=\"line\">  var src = fis.util.find(fis.project.root);</span><br><span class=\"line\">  var files = &#123;&#125;;</span><br><span class=\"line\">  src.forEach(function (f) &#123;</span><br><span class=\"line\">    var file = new File(f);</span><br><span class=\"line\">    files[file.subpath] = fis.compile(file);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  var packager = fis.matchRules(&apos;::package&apos;);</span><br><span class=\"line\">  var keys = Object.keys(packager);</span><br><span class=\"line\">  var ret = &#123;</span><br><span class=\"line\">    files: files,</span><br><span class=\"line\">    map: &#123;&#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  if (packager.indexOf(&apos;prepackager&apos;) &gt; -1) &#123;</span><br><span class=\"line\">    pipe(&apos;prepackager&apos;, ret);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (packager.indexOf(&apos;packager&apos;) &gt; -1) &#123;</span><br><span class=\"line\">    pipe(&apos;packager&apos;, ret);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  files.forEach(function (f) &#123;</span><br><span class=\"line\">    // 打包阶段产出的 map 表替换到文件</span><br><span class=\"line\">    if (f._isResourceMap) &#123;</span><br><span class=\"line\">      f._content = f._content.replace(/\\b__RESOURCE_MAP__\\b/g, JSON.stringify(ret.map));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  if (packager.indexOf(&apos;spriter&apos;) &gt; -1) &#123;</span><br><span class=\"line\">    pipe(&apos;spriter&apos;, ret);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (packager.indexOf(&apos;postpackager&apos;) &gt; -1) &#123;</span><br><span class=\"line\">    pipe(&apos;postpackager&apos;, ret);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li>扫描项目目录拿到文件并初始化出一个文件对象列表</li>\n<li>对文件对象中每一个文件进行单文件编译</li>\n<li>获取用户设置的package插件，进行打包处理（包括合并图片）</li>\n</ol>\n</blockquote>\n<p><img src=\"https://note.youdao.com/yws/public/resource/977ae713311b47c735d17d0a22726d2a/xmlnote/WEBRESOURCEfbb003f65a629ea378998ad3e27b9108/4523\" alt></p>\n<p>单文件编译处理了六个插件扩展点，通过用户配置启用某些插件：</p>\n<blockquote>\n<ol>\n<li>lint 代码校验检查，比较特殊，需要release命令命令行添加-l参数</li>\n<li>parser 预处理阶段，比如less、sass、es6、react前端模板等都在此处预编译处理</li>\n<li>preprocessor 标准化前处理插件</li>\n<li>standard 标准化插件，处理内直插件</li>\n<li>postprocessor 标准化后处理插件</li>\n<li>optimizer 代码优化</li>\n</ol>\n</blockquote>\n<p>打包处理了四个扩展点，通过用户配置启用某些插件：</p>\n<blockquote>\n<ol>\n<li>prepackager 打包前处理插件扩展点</li>\n<li>packager 打包插件扩展点，通过此插件收集文件依赖信息、合并信息产出静态资源映射表</li>\n<li>spriter 图片合并扩展点，如csssprites</li>\n<li>postpackager 打包后处理插件扩展点</li>\n</ol>\n</blockquote>\n<h3 id=\"fis3的配置文件\"><a href=\"#fis3的配置文件\" class=\"headerlink\" title=\"fis3的配置文件\"></a>fis3的配置文件</h3><blockquote>\n<p>通过glob语法match到某些文件，然后对这些文件定义各自的各个阶段的插件处理、发布规则，还能通过media定义不同环境的发布规则。感觉fis3的配置更优雅，可操作性更强。文件在什么阶段使用什么插件在这个阶段发生什么事情都可以很清楚地看到。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 【模块划分】</span><br><span class=\"line\"> * 一、特殊文件处理</span><br><span class=\"line\"> * 二、预处理es6+css/less+vue</span><br><span class=\"line\"> * 三、模块化处理</span><br><span class=\"line\"> * 四、优化optimizer</span><br><span class=\"line\"> * 五、media多环境</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">fis.require(&apos;smarty&apos;)(fis);</span><br><span class=\"line\">var namespace = &apos;cloan&apos;;</span><br><span class=\"line\">fis.set(&apos;namespace&apos;, namespace);</span><br><span class=\"line\">fis.set(&apos;templates&apos;, &apos;/template/&apos; + namespace);</span><br><span class=\"line\">fis.set(&apos;statics&apos;, &apos;/static/&apos; + namespace);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 一、特殊文件处理</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">var ignoreList = [</span><br><span class=\"line\">    &apos;*.&#123;md, sh, idea, DS_Store&#125;&apos;,</span><br><span class=\"line\">    &apos;BCLOUD&apos;,</span><br><span class=\"line\">    &apos;BCLOUD.qa&apos;,</span><br><span class=\"line\">    &apos;fis-conf.js&apos;,</span><br><span class=\"line\">    &apos;component.json&apos;,</span><br><span class=\"line\">    &apos;**/example/*&apos;,</span><br><span class=\"line\">    &apos;.git/**&apos;</span><br><span class=\"line\">].join(&apos;,&apos;);</span><br><span class=\"line\">// 1. 忽略release文件</span><br><span class=\"line\">fis.match(&apos;&#123;&apos; + ignoreList + &apos;&#125;&apos;, &#123;</span><br><span class=\"line\">    release: false</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 2. test文件放到根目录</span><br><span class=\"line\">    .match(&apos;/app/test/(**)&apos;, &#123;</span><br><span class=\"line\">        release: &apos;/test/$&#123;namespace&#125;/app/$1&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .match(&apos;/test/(**)&apos;, &#123;</span><br><span class=\"line\">        release: &apos;/test/$&#123;namespace&#125;/$1&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    // 3. /app/static/config/api.js文件里面$&#123;appName&#125;替换</span><br><span class=\"line\">    .match(&apos;**/api**.js&apos;, &#123;</span><br><span class=\"line\">        postprocessor: function (content, file, settings) &#123;</span><br><span class=\"line\">            return content.replace(/\\$\\&#123;appName\\&#125;/g, namespace);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    // 4. 指定tpl为page(与默认不一样)</span><br><span class=\"line\">    .match(&apos;**.tpl&apos;, &#123;</span><br><span class=\"line\">        release: &apos;$&#123;templates&#125;/$0&apos;,</span><br><span class=\"line\">        url: &apos;$&#123;namespace&#125;/$0&apos;,</span><br><span class=\"line\">        extras: &#123;</span><br><span class=\"line\">            isPage: true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 二、预处理es6+css/less+vue</span><br><span class=\"line\"> */</span><br><span class=\"line\">var vueList = [</span><br><span class=\"line\">    &apos;app/component/**.vue&apos;,</span><br><span class=\"line\">    &apos;components/**.vue&apos;,</span><br><span class=\"line\">    &apos;loan-components/**vue&apos;</span><br><span class=\"line\">].join(&apos;,&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// todo: 可以优化为所有的js?</span><br><span class=\"line\">var es6List = [</span><br><span class=\"line\">    &apos;**.vue:js&apos;,</span><br><span class=\"line\">    &apos;app/**.tpl:js&apos;,</span><br><span class=\"line\">    &apos;app/page/**.js&apos;,</span><br><span class=\"line\">    &apos;app/component/**.js&apos;,</span><br><span class=\"line\">    &apos;app/static/config/**.js&apos;,</span><br><span class=\"line\">    &apos;static/js/util/**.js&apos;,</span><br><span class=\"line\">    &apos;components/**.js&apos;,</span><br><span class=\"line\">    &apos;loan-components/**.js&apos;,</span><br><span class=\"line\">    &apos;widget/biz/error-reporter/index.js&apos;</span><br><span class=\"line\">].join(&apos;,&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var lessList = [</span><br><span class=\"line\">    &apos;*.less&apos;,</span><br><span class=\"line\">    &apos;components/**.vue:less&apos;,</span><br><span class=\"line\">    &apos;app/component/**.vue:less&apos;,</span><br><span class=\"line\">    &apos;loan-components/**.vue:less&apos;,</span><br><span class=\"line\">    &apos;page/activity/**.css&apos;</span><br><span class=\"line\">].join(&apos;,&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 1. vue处理</span><br><span class=\"line\">fis.match(&apos;&#123;&apos; + vueList + &apos;&#125;&apos;, &#123;</span><br><span class=\"line\">    isMod: true, // todo:待确定</span><br><span class=\"line\">    rExt: &apos;js&apos;,</span><br><span class=\"line\">    useSameNameRequire: true, // todo: 待确定</span><br><span class=\"line\">    parser: fis.plugin(&apos;vue-component&apos;, &#123;</span><br><span class=\"line\">        cssScopeFlag: &apos;vue-c&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 2. es6 处理</span><br><span class=\"line\">    .match(&apos;&#123;&apos; + es6List + &apos;&#125;&apos;, &#123;</span><br><span class=\"line\">        parser: [</span><br><span class=\"line\">            fis.plugin(&apos;babel-6.x&apos;, &#123;</span><br><span class=\"line\">                plugins: [</span><br><span class=\"line\">                    &apos;add-module-exports&apos;,</span><br><span class=\"line\">                    &apos;transform-object-assign&apos;,</span><br><span class=\"line\">                    &apos;async-to-promises&apos;,</span><br><span class=\"line\">                    &apos;array-includes&apos;</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        rExt: &apos;js&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    // 3. css/less 处理</span><br><span class=\"line\">    .match(&apos;&#123;&apos; + lessList + &apos;&#125;&apos;, &#123;</span><br><span class=\"line\">        parser: [</span><br><span class=\"line\">            fis.plugin(&apos;less-2.x&apos;),</span><br><span class=\"line\">            fis.plugin(&apos;rem&apos;, &#123;</span><br><span class=\"line\">                rem: 37.5,</span><br><span class=\"line\">                dpr: 1,</span><br><span class=\"line\">                fontSize2Rem: true</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        rExt: &apos;.css&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    // 加前缀。todo: 是否可以去掉less</span><br><span class=\"line\">    .match(&apos;*.&#123;css,less&#125;&apos;, &#123;</span><br><span class=\"line\">        preprocessor: fis.plugin(&apos;cssprefixer&apos;, &#123;</span><br><span class=\"line\">            browsers: [&apos;Chrome &gt; 1&apos;],</span><br><span class=\"line\">            cascade: true</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        useSprite: true</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .match(&apos;*.&#123;png, jpg, svg, gif&#125;&apos;, &#123;</span><br><span class=\"line\">        useHash: true,</span><br><span class=\"line\">        useSprite: true,</span><br><span class=\"line\">        optimizer: null</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 三、模块化处理</span><br><span class=\"line\"> */</span><br><span class=\"line\">// 1. path短路径</span><br><span class=\"line\">fis.hook(&apos;commonjs&apos;, &#123;</span><br><span class=\"line\">    // 要加vue</span><br><span class=\"line\">    extList: [</span><br><span class=\"line\">        &apos;.js&apos;, &apos;.vue&apos;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    paths: &#123;</span><br><span class=\"line\">        api: &apos;/app/static/config/api.js&apos;,</span><br><span class=\"line\">        constant: &apos;/app/static/config/constant.js&apos;,</span><br><span class=\"line\">        notifyNativeError: &apos;/app/static/config/notify-native-error/index.js&apos;,</span><br><span class=\"line\">        formConfig: &apos;/app/static/config/form/index.js&apos;,</span><br><span class=\"line\">        component: &apos;/app/component&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 2. node_modules</span><br><span class=\"line\">    .hook(&apos;node_modules&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 3. js模块化处理</span><br><span class=\"line\">var modList = [</span><br><span class=\"line\">    &apos;/node_modules/**.js&apos;, // 因为某些js没有模块化</span><br><span class=\"line\">    &apos;/app/static/config/**.js&apos;,</span><br><span class=\"line\">    &apos;/app/static/js/**.js&apos;,</span><br><span class=\"line\">    &apos;/app/page/**.js&apos;,</span><br><span class=\"line\">    &apos;/app/component/**.js&apos;,</span><br><span class=\"line\">    &apos;/components/**.js&apos;,</span><br><span class=\"line\">    &apos;/loan-components/**.js&apos;</span><br><span class=\"line\">].join(&apos;,&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">fis.match(&apos;&#123;&apos; + modList + &apos;&#125;&apos;, &#123;</span><br><span class=\"line\">    isMod: true,</span><br><span class=\"line\">    useHash: true</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .match(/^\\/page\\/activity\\/activity-static\\/track\\/.*\\.(js)/i, &#123;</span><br><span class=\"line\">        isMod: false</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .match(&apos;/components/fin-fg/error-reporter/index.js&apos;, &#123;</span><br><span class=\"line\">        isMod: false</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 四、优化optimizer</span><br><span class=\"line\"> */</span><br><span class=\"line\">// 1. 压缩：</span><br><span class=\"line\">// 【默认没有压缩】</span><br><span class=\"line\">// - 组件vue转换成的js</span><br><span class=\"line\">// - png</span><br><span class=\"line\">// 【默认有压缩】</span><br><span class=\"line\">// - tpl</span><br><span class=\"line\">// - css</span><br><span class=\"line\">fis.match(&apos;*.&#123;js, vue&#125;&apos;, &#123;</span><br><span class=\"line\">    optimizer: fis.plugin(&apos;uglify-js&apos;, &#123;</span><br><span class=\"line\">        output: &#123;</span><br><span class=\"line\">            // smarty 超过200字符会截断</span><br><span class=\"line\">            /* eslint-disable */</span><br><span class=\"line\">            max_line_len: 200</span><br><span class=\"line\">            /* eslint-enable */</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .match(&apos;*.png&apos;, &#123;</span><br><span class=\"line\">        optimizer: fis.plugin(&apos;png-compressor&apos;, &#123;&#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 五、media多环境</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">// 本地环境</span><br><span class=\"line\">// 开发模式</span><br><span class=\"line\">fis.media(&apos;debug&apos;)</span><br><span class=\"line\">    .match(&apos;*.&#123;js, vue, less, css, png, jpg, svg&#125;&apos;, &#123;</span><br><span class=\"line\">        useHash: false,</span><br><span class=\"line\">        useSprite: false,</span><br><span class=\"line\">        optimizer: null</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">// 模拟线上</span><br><span class=\"line\">fis.media(&apos;devonline&apos;)</span><br><span class=\"line\">    .match(&apos;::packager&apos;, &#123;</span><br><span class=\"line\">        packager: fis.plugin(&apos;deps-pack&apos;, pkgMap)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">// 2. 联调环境</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 不能同步到rd机器检查点</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * 1. less 或者 css相关文件没有文件注释，或者只有根选择器没有内容</span><br><span class=\"line\"> * 2. receiver.php没有部署或者删除</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">// 联调推到rd机器</span><br><span class=\"line\">var rdInfo = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: &apos;rd&apos;,</span><br><span class=\"line\">        path: &apos;/home/work/odp-cloan&apos;,</span><br><span class=\"line\">        receiver: &apos;http://gzns-nbg-fpu-aug-c02xi2-87.gzns.baidu.com:8080/umoneyweb/receiver.php&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: &apos;rd3&apos;,</span><br><span class=\"line\">        path: &apos;/home/work/odp-cloan3&apos;,</span><br><span class=\"line\">        receiver: &apos;http://gzns-nbg-fpu-aug-c02xi2-87.gzns.baidu.com:8080/umoneyweb/receiver.php&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: &apos;dev&apos;,</span><br><span class=\"line\">        path: &apos;/home/work/odp&apos;,</span><br><span class=\"line\">        receiver: &apos;http://gzns-um-c63.epc.baidu.com:9999/receiver.php&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\">// 3. 测试环境+线上环境</span><br><span class=\"line\">onlineEnv(&apos;qa&apos;);</span><br><span class=\"line\">onlineEnv(&apos;prod&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function onlineEnv(mediaName) &#123;</span><br><span class=\"line\">    fis.media(mediaName)</span><br><span class=\"line\">        .match(&apos;**/icon/**&apos;, &#123;</span><br><span class=\"line\">            release: &apos;/static/$&#123;namespace&#125;/pkg/font/$1&apos;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .match(&apos;*.&#123;png, jpg, gif, svg&#125;&apos;, &#123;</span><br><span class=\"line\">            release: &apos;/static/$&#123;namespace&#125;/pkg/image/$0&apos;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .match(&apos;&#123;components/**.js, app/page/layout.tpl:js, loan-components/**.js&#125;&apos;, &#123;</span><br><span class=\"line\">            parser: [</span><br><span class=\"line\">                fis.plugin(&apos;jdists&apos;, &#123;</span><br><span class=\"line\">                    remove: &apos;debug,test,dev&apos;</span><br><span class=\"line\">                &#125;),</span><br><span class=\"line\">                fis.plugin(&apos;babel-6.x&apos;, &#123;</span><br><span class=\"line\">                    plugins: [</span><br><span class=\"line\">                        &apos;add-module-exports&apos;,</span><br><span class=\"line\">                        &apos;transform-object-assign&apos;,</span><br><span class=\"line\">                        &apos;async-to-promises&apos;,</span><br><span class=\"line\">                        &apos;array-includes&apos;</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .match(&apos;::packager&apos;, &#123;</span><br><span class=\"line\">            packager: fis.plugin(&apos;deps-pack&apos;, pkgMap)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .match(&apos;**&apos;, &#123;</span><br><span class=\"line\">            deploy: [</span><br><span class=\"line\">                fis.plugin(&apos;skip-packed&apos;),</span><br><span class=\"line\">                fis.plugin(&apos;local-deliver&apos;, &#123;</span><br><span class=\"line\">                    to: fis.get(&apos;options.dest&apos;) || fis.get(&apos;options.d&apos;) || &apos;./output&apos;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (mediaName === &apos;prod&apos;) &#123;</span><br><span class=\"line\">        fis.media(mediaName)</span><br><span class=\"line\">            .match(&apos;!*.tpl&apos;, &#123;</span><br><span class=\"line\">                domain: [&apos;https://umoney.bdstatic.com/webroot&apos;]</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"fis3的输出\"><a href=\"#fis3的输出\" class=\"headerlink\" title=\"fis3的输出\"></a>fis3的输出</h3><blockquote>\n<p>fis3的打包阶段只搜集所有文件列表以及各种依赖关系，根据打包阶段生成的资源表自定义产出规则。</p>\n</blockquote>\n<h3 id=\"fis3可以提供假mock数据\"><a href=\"#fis3可以提供假mock数据\" class=\"headerlink\" title=\"fis3可以提供假mock数据\"></a>fis3可以提供假mock数据</h3><p>fis3提供mock假数据模拟协助前端开发，需要放到服务器的/mock/sample.json目录下，确保通过<a href=\"http://127.0.0.1:8080/mock/sample.json可以访问到\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/mock/sample.json可以访问到</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;error&quot;: 0,</span><br><span class=\"line\"> &quot;message&quot;: &quot;ok&quot;,</span><br><span class=\"line\"> &quot;data&quot;: &#123;</span><br><span class=\"line\">   &quot;uname&quot;: &quot;foo&quot;,</span><br><span class=\"line\">   &quot;uid&quot;: 1</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>准备一个server.conf配置文件放在服务器的/mock/server.conf目录，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rewrite ^\\/api\\/user$ /mock/sample.json</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"fis3的工作原理：\"><a href=\"#fis3的工作原理：\" class=\"headerlink\" title=\"fis3的工作原理：\"></a>fis3的工作原理：</h3><blockquote>\n<p>fis3是真正地从前端工程化的角度出发，不单单是个打包工具，它基于文件对象进行构建，每个进入fis3的文件都会被实例化为一个file对象，整个构建流程都对这个对象进行操作完成构建任务。fis3没有入口文件的概念，是根据内置打包阶段生成的资源表定义之后的产出规则。</p>\n</blockquote>\n<h3 id=\"fis3的构建流程：\"><a href=\"#fis3的构建流程：\" class=\"headerlink\" title=\"fis3的构建流程：\"></a>fis3的构建流程：</h3><blockquote>\n<p>fis3将构建流程分为了单文件编译和打包两个阶段。单文件编译又分为了lint、parser、preprocessor、standard、postprocessor、optimizer六个阶段。打包分为prepackager、packager、spriter、postpackager四个阶段。<br>","more":"</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fis.release = function (opt) &#123;</span><br><span class=\"line\">  var src = fis.util.find(fis.project.root);</span><br><span class=\"line\">  var files = &#123;&#125;;</span><br><span class=\"line\">  src.forEach(function (f) &#123;</span><br><span class=\"line\">    var file = new File(f);</span><br><span class=\"line\">    files[file.subpath] = fis.compile(file);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  var packager = fis.matchRules(&apos;::package&apos;);</span><br><span class=\"line\">  var keys = Object.keys(packager);</span><br><span class=\"line\">  var ret = &#123;</span><br><span class=\"line\">    files: files,</span><br><span class=\"line\">    map: &#123;&#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  if (packager.indexOf(&apos;prepackager&apos;) &gt; -1) &#123;</span><br><span class=\"line\">    pipe(&apos;prepackager&apos;, ret);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (packager.indexOf(&apos;packager&apos;) &gt; -1) &#123;</span><br><span class=\"line\">    pipe(&apos;packager&apos;, ret);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  files.forEach(function (f) &#123;</span><br><span class=\"line\">    // 打包阶段产出的 map 表替换到文件</span><br><span class=\"line\">    if (f._isResourceMap) &#123;</span><br><span class=\"line\">      f._content = f._content.replace(/\\b__RESOURCE_MAP__\\b/g, JSON.stringify(ret.map));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  if (packager.indexOf(&apos;spriter&apos;) &gt; -1) &#123;</span><br><span class=\"line\">    pipe(&apos;spriter&apos;, ret);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  if (packager.indexOf(&apos;postpackager&apos;) &gt; -1) &#123;</span><br><span class=\"line\">    pipe(&apos;postpackager&apos;, ret);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<ol>\n<li>扫描项目目录拿到文件并初始化出一个文件对象列表</li>\n<li>对文件对象中每一个文件进行单文件编译</li>\n<li>获取用户设置的package插件，进行打包处理（包括合并图片）</li>\n</ol>\n</blockquote>\n<p><img src=\"https://note.youdao.com/yws/public/resource/977ae713311b47c735d17d0a22726d2a/xmlnote/WEBRESOURCEfbb003f65a629ea378998ad3e27b9108/4523\" alt></p>\n<p>单文件编译处理了六个插件扩展点，通过用户配置启用某些插件：</p>\n<blockquote>\n<ol>\n<li>lint 代码校验检查，比较特殊，需要release命令命令行添加-l参数</li>\n<li>parser 预处理阶段，比如less、sass、es6、react前端模板等都在此处预编译处理</li>\n<li>preprocessor 标准化前处理插件</li>\n<li>standard 标准化插件，处理内直插件</li>\n<li>postprocessor 标准化后处理插件</li>\n<li>optimizer 代码优化</li>\n</ol>\n</blockquote>\n<p>打包处理了四个扩展点，通过用户配置启用某些插件：</p>\n<blockquote>\n<ol>\n<li>prepackager 打包前处理插件扩展点</li>\n<li>packager 打包插件扩展点，通过此插件收集文件依赖信息、合并信息产出静态资源映射表</li>\n<li>spriter 图片合并扩展点，如csssprites</li>\n<li>postpackager 打包后处理插件扩展点</li>\n</ol>\n</blockquote>\n<h3 id=\"fis3的配置文件\"><a href=\"#fis3的配置文件\" class=\"headerlink\" title=\"fis3的配置文件\"></a>fis3的配置文件</h3><blockquote>\n<p>通过glob语法match到某些文件，然后对这些文件定义各自的各个阶段的插件处理、发布规则，还能通过media定义不同环境的发布规则。感觉fis3的配置更优雅，可操作性更强。文件在什么阶段使用什么插件在这个阶段发生什么事情都可以很清楚地看到。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 【模块划分】</span><br><span class=\"line\"> * 一、特殊文件处理</span><br><span class=\"line\"> * 二、预处理es6+css/less+vue</span><br><span class=\"line\"> * 三、模块化处理</span><br><span class=\"line\"> * 四、优化optimizer</span><br><span class=\"line\"> * 五、media多环境</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">fis.require(&apos;smarty&apos;)(fis);</span><br><span class=\"line\">var namespace = &apos;cloan&apos;;</span><br><span class=\"line\">fis.set(&apos;namespace&apos;, namespace);</span><br><span class=\"line\">fis.set(&apos;templates&apos;, &apos;/template/&apos; + namespace);</span><br><span class=\"line\">fis.set(&apos;statics&apos;, &apos;/static/&apos; + namespace);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 一、特殊文件处理</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">var ignoreList = [</span><br><span class=\"line\">    &apos;*.&#123;md, sh, idea, DS_Store&#125;&apos;,</span><br><span class=\"line\">    &apos;BCLOUD&apos;,</span><br><span class=\"line\">    &apos;BCLOUD.qa&apos;,</span><br><span class=\"line\">    &apos;fis-conf.js&apos;,</span><br><span class=\"line\">    &apos;component.json&apos;,</span><br><span class=\"line\">    &apos;**/example/*&apos;,</span><br><span class=\"line\">    &apos;.git/**&apos;</span><br><span class=\"line\">].join(&apos;,&apos;);</span><br><span class=\"line\">// 1. 忽略release文件</span><br><span class=\"line\">fis.match(&apos;&#123;&apos; + ignoreList + &apos;&#125;&apos;, &#123;</span><br><span class=\"line\">    release: false</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 2. test文件放到根目录</span><br><span class=\"line\">    .match(&apos;/app/test/(**)&apos;, &#123;</span><br><span class=\"line\">        release: &apos;/test/$&#123;namespace&#125;/app/$1&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .match(&apos;/test/(**)&apos;, &#123;</span><br><span class=\"line\">        release: &apos;/test/$&#123;namespace&#125;/$1&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    // 3. /app/static/config/api.js文件里面$&#123;appName&#125;替换</span><br><span class=\"line\">    .match(&apos;**/api**.js&apos;, &#123;</span><br><span class=\"line\">        postprocessor: function (content, file, settings) &#123;</span><br><span class=\"line\">            return content.replace(/\\$\\&#123;appName\\&#125;/g, namespace);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    // 4. 指定tpl为page(与默认不一样)</span><br><span class=\"line\">    .match(&apos;**.tpl&apos;, &#123;</span><br><span class=\"line\">        release: &apos;$&#123;templates&#125;/$0&apos;,</span><br><span class=\"line\">        url: &apos;$&#123;namespace&#125;/$0&apos;,</span><br><span class=\"line\">        extras: &#123;</span><br><span class=\"line\">            isPage: true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 二、预处理es6+css/less+vue</span><br><span class=\"line\"> */</span><br><span class=\"line\">var vueList = [</span><br><span class=\"line\">    &apos;app/component/**.vue&apos;,</span><br><span class=\"line\">    &apos;components/**.vue&apos;,</span><br><span class=\"line\">    &apos;loan-components/**vue&apos;</span><br><span class=\"line\">].join(&apos;,&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// todo: 可以优化为所有的js?</span><br><span class=\"line\">var es6List = [</span><br><span class=\"line\">    &apos;**.vue:js&apos;,</span><br><span class=\"line\">    &apos;app/**.tpl:js&apos;,</span><br><span class=\"line\">    &apos;app/page/**.js&apos;,</span><br><span class=\"line\">    &apos;app/component/**.js&apos;,</span><br><span class=\"line\">    &apos;app/static/config/**.js&apos;,</span><br><span class=\"line\">    &apos;static/js/util/**.js&apos;,</span><br><span class=\"line\">    &apos;components/**.js&apos;,</span><br><span class=\"line\">    &apos;loan-components/**.js&apos;,</span><br><span class=\"line\">    &apos;widget/biz/error-reporter/index.js&apos;</span><br><span class=\"line\">].join(&apos;,&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">var lessList = [</span><br><span class=\"line\">    &apos;*.less&apos;,</span><br><span class=\"line\">    &apos;components/**.vue:less&apos;,</span><br><span class=\"line\">    &apos;app/component/**.vue:less&apos;,</span><br><span class=\"line\">    &apos;loan-components/**.vue:less&apos;,</span><br><span class=\"line\">    &apos;page/activity/**.css&apos;</span><br><span class=\"line\">].join(&apos;,&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 1. vue处理</span><br><span class=\"line\">fis.match(&apos;&#123;&apos; + vueList + &apos;&#125;&apos;, &#123;</span><br><span class=\"line\">    isMod: true, // todo:待确定</span><br><span class=\"line\">    rExt: &apos;js&apos;,</span><br><span class=\"line\">    useSameNameRequire: true, // todo: 待确定</span><br><span class=\"line\">    parser: fis.plugin(&apos;vue-component&apos;, &#123;</span><br><span class=\"line\">        cssScopeFlag: &apos;vue-c&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 2. es6 处理</span><br><span class=\"line\">    .match(&apos;&#123;&apos; + es6List + &apos;&#125;&apos;, &#123;</span><br><span class=\"line\">        parser: [</span><br><span class=\"line\">            fis.plugin(&apos;babel-6.x&apos;, &#123;</span><br><span class=\"line\">                plugins: [</span><br><span class=\"line\">                    &apos;add-module-exports&apos;,</span><br><span class=\"line\">                    &apos;transform-object-assign&apos;,</span><br><span class=\"line\">                    &apos;async-to-promises&apos;,</span><br><span class=\"line\">                    &apos;array-includes&apos;</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        rExt: &apos;js&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    // 3. css/less 处理</span><br><span class=\"line\">    .match(&apos;&#123;&apos; + lessList + &apos;&#125;&apos;, &#123;</span><br><span class=\"line\">        parser: [</span><br><span class=\"line\">            fis.plugin(&apos;less-2.x&apos;),</span><br><span class=\"line\">            fis.plugin(&apos;rem&apos;, &#123;</span><br><span class=\"line\">                rem: 37.5,</span><br><span class=\"line\">                dpr: 1,</span><br><span class=\"line\">                fontSize2Rem: true</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        ],</span><br><span class=\"line\">        rExt: &apos;.css&apos;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    // 加前缀。todo: 是否可以去掉less</span><br><span class=\"line\">    .match(&apos;*.&#123;css,less&#125;&apos;, &#123;</span><br><span class=\"line\">        preprocessor: fis.plugin(&apos;cssprefixer&apos;, &#123;</span><br><span class=\"line\">            browsers: [&apos;Chrome &gt; 1&apos;],</span><br><span class=\"line\">            cascade: true</span><br><span class=\"line\">        &#125;),</span><br><span class=\"line\">        useSprite: true</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .match(&apos;*.&#123;png, jpg, svg, gif&#125;&apos;, &#123;</span><br><span class=\"line\">        useHash: true,</span><br><span class=\"line\">        useSprite: true,</span><br><span class=\"line\">        optimizer: null</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 三、模块化处理</span><br><span class=\"line\"> */</span><br><span class=\"line\">// 1. path短路径</span><br><span class=\"line\">fis.hook(&apos;commonjs&apos;, &#123;</span><br><span class=\"line\">    // 要加vue</span><br><span class=\"line\">    extList: [</span><br><span class=\"line\">        &apos;.js&apos;, &apos;.vue&apos;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    paths: &#123;</span><br><span class=\"line\">        api: &apos;/app/static/config/api.js&apos;,</span><br><span class=\"line\">        constant: &apos;/app/static/config/constant.js&apos;,</span><br><span class=\"line\">        notifyNativeError: &apos;/app/static/config/notify-native-error/index.js&apos;,</span><br><span class=\"line\">        formConfig: &apos;/app/static/config/form/index.js&apos;,</span><br><span class=\"line\">        component: &apos;/app/component&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">// 2. node_modules</span><br><span class=\"line\">    .hook(&apos;node_modules&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">// 3. js模块化处理</span><br><span class=\"line\">var modList = [</span><br><span class=\"line\">    &apos;/node_modules/**.js&apos;, // 因为某些js没有模块化</span><br><span class=\"line\">    &apos;/app/static/config/**.js&apos;,</span><br><span class=\"line\">    &apos;/app/static/js/**.js&apos;,</span><br><span class=\"line\">    &apos;/app/page/**.js&apos;,</span><br><span class=\"line\">    &apos;/app/component/**.js&apos;,</span><br><span class=\"line\">    &apos;/components/**.js&apos;,</span><br><span class=\"line\">    &apos;/loan-components/**.js&apos;</span><br><span class=\"line\">].join(&apos;,&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">fis.match(&apos;&#123;&apos; + modList + &apos;&#125;&apos;, &#123;</span><br><span class=\"line\">    isMod: true,</span><br><span class=\"line\">    useHash: true</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .match(/^\\/page\\/activity\\/activity-static\\/track\\/.*\\.(js)/i, &#123;</span><br><span class=\"line\">        isMod: false</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    .match(&apos;/components/fin-fg/error-reporter/index.js&apos;, &#123;</span><br><span class=\"line\">        isMod: false</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 四、优化optimizer</span><br><span class=\"line\"> */</span><br><span class=\"line\">// 1. 压缩：</span><br><span class=\"line\">// 【默认没有压缩】</span><br><span class=\"line\">// - 组件vue转换成的js</span><br><span class=\"line\">// - png</span><br><span class=\"line\">// 【默认有压缩】</span><br><span class=\"line\">// - tpl</span><br><span class=\"line\">// - css</span><br><span class=\"line\">fis.match(&apos;*.&#123;js, vue&#125;&apos;, &#123;</span><br><span class=\"line\">    optimizer: fis.plugin(&apos;uglify-js&apos;, &#123;</span><br><span class=\"line\">        output: &#123;</span><br><span class=\"line\">            // smarty 超过200字符会截断</span><br><span class=\"line\">            /* eslint-disable */</span><br><span class=\"line\">            max_line_len: 200</span><br><span class=\"line\">            /* eslint-enable */</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">    .match(&apos;*.png&apos;, &#123;</span><br><span class=\"line\">        optimizer: fis.plugin(&apos;png-compressor&apos;, &#123;&#125;)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 五、media多环境</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">// 本地环境</span><br><span class=\"line\">// 开发模式</span><br><span class=\"line\">fis.media(&apos;debug&apos;)</span><br><span class=\"line\">    .match(&apos;*.&#123;js, vue, less, css, png, jpg, svg&#125;&apos;, &#123;</span><br><span class=\"line\">        useHash: false,</span><br><span class=\"line\">        useSprite: false,</span><br><span class=\"line\">        optimizer: null</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">// 模拟线上</span><br><span class=\"line\">fis.media(&apos;devonline&apos;)</span><br><span class=\"line\">    .match(&apos;::packager&apos;, &#123;</span><br><span class=\"line\">        packager: fis.plugin(&apos;deps-pack&apos;, pkgMap)</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">// 2. 联调环境</span><br><span class=\"line\"></span><br><span class=\"line\">/**</span><br><span class=\"line\"> * 不能同步到rd机器检查点</span><br><span class=\"line\"> *</span><br><span class=\"line\"> * 1. less 或者 css相关文件没有文件注释，或者只有根选择器没有内容</span><br><span class=\"line\"> * 2. receiver.php没有部署或者删除</span><br><span class=\"line\"> *</span><br><span class=\"line\"> */</span><br><span class=\"line\"></span><br><span class=\"line\">// 联调推到rd机器</span><br><span class=\"line\">var rdInfo = [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: &apos;rd&apos;,</span><br><span class=\"line\">        path: &apos;/home/work/odp-cloan&apos;,</span><br><span class=\"line\">        receiver: &apos;http://gzns-nbg-fpu-aug-c02xi2-87.gzns.baidu.com:8080/umoneyweb/receiver.php&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: &apos;rd3&apos;,</span><br><span class=\"line\">        path: &apos;/home/work/odp-cloan3&apos;,</span><br><span class=\"line\">        receiver: &apos;http://gzns-nbg-fpu-aug-c02xi2-87.gzns.baidu.com:8080/umoneyweb/receiver.php&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        name: &apos;dev&apos;,</span><br><span class=\"line\">        path: &apos;/home/work/odp&apos;,</span><br><span class=\"line\">        receiver: &apos;http://gzns-um-c63.epc.baidu.com:9999/receiver.php&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">];</span><br><span class=\"line\">// 3. 测试环境+线上环境</span><br><span class=\"line\">onlineEnv(&apos;qa&apos;);</span><br><span class=\"line\">onlineEnv(&apos;prod&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">function onlineEnv(mediaName) &#123;</span><br><span class=\"line\">    fis.media(mediaName)</span><br><span class=\"line\">        .match(&apos;**/icon/**&apos;, &#123;</span><br><span class=\"line\">            release: &apos;/static/$&#123;namespace&#125;/pkg/font/$1&apos;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .match(&apos;*.&#123;png, jpg, gif, svg&#125;&apos;, &#123;</span><br><span class=\"line\">            release: &apos;/static/$&#123;namespace&#125;/pkg/image/$0&apos;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .match(&apos;&#123;components/**.js, app/page/layout.tpl:js, loan-components/**.js&#125;&apos;, &#123;</span><br><span class=\"line\">            parser: [</span><br><span class=\"line\">                fis.plugin(&apos;jdists&apos;, &#123;</span><br><span class=\"line\">                    remove: &apos;debug,test,dev&apos;</span><br><span class=\"line\">                &#125;),</span><br><span class=\"line\">                fis.plugin(&apos;babel-6.x&apos;, &#123;</span><br><span class=\"line\">                    plugins: [</span><br><span class=\"line\">                        &apos;add-module-exports&apos;,</span><br><span class=\"line\">                        &apos;transform-object-assign&apos;,</span><br><span class=\"line\">                        &apos;async-to-promises&apos;,</span><br><span class=\"line\">                        &apos;array-includes&apos;</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .match(&apos;::packager&apos;, &#123;</span><br><span class=\"line\">            packager: fis.plugin(&apos;deps-pack&apos;, pkgMap)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">        .match(&apos;**&apos;, &#123;</span><br><span class=\"line\">            deploy: [</span><br><span class=\"line\">                fis.plugin(&apos;skip-packed&apos;),</span><br><span class=\"line\">                fis.plugin(&apos;local-deliver&apos;, &#123;</span><br><span class=\"line\">                    to: fis.get(&apos;options.dest&apos;) || fis.get(&apos;options.d&apos;) || &apos;./output&apos;</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    if (mediaName === &apos;prod&apos;) &#123;</span><br><span class=\"line\">        fis.media(mediaName)</span><br><span class=\"line\">            .match(&apos;!*.tpl&apos;, &#123;</span><br><span class=\"line\">                domain: [&apos;https://umoney.bdstatic.com/webroot&apos;]</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"fis3的输出\"><a href=\"#fis3的输出\" class=\"headerlink\" title=\"fis3的输出\"></a>fis3的输出</h3><blockquote>\n<p>fis3的打包阶段只搜集所有文件列表以及各种依赖关系，根据打包阶段生成的资源表自定义产出规则。</p>\n</blockquote>\n<h3 id=\"fis3可以提供假mock数据\"><a href=\"#fis3可以提供假mock数据\" class=\"headerlink\" title=\"fis3可以提供假mock数据\"></a>fis3可以提供假mock数据</h3><p>fis3提供mock假数据模拟协助前端开发，需要放到服务器的/mock/sample.json目录下，确保通过<a href=\"http://127.0.0.1:8080/mock/sample.json可以访问到\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8080/mock/sample.json可以访问到</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\"> &quot;error&quot;: 0,</span><br><span class=\"line\"> &quot;message&quot;: &quot;ok&quot;,</span><br><span class=\"line\"> &quot;data&quot;: &#123;</span><br><span class=\"line\">   &quot;uname&quot;: &quot;foo&quot;,</span><br><span class=\"line\">   &quot;uid&quot;: 1</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>准备一个server.conf配置文件放在服务器的/mock/server.conf目录，内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rewrite ^\\/api\\/user$ /mock/sample.json</span><br></pre></td></tr></table></figure>"},{"title":"JS深拷贝浅拷贝","date":"2018-05-17T05:51:43.000Z","about":null,"_content":"### 深拷贝和浅拷贝主要区别是在内存中存储类型（堆栈）不同。\n\n> 但其实js中没有严格意义上区分堆栈内存，因此可以粗暴的认为所有的数据类型都存储在堆内存，但是有些场景下还是需要利用栈数据结构的思维来实现一些思维，比如，js的执行上下文就采用了栈结构实现环境栈（又名函数调用栈）。\n\n## 堆栈的区别\n> 栈，先进后出(FILO)的存储方式，按值存放可直接访问。堆，树状结构，按引用访问。\n<!--more-->\n## js中的数据类型\n1. 基本数据类型：String，Number，Null，Undefined，Boolean。五中基本数据类型的变量直接按值存放，存在栈内存中，可直接访问。\n2. 引用类型：Object，Array，Function。值大小不固定，栈内存中的变量值存的是地址，指向堆内存中的对象。访问引用类型的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得数据。\n* 见下图理解：\n\n![](https://note.youdao.com/yws/public/resource/9274007941c429664226c48c2ba441e5/xmlnote/WEBRESOURCEe9e63c24c049cb8c31d381f59aafc906/2976)\n\n### 说拷贝之前还想再说一下js中的按值传递和按引用传递\n#### 按值传递\n> 高程书中写道：ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。可以把ECMAScript函数的参数想象成局部变量。\n\n举个例子：\n\n```\nfunction foo(v) {\n    v = 2;\n    return v;\n}\n\nvar value = 1;\nfoo(value); // 2\nconsole.log(value) // 1\n```\n可以看到，value被传递到foo函数中的时候，相当于把实参变量value的值拷贝给形参变量v，函数内部修改的都是形参变量v的值，不会影响原来的变量value的值。\n\n#### 按引用传递\n> 像上述的基本数据类型的值的拷贝还是很好理解的，但是当值的数据类型变得复杂，上面的拷贝方式就会产生性能上的影响，所以出现了另外一种传递方式——按引用传递。所谓引用传递，就是传递对象的引用，函数内部对参数的修改会反映在函数外部，因为两者引用的是同一个对象。\n\n举个例子：\n\n```\nfunction change(person) {\n    person.age = 25;\n    \n    return person;\n}\n\nvar obj1 = {\n    name: 'young',\n    age: 21\n};\nvar obj2 = change(obj1);\nconsole.log(obj1); // {name: 'young', age: 25}\nconsole.log(obj2); // {name: 'young', age: 25}\n```\n等一下，和高程书说的好像有点不一样，这样子的话看着像是按引用传递了······稍安勿躁~\n\n#### 共享传递\n> 共享传递是指，在传递对象的时候，传递对象的引用的副本。注意！！！按引用传递是指传递对象的引用，按共享传递是指传递对象的引用的副本。\n\n再看个例子：\n\n```\nfunction change(person) {\n    person.age = 25;\n    person = {\n        name: 'miaorenjie',\n        age: 20\n    };\n    \n    return person;\n}\n\nvar obj1 = {\n    name: 'young',\n    age: 21\n};\nvar obj2 = change(obj1);\nconsole.log(obj1); // {name: 'young', age: 25}\nconsole.log(obj2); // {name: 'miaorenjie', age: 20}\n```\n所以修改person.age是通过引用找到原值，并且影响原值的，并不是通过person，后面直接修改person，是更改了person的指向，也就是重新拷贝了指向内存的地址，原本指向obj1的指针就变为了指向新的对象，所以，可以看到的是obj1的属性改变是通过引用修改的，而如果说是按引用传递的话，person的修改也是会反映在obj1上的。所以，总结一下，我们可以这么理解：\n> 参数如果是基本数据类型，就是按值传递，如果是引用类型，就是按共享传递。因为不论拷贝值副本还是地址副本始终也是拷贝的值，所以红宝书告诉你说参数都是按值传递~\n\n### 浅拷贝&深拷贝\n首先，深拷贝和浅拷贝在js中是对引用类型而言的。\n\n> 浅拷贝：指新拷贝的对象和原对象指向同一个地址，改变其中一个变量的内容都会反映在另外一个变量身上，也就是拷贝的原对象的内存地址。\n深拷贝：指重新分配内存给新拷贝的对象，将原对象的各个属性复制进去，对拷贝对象和原对象各自的操作互不影响。\n\n接下来看具体实现吧，终于切入正题了~\n1. 赋值：\n\n```\nvar obj = {\n    name : 'miaorenjie',\n    age: 20,\n    like: ['black', 'white']\n};\n\nvar obj1 = obj;\nobj1.name = 'young';\nobj1.like[0] = 'pink';\n\nconsole.log(obj); // { name: 'young', age: 20, like: [ 'pink', 'blue' ] }\nconsole.log(obj1); // { name: 'young', age: 20, like: [ 'pink', 'blue' ] }\n```\n可以看到的是，赋值操作是纯粹的复制原对象的引用，所以在修改新对象的原始数据类型和引用类型的值之后的变化也都反映在了原对象上。\n\n2. 浅拷贝（简单的复制引用）\n\n```\nfunction shallowCopy(src) {\n    var result = {};\n    for(var i in src) {\n        if(src.hasOwnProperty(i)) {\n            result[i] = src[i];\n        }\n    }\n    \n    return result;\n}\n\nvar obj = {\n    name : 'miaorenjie',\n    age: 20,\n    like: ['black', 'white']\n}\n\nvar obj2 = shallowCopy(obj);\nobj2.age = 21;\nobj2.like[1] = 'blue';\nconsole.log(obj); // { name: 'miaorenjie', age: 20, like: [ 'black', 'blue' ] }\nconsole.log(obj2); // { name: 'miaorenjie', age: 21, like: [ 'black', 'blue' ] }\n```\n可以看到，新复制的对象好像并没有和原对象共用内存呀，要不然怎么基本数据类型没有随之修改。如果你也产生了这个疑问，那么恭喜，你和小编走入了同一个误区。此处所实现的浅复制，指的是循环复制原对象的属性时，进行的一层浅复制，也就是在循环赋值到某个具体的属性的时候，对这个具体的属性进行复制，如果是原始数据类型就复制的属性值，如果是引用类型就复制引用类型的属性值——对象的引用，所以基本数据类型是没有共用内存的，只有原对象中的对象才是共用内存的，所以只有引用类型的值在互相影响。\n\n2. Object.assign()\n> Object.assign(target, ...sources)方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。[target:目标对象，sources:源对象] \n\n- 浅拷贝\n> 因为 Object.assign()拷贝的是属性值。。假如源对象的属性值是一个指向对象的引用，它就拷贝那个引用值，也就是源对象中的引用属性会和目标对象的该属性共用内存，两者的后续修改都会影响到对方，这时候获得的就是源对象的浅复制。\n\n```\n// 第一种假如\nlet obj1 = { a: 0 , b: { c: 0}};\nlet obj2 = Object.assign({}, obj1);\nobj1.a = 1;\nconsole.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}\nconsole.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}\nobj2.a = 2;\nconsole.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}\nconsole.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}}\n\n// 第二种假如\nobj2.b.c = 3;\nconsole.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}}\nconsole.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}}\n```\n\n- 拷贝Symbol类型的属性\n\n```\nvar o1 = { a: 1 };\nvar o2 = { [Symbol('foo')]: 2 };\n\nvar obj = Object.assign({}, o1, o2);\nconsole.log(obj); // { a : 1, [Symbol(\"foo\")]: 2 } (cf. bug 1207182 on Firefox)\nObject.getOwnPropertySymbols(obj); // [Symbol(foo)]\n```\n- 原始类型会被包装为对象\n> Object.assign()会忽略null或undefined的源值，因为原始类型会被包装成对象，但是null和undefined无法转成对象，只有字符串的包装对象才可能有自身可枚举属性。包装后的对象属性值对应的键是它在源对象中的索引。\n\n```\nvar v1 = \"abc\";\nvar v2 = true;\nvar v3 = 10;\nvar v4 = Symbol(\"foo\")\n\nvar obj = Object.assign({}, v1, null, v2, undefined, v3, v4); \n// 原始类型会被包装，null 和 undefined 会被忽略。\n// 注意，只有字符串的包装对象才可能有自身可枚举属性。\nconsole.log(obj); // { \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" }\n```\n-  继承属性和不可枚举属性不可拷贝\n> Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它是分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。\n\n```\nvar obj = Object.create({foo: 1}, { // foo 是个继承属性。\n    bar: {\n        value: 2  // bar 是个不可枚举属性。\n    },\n    baz: {\n        value: 3,\n        enumerable: true  // baz 是个自身可枚举属性。\n    }\n});\n\nvar copy = Object.assign({}, obj);\nconsole.log(copy); // { baz: 3 }\n```\n- 属性覆盖（可用来合并对象）\n> 如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。\n\n```\nvar o1 = { a: 1, b: 1, c: 1 };\nvar o2 = { b: 2, c: 2 };\nvar o3 = { c: 3 };\n\nvar obj = Object.assign({}, o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\n```\n- 异常会打断后续拷贝任务\n> 在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。\n\n```\nvar target = Object.defineProperty({}, \"foo\", {\n    value: 1,\n    writable: false\n}); // target 的 foo 属性是个只读属性。\n\nObject.assign(target, {bar: 2}, {foo2: 3, foo: 3, foo3: 3}, {baz: 4});\n// TypeError: \"foo\" is read-only\n// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。\n\nconsole.log(target.bar);  // 2，说明第一个源对象拷贝成功了。\nconsole.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。\nconsole.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。\nconsole.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。\nconsole.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。\n```\n3. 深拷贝\n> 上面也说了，浅复制复制的是引用类型的地址，并没有开辟新的内存空间，而深复制是开辟新的内存来存放新对象，源对象和新对象对应的是两个不同的地址，修改其中一个对象的属性，不会改变另外一个对象的属性。深复制的几种实现：\n\n- 递归解析\n> 因为使用递归，性能会不如浅拷贝\n```\nfunction deepCopy(src, res) {\n    var res = res || {};\n    for(var i in src) {\n        if(src.hasOwnProperty(i)) {\n            if(typeof src[i] === 'object') {\n                res[i] = (src[i].constructor === Array) ? [] : {};\n                deepCopy(src[i], res[i]);\n            } else {\n                res[i] = src[i];\n            }\n        }\n    }\n    return res;\n}\n\nvar obj1 = {};\ndeepCopy(obj, obj1);\nobj1.age = 21;\nobj1.like[1] = 'blue';\n\nconsole.log(obj); // { name: 'miaorenjie', age: 20, like: [ 'black', 'white' ] }\nconsole.log(obj1); // { name: 'miaorenjie', age: 21, like: [ 'black', 'blue' ] }\n```\n- JSON解析\n> 局限性：如果被拷贝的对象中有function，则拷贝之后的对象就会丢失这个function，原型链就没了；如果被拷贝的对象中有正则表达式，则拷贝之后的对象正则表达式会变成Object\n\n```\nvar obj = {\n    name : 'miaorenjie',\n    age: 20,\n    like: ['black', 'white']\n}\n\nvar result = JSON.parse(JSON.stringify(obj));\nresult.age = 21;\nresult.name = 'young';\nresult.like.push('pink');\nconsole.log(obj); // { name: 'miaorenjie', age: 20, like: [ 'black', 'white' ] }\nconsole.log(result); // { name: 'young', age: 21, like: [ 'black', 'white', 'pink' ] }\n```\n- Object.assign()（当对象只有一层的时候使用）\n> 假如源对象的属性值不包含引用类型，那该方法返回的值就是一个与源对象相同但不在同一块内存的另一个对象，源对象和新对象的后续修改是互不影响的，也就是返回了源对象的深拷贝。\n\n```\nobj1 = { a: 0 , b: { c: 0}};\nlet obj3 = JSON.parse(JSON.stringify(obj1));\nobj1.a = 4;\nobj1.b.c = 4;\nconsole.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}\n```","source":"_posts/js深拷贝浅拷贝.md","raw":"---\ntitle: JS深拷贝浅拷贝\ndate: 2018-05-17 13:51:43\ntags: \n- 对象拷贝\ncategories: ES5 ES6\nabout:\n---\n### 深拷贝和浅拷贝主要区别是在内存中存储类型（堆栈）不同。\n\n> 但其实js中没有严格意义上区分堆栈内存，因此可以粗暴的认为所有的数据类型都存储在堆内存，但是有些场景下还是需要利用栈数据结构的思维来实现一些思维，比如，js的执行上下文就采用了栈结构实现环境栈（又名函数调用栈）。\n\n## 堆栈的区别\n> 栈，先进后出(FILO)的存储方式，按值存放可直接访问。堆，树状结构，按引用访问。\n<!--more-->\n## js中的数据类型\n1. 基本数据类型：String，Number，Null，Undefined，Boolean。五中基本数据类型的变量直接按值存放，存在栈内存中，可直接访问。\n2. 引用类型：Object，Array，Function。值大小不固定，栈内存中的变量值存的是地址，指向堆内存中的对象。访问引用类型的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得数据。\n* 见下图理解：\n\n![](https://note.youdao.com/yws/public/resource/9274007941c429664226c48c2ba441e5/xmlnote/WEBRESOURCEe9e63c24c049cb8c31d381f59aafc906/2976)\n\n### 说拷贝之前还想再说一下js中的按值传递和按引用传递\n#### 按值传递\n> 高程书中写道：ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。可以把ECMAScript函数的参数想象成局部变量。\n\n举个例子：\n\n```\nfunction foo(v) {\n    v = 2;\n    return v;\n}\n\nvar value = 1;\nfoo(value); // 2\nconsole.log(value) // 1\n```\n可以看到，value被传递到foo函数中的时候，相当于把实参变量value的值拷贝给形参变量v，函数内部修改的都是形参变量v的值，不会影响原来的变量value的值。\n\n#### 按引用传递\n> 像上述的基本数据类型的值的拷贝还是很好理解的，但是当值的数据类型变得复杂，上面的拷贝方式就会产生性能上的影响，所以出现了另外一种传递方式——按引用传递。所谓引用传递，就是传递对象的引用，函数内部对参数的修改会反映在函数外部，因为两者引用的是同一个对象。\n\n举个例子：\n\n```\nfunction change(person) {\n    person.age = 25;\n    \n    return person;\n}\n\nvar obj1 = {\n    name: 'young',\n    age: 21\n};\nvar obj2 = change(obj1);\nconsole.log(obj1); // {name: 'young', age: 25}\nconsole.log(obj2); // {name: 'young', age: 25}\n```\n等一下，和高程书说的好像有点不一样，这样子的话看着像是按引用传递了······稍安勿躁~\n\n#### 共享传递\n> 共享传递是指，在传递对象的时候，传递对象的引用的副本。注意！！！按引用传递是指传递对象的引用，按共享传递是指传递对象的引用的副本。\n\n再看个例子：\n\n```\nfunction change(person) {\n    person.age = 25;\n    person = {\n        name: 'miaorenjie',\n        age: 20\n    };\n    \n    return person;\n}\n\nvar obj1 = {\n    name: 'young',\n    age: 21\n};\nvar obj2 = change(obj1);\nconsole.log(obj1); // {name: 'young', age: 25}\nconsole.log(obj2); // {name: 'miaorenjie', age: 20}\n```\n所以修改person.age是通过引用找到原值，并且影响原值的，并不是通过person，后面直接修改person，是更改了person的指向，也就是重新拷贝了指向内存的地址，原本指向obj1的指针就变为了指向新的对象，所以，可以看到的是obj1的属性改变是通过引用修改的，而如果说是按引用传递的话，person的修改也是会反映在obj1上的。所以，总结一下，我们可以这么理解：\n> 参数如果是基本数据类型，就是按值传递，如果是引用类型，就是按共享传递。因为不论拷贝值副本还是地址副本始终也是拷贝的值，所以红宝书告诉你说参数都是按值传递~\n\n### 浅拷贝&深拷贝\n首先，深拷贝和浅拷贝在js中是对引用类型而言的。\n\n> 浅拷贝：指新拷贝的对象和原对象指向同一个地址，改变其中一个变量的内容都会反映在另外一个变量身上，也就是拷贝的原对象的内存地址。\n深拷贝：指重新分配内存给新拷贝的对象，将原对象的各个属性复制进去，对拷贝对象和原对象各自的操作互不影响。\n\n接下来看具体实现吧，终于切入正题了~\n1. 赋值：\n\n```\nvar obj = {\n    name : 'miaorenjie',\n    age: 20,\n    like: ['black', 'white']\n};\n\nvar obj1 = obj;\nobj1.name = 'young';\nobj1.like[0] = 'pink';\n\nconsole.log(obj); // { name: 'young', age: 20, like: [ 'pink', 'blue' ] }\nconsole.log(obj1); // { name: 'young', age: 20, like: [ 'pink', 'blue' ] }\n```\n可以看到的是，赋值操作是纯粹的复制原对象的引用，所以在修改新对象的原始数据类型和引用类型的值之后的变化也都反映在了原对象上。\n\n2. 浅拷贝（简单的复制引用）\n\n```\nfunction shallowCopy(src) {\n    var result = {};\n    for(var i in src) {\n        if(src.hasOwnProperty(i)) {\n            result[i] = src[i];\n        }\n    }\n    \n    return result;\n}\n\nvar obj = {\n    name : 'miaorenjie',\n    age: 20,\n    like: ['black', 'white']\n}\n\nvar obj2 = shallowCopy(obj);\nobj2.age = 21;\nobj2.like[1] = 'blue';\nconsole.log(obj); // { name: 'miaorenjie', age: 20, like: [ 'black', 'blue' ] }\nconsole.log(obj2); // { name: 'miaorenjie', age: 21, like: [ 'black', 'blue' ] }\n```\n可以看到，新复制的对象好像并没有和原对象共用内存呀，要不然怎么基本数据类型没有随之修改。如果你也产生了这个疑问，那么恭喜，你和小编走入了同一个误区。此处所实现的浅复制，指的是循环复制原对象的属性时，进行的一层浅复制，也就是在循环赋值到某个具体的属性的时候，对这个具体的属性进行复制，如果是原始数据类型就复制的属性值，如果是引用类型就复制引用类型的属性值——对象的引用，所以基本数据类型是没有共用内存的，只有原对象中的对象才是共用内存的，所以只有引用类型的值在互相影响。\n\n2. Object.assign()\n> Object.assign(target, ...sources)方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。[target:目标对象，sources:源对象] \n\n- 浅拷贝\n> 因为 Object.assign()拷贝的是属性值。。假如源对象的属性值是一个指向对象的引用，它就拷贝那个引用值，也就是源对象中的引用属性会和目标对象的该属性共用内存，两者的后续修改都会影响到对方，这时候获得的就是源对象的浅复制。\n\n```\n// 第一种假如\nlet obj1 = { a: 0 , b: { c: 0}};\nlet obj2 = Object.assign({}, obj1);\nobj1.a = 1;\nconsole.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}\nconsole.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}}\nobj2.a = 2;\nconsole.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}}\nconsole.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}}\n\n// 第二种假如\nobj2.b.c = 3;\nconsole.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}}\nconsole.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}}\n```\n\n- 拷贝Symbol类型的属性\n\n```\nvar o1 = { a: 1 };\nvar o2 = { [Symbol('foo')]: 2 };\n\nvar obj = Object.assign({}, o1, o2);\nconsole.log(obj); // { a : 1, [Symbol(\"foo\")]: 2 } (cf. bug 1207182 on Firefox)\nObject.getOwnPropertySymbols(obj); // [Symbol(foo)]\n```\n- 原始类型会被包装为对象\n> Object.assign()会忽略null或undefined的源值，因为原始类型会被包装成对象，但是null和undefined无法转成对象，只有字符串的包装对象才可能有自身可枚举属性。包装后的对象属性值对应的键是它在源对象中的索引。\n\n```\nvar v1 = \"abc\";\nvar v2 = true;\nvar v3 = 10;\nvar v4 = Symbol(\"foo\")\n\nvar obj = Object.assign({}, v1, null, v2, undefined, v3, v4); \n// 原始类型会被包装，null 和 undefined 会被忽略。\n// 注意，只有字符串的包装对象才可能有自身可枚举属性。\nconsole.log(obj); // { \"0\": \"a\", \"1\": \"b\", \"2\": \"c\" }\n```\n-  继承属性和不可枚举属性不可拷贝\n> Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它是分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。\n\n```\nvar obj = Object.create({foo: 1}, { // foo 是个继承属性。\n    bar: {\n        value: 2  // bar 是个不可枚举属性。\n    },\n    baz: {\n        value: 3,\n        enumerable: true  // baz 是个自身可枚举属性。\n    }\n});\n\nvar copy = Object.assign({}, obj);\nconsole.log(copy); // { baz: 3 }\n```\n- 属性覆盖（可用来合并对象）\n> 如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。\n\n```\nvar o1 = { a: 1, b: 1, c: 1 };\nvar o2 = { b: 2, c: 2 };\nvar o3 = { c: 3 };\n\nvar obj = Object.assign({}, o1, o2, o3);\nconsole.log(obj); // { a: 1, b: 2, c: 3 }\n```\n- 异常会打断后续拷贝任务\n> 在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。\n\n```\nvar target = Object.defineProperty({}, \"foo\", {\n    value: 1,\n    writable: false\n}); // target 的 foo 属性是个只读属性。\n\nObject.assign(target, {bar: 2}, {foo2: 3, foo: 3, foo3: 3}, {baz: 4});\n// TypeError: \"foo\" is read-only\n// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。\n\nconsole.log(target.bar);  // 2，说明第一个源对象拷贝成功了。\nconsole.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。\nconsole.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。\nconsole.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。\nconsole.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。\n```\n3. 深拷贝\n> 上面也说了，浅复制复制的是引用类型的地址，并没有开辟新的内存空间，而深复制是开辟新的内存来存放新对象，源对象和新对象对应的是两个不同的地址，修改其中一个对象的属性，不会改变另外一个对象的属性。深复制的几种实现：\n\n- 递归解析\n> 因为使用递归，性能会不如浅拷贝\n```\nfunction deepCopy(src, res) {\n    var res = res || {};\n    for(var i in src) {\n        if(src.hasOwnProperty(i)) {\n            if(typeof src[i] === 'object') {\n                res[i] = (src[i].constructor === Array) ? [] : {};\n                deepCopy(src[i], res[i]);\n            } else {\n                res[i] = src[i];\n            }\n        }\n    }\n    return res;\n}\n\nvar obj1 = {};\ndeepCopy(obj, obj1);\nobj1.age = 21;\nobj1.like[1] = 'blue';\n\nconsole.log(obj); // { name: 'miaorenjie', age: 20, like: [ 'black', 'white' ] }\nconsole.log(obj1); // { name: 'miaorenjie', age: 21, like: [ 'black', 'blue' ] }\n```\n- JSON解析\n> 局限性：如果被拷贝的对象中有function，则拷贝之后的对象就会丢失这个function，原型链就没了；如果被拷贝的对象中有正则表达式，则拷贝之后的对象正则表达式会变成Object\n\n```\nvar obj = {\n    name : 'miaorenjie',\n    age: 20,\n    like: ['black', 'white']\n}\n\nvar result = JSON.parse(JSON.stringify(obj));\nresult.age = 21;\nresult.name = 'young';\nresult.like.push('pink');\nconsole.log(obj); // { name: 'miaorenjie', age: 20, like: [ 'black', 'white' ] }\nconsole.log(result); // { name: 'young', age: 21, like: [ 'black', 'white', 'pink' ] }\n```\n- Object.assign()（当对象只有一层的时候使用）\n> 假如源对象的属性值不包含引用类型，那该方法返回的值就是一个与源对象相同但不在同一块内存的另一个对象，源对象和新对象的后续修改是互不影响的，也就是返回了源对象的深拷贝。\n\n```\nobj1 = { a: 0 , b: { c: 0}};\nlet obj3 = JSON.parse(JSON.stringify(obj1));\nobj1.a = 4;\nobj1.b.c = 4;\nconsole.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}\n```","slug":"js深拷贝浅拷贝","published":1,"updated":"2019-02-22T08:37:33.717Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugrpc002lvrieusimqixg","content":"<h3 id=\"深拷贝和浅拷贝主要区别是在内存中存储类型（堆栈）不同。\"><a href=\"#深拷贝和浅拷贝主要区别是在内存中存储类型（堆栈）不同。\" class=\"headerlink\" title=\"深拷贝和浅拷贝主要区别是在内存中存储类型（堆栈）不同。\"></a>深拷贝和浅拷贝主要区别是在内存中存储类型（堆栈）不同。</h3><blockquote>\n<p>但其实js中没有严格意义上区分堆栈内存，因此可以粗暴的认为所有的数据类型都存储在堆内存，但是有些场景下还是需要利用栈数据结构的思维来实现一些思维，比如，js的执行上下文就采用了栈结构实现环境栈（又名函数调用栈）。</p>\n</blockquote>\n<h2 id=\"堆栈的区别\"><a href=\"#堆栈的区别\" class=\"headerlink\" title=\"堆栈的区别\"></a>堆栈的区别</h2><blockquote>\n<p>栈，先进后出(FILO)的存储方式，按值存放可直接访问。堆，树状结构，按引用访问。<br><a id=\"more\"></a></p>\n</blockquote>\n<h2 id=\"js中的数据类型\"><a href=\"#js中的数据类型\" class=\"headerlink\" title=\"js中的数据类型\"></a>js中的数据类型</h2><ol>\n<li>基本数据类型：String，Number，Null，Undefined，Boolean。五中基本数据类型的变量直接按值存放，存在栈内存中，可直接访问。</li>\n<li>引用类型：Object，Array，Function。值大小不固定，栈内存中的变量值存的是地址，指向堆内存中的对象。访问引用类型的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得数据。</li>\n</ol>\n<ul>\n<li>见下图理解：</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/public/resource/9274007941c429664226c48c2ba441e5/xmlnote/WEBRESOURCEe9e63c24c049cb8c31d381f59aafc906/2976\" alt></p>\n<h3 id=\"说拷贝之前还想再说一下js中的按值传递和按引用传递\"><a href=\"#说拷贝之前还想再说一下js中的按值传递和按引用传递\" class=\"headerlink\" title=\"说拷贝之前还想再说一下js中的按值传递和按引用传递\"></a>说拷贝之前还想再说一下js中的按值传递和按引用传递</h3><h4 id=\"按值传递\"><a href=\"#按值传递\" class=\"headerlink\" title=\"按值传递\"></a>按值传递</h4><blockquote>\n<p>高程书中写道：ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。可以把ECMAScript函数的参数想象成局部变量。</p>\n</blockquote>\n<p>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(v) &#123;</span><br><span class=\"line\">    v = 2;</span><br><span class=\"line\">    return v;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var value = 1;</span><br><span class=\"line\">foo(value); // 2</span><br><span class=\"line\">console.log(value) // 1</span><br></pre></td></tr></table></figure>\n<p>可以看到，value被传递到foo函数中的时候，相当于把实参变量value的值拷贝给形参变量v，函数内部修改的都是形参变量v的值，不会影响原来的变量value的值。</p>\n<h4 id=\"按引用传递\"><a href=\"#按引用传递\" class=\"headerlink\" title=\"按引用传递\"></a>按引用传递</h4><blockquote>\n<p>像上述的基本数据类型的值的拷贝还是很好理解的，但是当值的数据类型变得复杂，上面的拷贝方式就会产生性能上的影响，所以出现了另外一种传递方式——按引用传递。所谓引用传递，就是传递对象的引用，函数内部对参数的修改会反映在函数外部，因为两者引用的是同一个对象。</p>\n</blockquote>\n<p>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function change(person) &#123;</span><br><span class=\"line\">    person.age = 25;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return person;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj1 = &#123;</span><br><span class=\"line\">    name: &apos;young&apos;,</span><br><span class=\"line\">    age: 21</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var obj2 = change(obj1);</span><br><span class=\"line\">console.log(obj1); // &#123;name: &apos;young&apos;, age: 25&#125;</span><br><span class=\"line\">console.log(obj2); // &#123;name: &apos;young&apos;, age: 25&#125;</span><br></pre></td></tr></table></figure>\n<p>等一下，和高程书说的好像有点不一样，这样子的话看着像是按引用传递了······稍安勿躁~</p>\n<h4 id=\"共享传递\"><a href=\"#共享传递\" class=\"headerlink\" title=\"共享传递\"></a>共享传递</h4><blockquote>\n<p>共享传递是指，在传递对象的时候，传递对象的引用的副本。注意！！！按引用传递是指传递对象的引用，按共享传递是指传递对象的引用的副本。</p>\n</blockquote>\n<p>再看个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function change(person) &#123;</span><br><span class=\"line\">    person.age = 25;</span><br><span class=\"line\">    person = &#123;</span><br><span class=\"line\">        name: &apos;miaorenjie&apos;,</span><br><span class=\"line\">        age: 20</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return person;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj1 = &#123;</span><br><span class=\"line\">    name: &apos;young&apos;,</span><br><span class=\"line\">    age: 21</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var obj2 = change(obj1);</span><br><span class=\"line\">console.log(obj1); // &#123;name: &apos;young&apos;, age: 25&#125;</span><br><span class=\"line\">console.log(obj2); // &#123;name: &apos;miaorenjie&apos;, age: 20&#125;</span><br></pre></td></tr></table></figure>\n<p>所以修改person.age是通过引用找到原值，并且影响原值的，并不是通过person，后面直接修改person，是更改了person的指向，也就是重新拷贝了指向内存的地址，原本指向obj1的指针就变为了指向新的对象，所以，可以看到的是obj1的属性改变是通过引用修改的，而如果说是按引用传递的话，person的修改也是会反映在obj1上的。所以，总结一下，我们可以这么理解：</p>\n<blockquote>\n<p>参数如果是基本数据类型，就是按值传递，如果是引用类型，就是按共享传递。因为不论拷贝值副本还是地址副本始终也是拷贝的值，所以红宝书告诉你说参数都是按值传递~</p>\n</blockquote>\n<h3 id=\"浅拷贝-amp-深拷贝\"><a href=\"#浅拷贝-amp-深拷贝\" class=\"headerlink\" title=\"浅拷贝&amp;深拷贝\"></a>浅拷贝&amp;深拷贝</h3><p>首先，深拷贝和浅拷贝在js中是对引用类型而言的。</p>\n<blockquote>\n<p>浅拷贝：指新拷贝的对象和原对象指向同一个地址，改变其中一个变量的内容都会反映在另外一个变量身上，也就是拷贝的原对象的内存地址。<br>深拷贝：指重新分配内存给新拷贝的对象，将原对象的各个属性复制进去，对拷贝对象和原对象各自的操作互不影响。</p>\n</blockquote>\n<p>接下来看具体实现吧，终于切入正题了~</p>\n<ol>\n<li>赋值：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name : &apos;miaorenjie&apos;,</span><br><span class=\"line\">    age: 20,</span><br><span class=\"line\">    like: [&apos;black&apos;, &apos;white&apos;]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj1 = obj;</span><br><span class=\"line\">obj1.name = &apos;young&apos;;</span><br><span class=\"line\">obj1.like[0] = &apos;pink&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(obj); // &#123; name: &apos;young&apos;, age: 20, like: [ &apos;pink&apos;, &apos;blue&apos; ] &#125;</span><br><span class=\"line\">console.log(obj1); // &#123; name: &apos;young&apos;, age: 20, like: [ &apos;pink&apos;, &apos;blue&apos; ] &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到的是，赋值操作是纯粹的复制原对象的引用，所以在修改新对象的原始数据类型和引用类型的值之后的变化也都反映在了原对象上。</p>\n<ol start=\"2\">\n<li>浅拷贝（简单的复制引用）</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function shallowCopy(src) &#123;</span><br><span class=\"line\">    var result = &#123;&#125;;</span><br><span class=\"line\">    for(var i in src) &#123;</span><br><span class=\"line\">        if(src.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">            result[i] = src[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name : &apos;miaorenjie&apos;,</span><br><span class=\"line\">    age: 20,</span><br><span class=\"line\">    like: [&apos;black&apos;, &apos;white&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj2 = shallowCopy(obj);</span><br><span class=\"line\">obj2.age = 21;</span><br><span class=\"line\">obj2.like[1] = &apos;blue&apos;;</span><br><span class=\"line\">console.log(obj); // &#123; name: &apos;miaorenjie&apos;, age: 20, like: [ &apos;black&apos;, &apos;blue&apos; ] &#125;</span><br><span class=\"line\">console.log(obj2); // &#123; name: &apos;miaorenjie&apos;, age: 21, like: [ &apos;black&apos;, &apos;blue&apos; ] &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，新复制的对象好像并没有和原对象共用内存呀，要不然怎么基本数据类型没有随之修改。如果你也产生了这个疑问，那么恭喜，你和小编走入了同一个误区。此处所实现的浅复制，指的是循环复制原对象的属性时，进行的一层浅复制，也就是在循环赋值到某个具体的属性的时候，对这个具体的属性进行复制，如果是原始数据类型就复制的属性值，如果是引用类型就复制引用类型的属性值——对象的引用，所以基本数据类型是没有共用内存的，只有原对象中的对象才是共用内存的，所以只有引用类型的值在互相影响。</p>\n<ol start=\"2\">\n<li>Object.assign()<blockquote>\n<p>Object.assign(target, …sources)方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。[target:目标对象，sources:源对象] </p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>浅拷贝<blockquote>\n<p>因为 Object.assign()拷贝的是属性值。。假如源对象的属性值是一个指向对象的引用，它就拷贝那个引用值，也就是源对象中的引用属性会和目标对象的该属性共用内存，两者的后续修改都会影响到对方，这时候获得的就是源对象的浅复制。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第一种假如</span><br><span class=\"line\">let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;</span><br><span class=\"line\">let obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class=\"line\">obj1.a = 1;</span><br><span class=\"line\">console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125;</span><br><span class=\"line\">console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br><span class=\"line\">obj2.a = 2;</span><br><span class=\"line\">console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125;</span><br><span class=\"line\">console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 第二种假如</span><br><span class=\"line\">obj2.b.c = 3;</span><br><span class=\"line\">console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125;</span><br><span class=\"line\">console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>拷贝Symbol类型的属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o1 = &#123; a: 1 &#125;;</span><br><span class=\"line\">var o2 = &#123; [Symbol(&apos;foo&apos;)]: 2 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = Object.assign(&#123;&#125;, o1, o2);</span><br><span class=\"line\">console.log(obj); // &#123; a : 1, [Symbol(&quot;foo&quot;)]: 2 &#125; (cf. bug 1207182 on Firefox)</span><br><span class=\"line\">Object.getOwnPropertySymbols(obj); // [Symbol(foo)]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>原始类型会被包装为对象<blockquote>\n<p>Object.assign()会忽略null或undefined的源值，因为原始类型会被包装成对象，但是null和undefined无法转成对象，只有字符串的包装对象才可能有自身可枚举属性。包装后的对象属性值对应的键是它在源对象中的索引。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var v1 = &quot;abc&quot;;</span><br><span class=\"line\">var v2 = true;</span><br><span class=\"line\">var v3 = 10;</span><br><span class=\"line\">var v4 = Symbol(&quot;foo&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); </span><br><span class=\"line\">// 原始类型会被包装，null 和 undefined 会被忽略。</span><br><span class=\"line\">// 注意，只有字符串的包装对象才可能有自身可枚举属性。</span><br><span class=\"line\">console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>继承属性和不可枚举属性不可拷贝<blockquote>\n<p>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它是分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = Object.create(&#123;foo: 1&#125;, &#123; // foo 是个继承属性。</span><br><span class=\"line\">    bar: &#123;</span><br><span class=\"line\">        value: 2  // bar 是个不可枚举属性。</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    baz: &#123;</span><br><span class=\"line\">        value: 3,</span><br><span class=\"line\">        enumerable: true  // baz 是个自身可枚举属性。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var copy = Object.assign(&#123;&#125;, obj);</span><br><span class=\"line\">console.log(copy); // &#123; baz: 3 &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>属性覆盖（可用来合并对象）<blockquote>\n<p>如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o1 = &#123; a: 1, b: 1, c: 1 &#125;;</span><br><span class=\"line\">var o2 = &#123; b: 2, c: 2 &#125;;</span><br><span class=\"line\">var o3 = &#123; c: 3 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = Object.assign(&#123;&#125;, o1, o2, o3);</span><br><span class=\"line\">console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>异常会打断后续拷贝任务<blockquote>\n<p>在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var target = Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123;</span><br><span class=\"line\">    value: 1,</span><br><span class=\"line\">    writable: false</span><br><span class=\"line\">&#125;); // target 的 foo 属性是个只读属性。</span><br><span class=\"line\"></span><br><span class=\"line\">Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);</span><br><span class=\"line\">// TypeError: &quot;foo&quot; is read-only</span><br><span class=\"line\">// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(target.bar);  // 2，说明第一个源对象拷贝成功了。</span><br><span class=\"line\">console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。</span><br><span class=\"line\">console.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span><br><span class=\"line\">console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span><br><span class=\"line\">console.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>深拷贝<blockquote>\n<p>上面也说了，浅复制复制的是引用类型的地址，并没有开辟新的内存空间，而深复制是开辟新的内存来存放新对象，源对象和新对象对应的是两个不同的地址，修改其中一个对象的属性，不会改变另外一个对象的属性。深复制的几种实现：</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li><p>递归解析</p>\n<blockquote>\n<p>因为使用递归，性能会不如浅拷贝</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function deepCopy(src, res) &#123;</span><br><span class=\"line\">    var res = res || &#123;&#125;;</span><br><span class=\"line\">    for(var i in src) &#123;</span><br><span class=\"line\">        if(src.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">            if(typeof src[i] === &apos;object&apos;) &#123;</span><br><span class=\"line\">                res[i] = (src[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class=\"line\">                deepCopy(src[i], res[i]);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                res[i] = src[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj1 = &#123;&#125;;</span><br><span class=\"line\">deepCopy(obj, obj1);</span><br><span class=\"line\">obj1.age = 21;</span><br><span class=\"line\">obj1.like[1] = &apos;blue&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(obj); // &#123; name: &apos;miaorenjie&apos;, age: 20, like: [ &apos;black&apos;, &apos;white&apos; ] &#125;</span><br><span class=\"line\">console.log(obj1); // &#123; name: &apos;miaorenjie&apos;, age: 21, like: [ &apos;black&apos;, &apos;blue&apos; ] &#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>JSON解析</p>\n<blockquote>\n<p>局限性：如果被拷贝的对象中有function，则拷贝之后的对象就会丢失这个function，原型链就没了；如果被拷贝的对象中有正则表达式，则拷贝之后的对象正则表达式会变成Object</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name : &apos;miaorenjie&apos;,</span><br><span class=\"line\">    age: 20,</span><br><span class=\"line\">    like: [&apos;black&apos;, &apos;white&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result = JSON.parse(JSON.stringify(obj));</span><br><span class=\"line\">result.age = 21;</span><br><span class=\"line\">result.name = &apos;young&apos;;</span><br><span class=\"line\">result.like.push(&apos;pink&apos;);</span><br><span class=\"line\">console.log(obj); // &#123; name: &apos;miaorenjie&apos;, age: 20, like: [ &apos;black&apos;, &apos;white&apos; ] &#125;</span><br><span class=\"line\">console.log(result); // &#123; name: &apos;young&apos;, age: 21, like: [ &apos;black&apos;, &apos;white&apos;, &apos;pink&apos; ] &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Object.assign()（当对象只有一层的时候使用）<blockquote>\n<p>假如源对象的属性值不包含引用类型，那该方法返回的值就是一个与源对象相同但不在同一块内存的另一个对象，源对象和新对象的后续修改是互不影响的，也就是返回了源对象的深拷贝。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;</span><br><span class=\"line\">let obj3 = JSON.parse(JSON.stringify(obj1));</span><br><span class=\"line\">obj1.a = 4;</span><br><span class=\"line\">obj1.b.c = 4;</span><br><span class=\"line\">console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"深拷贝和浅拷贝主要区别是在内存中存储类型（堆栈）不同。\"><a href=\"#深拷贝和浅拷贝主要区别是在内存中存储类型（堆栈）不同。\" class=\"headerlink\" title=\"深拷贝和浅拷贝主要区别是在内存中存储类型（堆栈）不同。\"></a>深拷贝和浅拷贝主要区别是在内存中存储类型（堆栈）不同。</h3><blockquote>\n<p>但其实js中没有严格意义上区分堆栈内存，因此可以粗暴的认为所有的数据类型都存储在堆内存，但是有些场景下还是需要利用栈数据结构的思维来实现一些思维，比如，js的执行上下文就采用了栈结构实现环境栈（又名函数调用栈）。</p>\n</blockquote>\n<h2 id=\"堆栈的区别\"><a href=\"#堆栈的区别\" class=\"headerlink\" title=\"堆栈的区别\"></a>堆栈的区别</h2><blockquote>\n<p>栈，先进后出(FILO)的存储方式，按值存放可直接访问。堆，树状结构，按引用访问。<br>","more":"</p>\n</blockquote>\n<h2 id=\"js中的数据类型\"><a href=\"#js中的数据类型\" class=\"headerlink\" title=\"js中的数据类型\"></a>js中的数据类型</h2><ol>\n<li>基本数据类型：String，Number，Null，Undefined，Boolean。五中基本数据类型的变量直接按值存放，存在栈内存中，可直接访问。</li>\n<li>引用类型：Object，Array，Function。值大小不固定，栈内存中的变量值存的是地址，指向堆内存中的对象。访问引用类型的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得数据。</li>\n</ol>\n<ul>\n<li>见下图理解：</li>\n</ul>\n<p><img src=\"https://note.youdao.com/yws/public/resource/9274007941c429664226c48c2ba441e5/xmlnote/WEBRESOURCEe9e63c24c049cb8c31d381f59aafc906/2976\" alt></p>\n<h3 id=\"说拷贝之前还想再说一下js中的按值传递和按引用传递\"><a href=\"#说拷贝之前还想再说一下js中的按值传递和按引用传递\" class=\"headerlink\" title=\"说拷贝之前还想再说一下js中的按值传递和按引用传递\"></a>说拷贝之前还想再说一下js中的按值传递和按引用传递</h3><h4 id=\"按值传递\"><a href=\"#按值传递\" class=\"headerlink\" title=\"按值传递\"></a>按值传递</h4><blockquote>\n<p>高程书中写道：ECMAScript中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。可以把ECMAScript函数的参数想象成局部变量。</p>\n</blockquote>\n<p>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(v) &#123;</span><br><span class=\"line\">    v = 2;</span><br><span class=\"line\">    return v;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var value = 1;</span><br><span class=\"line\">foo(value); // 2</span><br><span class=\"line\">console.log(value) // 1</span><br></pre></td></tr></table></figure>\n<p>可以看到，value被传递到foo函数中的时候，相当于把实参变量value的值拷贝给形参变量v，函数内部修改的都是形参变量v的值，不会影响原来的变量value的值。</p>\n<h4 id=\"按引用传递\"><a href=\"#按引用传递\" class=\"headerlink\" title=\"按引用传递\"></a>按引用传递</h4><blockquote>\n<p>像上述的基本数据类型的值的拷贝还是很好理解的，但是当值的数据类型变得复杂，上面的拷贝方式就会产生性能上的影响，所以出现了另外一种传递方式——按引用传递。所谓引用传递，就是传递对象的引用，函数内部对参数的修改会反映在函数外部，因为两者引用的是同一个对象。</p>\n</blockquote>\n<p>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function change(person) &#123;</span><br><span class=\"line\">    person.age = 25;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return person;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj1 = &#123;</span><br><span class=\"line\">    name: &apos;young&apos;,</span><br><span class=\"line\">    age: 21</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var obj2 = change(obj1);</span><br><span class=\"line\">console.log(obj1); // &#123;name: &apos;young&apos;, age: 25&#125;</span><br><span class=\"line\">console.log(obj2); // &#123;name: &apos;young&apos;, age: 25&#125;</span><br></pre></td></tr></table></figure>\n<p>等一下，和高程书说的好像有点不一样，这样子的话看着像是按引用传递了······稍安勿躁~</p>\n<h4 id=\"共享传递\"><a href=\"#共享传递\" class=\"headerlink\" title=\"共享传递\"></a>共享传递</h4><blockquote>\n<p>共享传递是指，在传递对象的时候，传递对象的引用的副本。注意！！！按引用传递是指传递对象的引用，按共享传递是指传递对象的引用的副本。</p>\n</blockquote>\n<p>再看个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function change(person) &#123;</span><br><span class=\"line\">    person.age = 25;</span><br><span class=\"line\">    person = &#123;</span><br><span class=\"line\">        name: &apos;miaorenjie&apos;,</span><br><span class=\"line\">        age: 20</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return person;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj1 = &#123;</span><br><span class=\"line\">    name: &apos;young&apos;,</span><br><span class=\"line\">    age: 21</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var obj2 = change(obj1);</span><br><span class=\"line\">console.log(obj1); // &#123;name: &apos;young&apos;, age: 25&#125;</span><br><span class=\"line\">console.log(obj2); // &#123;name: &apos;miaorenjie&apos;, age: 20&#125;</span><br></pre></td></tr></table></figure>\n<p>所以修改person.age是通过引用找到原值，并且影响原值的，并不是通过person，后面直接修改person，是更改了person的指向，也就是重新拷贝了指向内存的地址，原本指向obj1的指针就变为了指向新的对象，所以，可以看到的是obj1的属性改变是通过引用修改的，而如果说是按引用传递的话，person的修改也是会反映在obj1上的。所以，总结一下，我们可以这么理解：</p>\n<blockquote>\n<p>参数如果是基本数据类型，就是按值传递，如果是引用类型，就是按共享传递。因为不论拷贝值副本还是地址副本始终也是拷贝的值，所以红宝书告诉你说参数都是按值传递~</p>\n</blockquote>\n<h3 id=\"浅拷贝-amp-深拷贝\"><a href=\"#浅拷贝-amp-深拷贝\" class=\"headerlink\" title=\"浅拷贝&amp;深拷贝\"></a>浅拷贝&amp;深拷贝</h3><p>首先，深拷贝和浅拷贝在js中是对引用类型而言的。</p>\n<blockquote>\n<p>浅拷贝：指新拷贝的对象和原对象指向同一个地址，改变其中一个变量的内容都会反映在另外一个变量身上，也就是拷贝的原对象的内存地址。<br>深拷贝：指重新分配内存给新拷贝的对象，将原对象的各个属性复制进去，对拷贝对象和原对象各自的操作互不影响。</p>\n</blockquote>\n<p>接下来看具体实现吧，终于切入正题了~</p>\n<ol>\n<li>赋值：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name : &apos;miaorenjie&apos;,</span><br><span class=\"line\">    age: 20,</span><br><span class=\"line\">    like: [&apos;black&apos;, &apos;white&apos;]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj1 = obj;</span><br><span class=\"line\">obj1.name = &apos;young&apos;;</span><br><span class=\"line\">obj1.like[0] = &apos;pink&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(obj); // &#123; name: &apos;young&apos;, age: 20, like: [ &apos;pink&apos;, &apos;blue&apos; ] &#125;</span><br><span class=\"line\">console.log(obj1); // &#123; name: &apos;young&apos;, age: 20, like: [ &apos;pink&apos;, &apos;blue&apos; ] &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到的是，赋值操作是纯粹的复制原对象的引用，所以在修改新对象的原始数据类型和引用类型的值之后的变化也都反映在了原对象上。</p>\n<ol start=\"2\">\n<li>浅拷贝（简单的复制引用）</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function shallowCopy(src) &#123;</span><br><span class=\"line\">    var result = &#123;&#125;;</span><br><span class=\"line\">    for(var i in src) &#123;</span><br><span class=\"line\">        if(src.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">            result[i] = src[i];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    return result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name : &apos;miaorenjie&apos;,</span><br><span class=\"line\">    age: 20,</span><br><span class=\"line\">    like: [&apos;black&apos;, &apos;white&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj2 = shallowCopy(obj);</span><br><span class=\"line\">obj2.age = 21;</span><br><span class=\"line\">obj2.like[1] = &apos;blue&apos;;</span><br><span class=\"line\">console.log(obj); // &#123; name: &apos;miaorenjie&apos;, age: 20, like: [ &apos;black&apos;, &apos;blue&apos; ] &#125;</span><br><span class=\"line\">console.log(obj2); // &#123; name: &apos;miaorenjie&apos;, age: 21, like: [ &apos;black&apos;, &apos;blue&apos; ] &#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，新复制的对象好像并没有和原对象共用内存呀，要不然怎么基本数据类型没有随之修改。如果你也产生了这个疑问，那么恭喜，你和小编走入了同一个误区。此处所实现的浅复制，指的是循环复制原对象的属性时，进行的一层浅复制，也就是在循环赋值到某个具体的属性的时候，对这个具体的属性进行复制，如果是原始数据类型就复制的属性值，如果是引用类型就复制引用类型的属性值——对象的引用，所以基本数据类型是没有共用内存的，只有原对象中的对象才是共用内存的，所以只有引用类型的值在互相影响。</p>\n<ol start=\"2\">\n<li>Object.assign()<blockquote>\n<p>Object.assign(target, …sources)方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。[target:目标对象，sources:源对象] </p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li>浅拷贝<blockquote>\n<p>因为 Object.assign()拷贝的是属性值。。假如源对象的属性值是一个指向对象的引用，它就拷贝那个引用值，也就是源对象中的引用属性会和目标对象的该属性共用内存，两者的后续修改都会影响到对方，这时候获得的就是源对象的浅复制。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 第一种假如</span><br><span class=\"line\">let obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;</span><br><span class=\"line\">let obj2 = Object.assign(&#123;&#125;, obj1);</span><br><span class=\"line\">obj1.a = 1;</span><br><span class=\"line\">console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125;</span><br><span class=\"line\">console.log(JSON.stringify(obj2)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br><span class=\"line\">obj2.a = 2;</span><br><span class=\"line\">console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 0&#125;&#125;</span><br><span class=\"line\">console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 0&#125;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 第二种假如</span><br><span class=\"line\">obj2.b.c = 3;</span><br><span class=\"line\">console.log(JSON.stringify(obj1)); // &#123; a: 1, b: &#123; c: 3&#125;&#125;</span><br><span class=\"line\">console.log(JSON.stringify(obj2)); // &#123; a: 2, b: &#123; c: 3&#125;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>拷贝Symbol类型的属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o1 = &#123; a: 1 &#125;;</span><br><span class=\"line\">var o2 = &#123; [Symbol(&apos;foo&apos;)]: 2 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = Object.assign(&#123;&#125;, o1, o2);</span><br><span class=\"line\">console.log(obj); // &#123; a : 1, [Symbol(&quot;foo&quot;)]: 2 &#125; (cf. bug 1207182 on Firefox)</span><br><span class=\"line\">Object.getOwnPropertySymbols(obj); // [Symbol(foo)]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>原始类型会被包装为对象<blockquote>\n<p>Object.assign()会忽略null或undefined的源值，因为原始类型会被包装成对象，但是null和undefined无法转成对象，只有字符串的包装对象才可能有自身可枚举属性。包装后的对象属性值对应的键是它在源对象中的索引。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var v1 = &quot;abc&quot;;</span><br><span class=\"line\">var v2 = true;</span><br><span class=\"line\">var v3 = 10;</span><br><span class=\"line\">var v4 = Symbol(&quot;foo&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = Object.assign(&#123;&#125;, v1, null, v2, undefined, v3, v4); </span><br><span class=\"line\">// 原始类型会被包装，null 和 undefined 会被忽略。</span><br><span class=\"line\">// 注意，只有字符串的包装对象才可能有自身可枚举属性。</span><br><span class=\"line\">console.log(obj); // &#123; &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>继承属性和不可枚举属性不可拷贝<blockquote>\n<p>Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它是分配属性，而不仅仅是复制或定义新的属性。如果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = Object.create(&#123;foo: 1&#125;, &#123; // foo 是个继承属性。</span><br><span class=\"line\">    bar: &#123;</span><br><span class=\"line\">        value: 2  // bar 是个不可枚举属性。</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    baz: &#123;</span><br><span class=\"line\">        value: 3,</span><br><span class=\"line\">        enumerable: true  // baz 是个自身可枚举属性。</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">var copy = Object.assign(&#123;&#125;, obj);</span><br><span class=\"line\">console.log(copy); // &#123; baz: 3 &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>属性覆盖（可用来合并对象）<blockquote>\n<p>如果目标对象中的属性具有相同的键，则属性将被源中的属性覆盖。后来的源的属性将类似地覆盖早先的属性。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var o1 = &#123; a: 1, b: 1, c: 1 &#125;;</span><br><span class=\"line\">var o2 = &#123; b: 2, c: 2 &#125;;</span><br><span class=\"line\">var o3 = &#123; c: 3 &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj = Object.assign(&#123;&#125;, o1, o2, o3);</span><br><span class=\"line\">console.log(obj); // &#123; a: 1, b: 2, c: 3 &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>异常会打断后续拷贝任务<blockquote>\n<p>在出现错误的情况下，例如，如果属性不可写，会引发TypeError，如果在引发错误之前添加了任何属性，则可以更改target对象。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var target = Object.defineProperty(&#123;&#125;, &quot;foo&quot;, &#123;</span><br><span class=\"line\">    value: 1,</span><br><span class=\"line\">    writable: false</span><br><span class=\"line\">&#125;); // target 的 foo 属性是个只读属性。</span><br><span class=\"line\"></span><br><span class=\"line\">Object.assign(target, &#123;bar: 2&#125;, &#123;foo2: 3, foo: 3, foo3: 3&#125;, &#123;baz: 4&#125;);</span><br><span class=\"line\">// TypeError: &quot;foo&quot; is read-only</span><br><span class=\"line\">// 注意这个异常是在拷贝第二个源对象的第二个属性时发生的。</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(target.bar);  // 2，说明第一个源对象拷贝成功了。</span><br><span class=\"line\">console.log(target.foo2); // 3，说明第二个源对象的第一个属性也拷贝成功了。</span><br><span class=\"line\">console.log(target.foo);  // 1，只读属性不能被覆盖，所以第二个源对象的第二个属性拷贝失败了。</span><br><span class=\"line\">console.log(target.foo3); // undefined，异常之后 assign 方法就退出了，第三个属性是不会被拷贝到的。</span><br><span class=\"line\">console.log(target.baz);  // undefined，第三个源对象更是不会被拷贝到的。</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>深拷贝<blockquote>\n<p>上面也说了，浅复制复制的是引用类型的地址，并没有开辟新的内存空间，而深复制是开辟新的内存来存放新对象，源对象和新对象对应的是两个不同的地址，修改其中一个对象的属性，不会改变另外一个对象的属性。深复制的几种实现：</p>\n</blockquote>\n</li>\n</ol>\n<ul>\n<li><p>递归解析</p>\n<blockquote>\n<p>因为使用递归，性能会不如浅拷贝</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function deepCopy(src, res) &#123;</span><br><span class=\"line\">    var res = res || &#123;&#125;;</span><br><span class=\"line\">    for(var i in src) &#123;</span><br><span class=\"line\">        if(src.hasOwnProperty(i)) &#123;</span><br><span class=\"line\">            if(typeof src[i] === &apos;object&apos;) &#123;</span><br><span class=\"line\">                res[i] = (src[i].constructor === Array) ? [] : &#123;&#125;;</span><br><span class=\"line\">                deepCopy(src[i], res[i]);</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                res[i] = src[i];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return res;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj1 = &#123;&#125;;</span><br><span class=\"line\">deepCopy(obj, obj1);</span><br><span class=\"line\">obj1.age = 21;</span><br><span class=\"line\">obj1.like[1] = &apos;blue&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(obj); // &#123; name: &apos;miaorenjie&apos;, age: 20, like: [ &apos;black&apos;, &apos;white&apos; ] &#125;</span><br><span class=\"line\">console.log(obj1); // &#123; name: &apos;miaorenjie&apos;, age: 21, like: [ &apos;black&apos;, &apos;blue&apos; ] &#125;</span><br></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>JSON解析</p>\n<blockquote>\n<p>局限性：如果被拷贝的对象中有function，则拷贝之后的对象就会丢失这个function，原型链就没了；如果被拷贝的对象中有正则表达式，则拷贝之后的对象正则表达式会变成Object</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    name : &apos;miaorenjie&apos;,</span><br><span class=\"line\">    age: 20,</span><br><span class=\"line\">    like: [&apos;black&apos;, &apos;white&apos;]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var result = JSON.parse(JSON.stringify(obj));</span><br><span class=\"line\">result.age = 21;</span><br><span class=\"line\">result.name = &apos;young&apos;;</span><br><span class=\"line\">result.like.push(&apos;pink&apos;);</span><br><span class=\"line\">console.log(obj); // &#123; name: &apos;miaorenjie&apos;, age: 20, like: [ &apos;black&apos;, &apos;white&apos; ] &#125;</span><br><span class=\"line\">console.log(result); // &#123; name: &apos;young&apos;, age: 21, like: [ &apos;black&apos;, &apos;white&apos;, &apos;pink&apos; ] &#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Object.assign()（当对象只有一层的时候使用）<blockquote>\n<p>假如源对象的属性值不包含引用类型，那该方法返回的值就是一个与源对象相同但不在同一块内存的另一个对象，源对象和新对象的后续修改是互不影响的，也就是返回了源对象的深拷贝。</p>\n</blockquote>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">obj1 = &#123; a: 0 , b: &#123; c: 0&#125;&#125;;</span><br><span class=\"line\">let obj3 = JSON.parse(JSON.stringify(obj1));</span><br><span class=\"line\">obj1.a = 4;</span><br><span class=\"line\">obj1.b.c = 4;</span><br><span class=\"line\">console.log(JSON.stringify(obj3)); // &#123; a: 0, b: &#123; c: 0&#125;&#125;</span><br></pre></td></tr></table></figure>"},{"title":"浅谈Webpack工作流程","date":"2018-05-30T09:17:57.000Z","about":null,"_content":"### Webpack loader的设计原则\n> 所有模块都是js模块，其他类型的模块比如图片、css等都需要通过对应的loader转成js模块。所以，webpack中所有资源本质上都被当成js模块处理。\n> 所有的loader都是一个管道，入口是一个字符串，出口是另一个字符串，多个loader像水管一样串联起来。\n<!--more-->\n### webpack的工作流程\n![image](https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg)\n\n在webpack的源码里面，有两个webpack.js文件，一个在lib目录下，一个在bin目录下，bin目录下的是处理命令行相关的参数的，也就是我们通过命令行直接启动的入口，lib目录下的是webpack的逻辑入口。\n\n每次在命令行输入webpack后，操作系统都会去调用  ./node_modules/.bin/webpack 这个shell脚本。这个脚本会去调用 ./node_modules/webpack/bin/webpack.js  并追加输入的参数，如-p,-w。\n\n在webpack.js这个文件中webpack通过optimist将用户配置的webpack.config.js和shell脚本传过来的参数整合成options对象传到了下一个流程的控制对象中。\n\n#### optimist\noptimist实现了node命令行的解析，API调用也非常方便\n\n```\nvar optimist = require(\"optimist\");\n\noptimist\n  .boolean(\"json\").alias(\"json\", \"j\").describe(\"json\")\n  .boolean(\"colors\").alias(\"colors\", \"c\").describe(\"colors\")\n  .boolean(\"watch\").alias(\"watch\", \"w\").describe(\"watch\")\n  ...\n```\n获取到后缀参数之后，optimist分析参数并以键值对的形式把参数对象保存在optimist.argv中，argv中是这些东东：\n\n```\n// webpack --hot -w\n{\n    hot: true,\n    profile: false,\n    watch: true,\n    ...\n}\n```\n\n#### config合并与插件加载\n> 加载插件之前，webpack会将webpack.config.js中的各个配置项拷贝到options对象中，并加载用户配置在webpack.config.js的plugins。接着optimist.argv会被传入到./node_modules/webpack/bin/convert-argv.js中，通过判断argv中参数的值决定是否去加载对应插件\n\n```\nifBooleanArg(\"hot\", function() {\n    ensureArray(options, \"plugins\");\n    var HotModuleReplacementPlugin = require(\"../lib/HotModuleReplacementPlugin\");\n    options.plugins.push(new HotModuleReplacementPlugin());\n});\n...\nreturn options;\n```\noptions作为最后的返回值，包含了之后构建阶段所需要的重要信息\n\n```\n{ \n    entry: {},//入口配置\n    output: {}, //输出配置\n    plugins: [], //插件集合(配置文件 + shell指令) \n    module: { loaders: [ [Object] ] }, //模块配置\n    context: //工程路径\n    ... \n}\n```\n可以看到这或许和你自己的webpack.config.js有些相似，只是多传入了一些经shell传入的插件对象。插件对象初始化完毕之后，options也就传入到了下个流程。\n\n```\nvar webpack = require('../lib/webpack.js');\nvar compiler = webpack(options);\n```\n\n#### 编译与构建流程\n> 在加载配置文件和 shell 后缀参数申明的插件，并传入构建信息 options 对象后，开始整个 webpack 打包最漫长的一步。而这个时候，真正的 webpack 对象才刚被初始化。\n\ncompiler.run() 是webpack的实际入口，会启动自动编译，然后在不同的生命周期调用对应的插件（的回调函数），可以在 lib/webpack.js 中看到主要有以下的生命周期：\n>- beforeRun\n>- run\n>- emit // 把各个chunk输出到结果文件\n>- afterEmit // 完成输出\n>- beforeCompile\n>- compile // 开始进入编译环境\n>- make // 这里执行代码编译\n>- afterCompile // 这里根据编译结果合并出我们最终生成的文件名和文件内容\n>- watchRun // 这里控制台监听编译过程\n\n##### 1. 核心对象 Compilation\n> compiler.run后首先会触发compile，这一步会构建出Compilation对象，它是一个编译对象。\n\n> 一般都会有两个Compilation对象，一个负责组织打包过程，包含了每个构建环节以及输出环节所对应的方法，比如一些关键步骤：addEntry()，_addModuleChain()，buildMoudle()，seal()，createChunkAssets()（在每一个节点都会触发webpack事件去调用各插件）；另外一个包含了所有的module，chunk，生成的asset以及用来生成最后打包文件的template的信息。\n\n##### 2. 编译与构建主流程\n在创建 module 之前，Compiler 会触发 make，并调用 Compilation.addEntry 方法，通过 options 对象的 entry 字段找到我们的入口js文件。之后，addEntry 会调用 _addModuleChain 方法，最终经过几次调用后会进入到 NormalModule.js 中的 build 方法。而build又会先调用doBuild方法，对每一个require()用对应的loader进行加工，最后生成一个js module。\n\n```\ndoBuild(options, compilation, resolver, fs, callback) {\n\tconst loaderContext = this.createLoaderContext(\n\t\tresolver,\n\t\toptions,\n\t\tcompilation,\n\t\tfs\n\t);\n\n\trunLoaders({\n\t\tresource: this.resource,\n\t\tloaders: this.loaders,\n\t\tcontext: loaderContext,\n\t\treadResource: fs.readFile.bind(fs)\n\t},(err, result) => {\n\t\tif (result) {\n\t\t    // result是一个数组，数组的第一项就是编译后的代码，result的结果就是bable-loader返回的结果\n\t\t\tthis.buildInfo.cacheable = result.cacheable;\n\t\t\tthis.buildInfo.fileDependencies = new Set(result.fileDependencies);\n\t\t\tthis.buildInfo.contextDependencies = new Set(result.contextDependencies);\n\t\t}\n\n\t\tconst resourceBuffer = result.resourceBuffer;\n\t\tconst source = result.result[0]; // 这里是bable-loader编译后的代码\n\t\tconst sourceMap = result.result.length >= 1 ? result.result[1] : null;\n\t\tconst extraInfo = result.result.length >= 2 ? result.result[2] : null;\n\n        // this._source是一个对象，有name和value两个字段，name是文件路径，value是编译后的js代码\n\t\tthis._source = this.createSource(\n\t\t\tthis.binary ? asBuffer(source) : asString(source),\n\t\t\tresourceBuffer,\n\t\t\tsourceMap\n\t\t);\n\t\treturn callback();\n\t});\n}\n```\n可以看到，doBuild方法就是调用了相应的loader，把我们的模块转成标准的js模块，无论这个模块是js、css还是图片。也就是说，在webpack.config.js中配置的loader就是在这里调用的。不止是entry文件在这里调loader，它依赖的任何一个模块都会在这里调用，比如css模块，就会在这里调用对应的css-loader和style-loader把它转换成js对象。\n\n##### 3. 构建细节\n> 经过doBuild之后，我们的任何模块都转成了标准的js模块，下面就可以编译js了\n\n```\nbuild(options, compilation, resolver, fs, callback) {\n    // 变量初始化，省略\n    return this.doBuild(options, compilation, resolver, fs, err => {\n        this._cachedSources.clear();  // 清除缓存\n        // 由acorn解析生成ast\n        try {\n            // 源码经过loader编译已经成为标准的JS代码，下一步就是调用 parser.parse 对JS代码进行语法解析\n            const result = this.parser.parse(\n                this._ast || this._source.source(),\n                {\n                    current: this,\n                    module: this,\n                    compilation: compilation,\n                    options: options\n                },\n                (err, result) => {\n                    if (err) {\n                        handleParseError(err);\n                    } else {\n                        handleParseResult(result);\n                    }\n                }\n            );\n            if (result !== undefined) {\n                // parse is sync\n                handleParseResult(result);\n            }\n        } catch (e) {\n            handleParseError(e);\n        }\n    });\n}\n```\n那么再来看看parse.parse的代码：\n\n```\nparse(source, initialState) {\n    let ast = acorn.parse(source); // 调用 acorn 对JS进行语法解析，acorn 就是一个JS的 parser\n\n    const oldState = this.state;\n    const state = (this.state = initialState || {});\n    if (this.hooks.program.call(ast, comments) === undefined) {\n        this.prewalkStatements(ast.body);\n        this.walkStatements(ast.body);\n    }\n    this.state = oldState;\n    return state;\n}\n```\n解析完成之后接着会收集依赖，最终这些依赖都会被放到module.dependencies中。\n\n#### 打包输出\n在所有模块以及依赖模块build完成，收集完素有的依赖之后，最终又会回到compiler.js中的compile方法里，它会调用compilation.seal方法，seal方法会把所有依赖的模块都通过调用各插件对构建后的结果进行封装，要逐次对每个module和chunk进行整理，生成编译后的源码，合并、拆分、生成hash。\n\n> 封装过程中，webpack会调用Compilation中的createChunkAssets方法进行打包后代码的生成，流程如下： \n\n![](https://note.youdao.com/yws/public/resource/5f715a67310521eccbb0c9b4f0b22331/xmlnote/2559AC36AF3042C09B212C1EFB06EC8A/4517)\n\n从上图可以看到是通过判断是入口js还是需要异步加载js来选择不同的模板对象进行封装，入口js会采用webpack事件流的render事件来触发Template类中的renderChunkModules()（异步记载的js会调用chunkTemplate中的render方法）\n\n```\nif(chunk.entry) {\n    source = this.mainTemplate.render(this.hash, chunk, this.moduleTemplate, this.dependencyTemplates);\n} else {\n    source = this.chunkTemplate.render(chunk, this.moduleTemplate, this.dependencyTemplates);\n}\n```\n> 模块在封装的时候和它在构建时一样，都是调用各模块类中的方法。封装通过调用module.source()来进行各种操作，比如reuqire()的替换。\n\n```\nMainTemplate.prototype.requireFn = \"__webpack_require__\";\nMainTemplate.prototype.render = function(hash, chunk, moduleTemplate, dependencyTemplates) {\n    var buf = [];\n    // 每一个module都有一个moduleId,在最后会替换。\n    buf.push(\"function \" + this.requireFn + \"(moduleId) {\");\n    buf.push(this.indent(this.applyPluginsWaterfall(\"require\", \"\", chunk, hash)));\n    buf.push(\"}\");\n    buf.push(\"\");\n    ... // 其余封装操作\n};\n```\n> 各模块进行 doBlock 后，把 module 的最终代码循环添加到 source 中。一个 source 对应着一个 asset 对象，该对象保存了单个文件的文件名( name )和最终代码( value )。\n\n最后一步，webpack调用Compiler中的emitAssets()，按照output中的配置项将文件输出到了对应的path中，从而webpack整个打包过程结束。如果想对结果处理，需要对emit触发后对自定义插件进行扩展。\n\n## 流程总结\n1. 根据webpack.config.js的配置文件注册对应的插件\n2. 调用comiple.run进入编译阶段\n3. 在编译的第一阶段是Compilation，它会注册好不同类型的module对应的factory\n4. 进入make阶段，从entry开始两步走\n5. 第一步：调用loaders对模块的原始代码进行编译，转换成标准的js代码\n6. 第二步：调用acorn对js代码进行语法分析，然后收集其中的依赖关系。每个模块都会记录自己的依赖关系，从而形成一颗关系树\n7. 最后调用compilation.seal进入render阶段，根据之前收集的依赖，决定生成多少文件，每个文件的内容是什么","source":"_posts/浅谈Webpack工作流程.md","raw":"---\ntitle: 浅谈Webpack工作流程\ndate: 2018-05-30 17:17:57\ntags: \n- webpack\ncategories: 前端构建工具\nabout:\n---\n### Webpack loader的设计原则\n> 所有模块都是js模块，其他类型的模块比如图片、css等都需要通过对应的loader转成js模块。所以，webpack中所有资源本质上都被当成js模块处理。\n> 所有的loader都是一个管道，入口是一个字符串，出口是另一个字符串，多个loader像水管一样串联起来。\n<!--more-->\n### webpack的工作流程\n![image](https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg)\n\n在webpack的源码里面，有两个webpack.js文件，一个在lib目录下，一个在bin目录下，bin目录下的是处理命令行相关的参数的，也就是我们通过命令行直接启动的入口，lib目录下的是webpack的逻辑入口。\n\n每次在命令行输入webpack后，操作系统都会去调用  ./node_modules/.bin/webpack 这个shell脚本。这个脚本会去调用 ./node_modules/webpack/bin/webpack.js  并追加输入的参数，如-p,-w。\n\n在webpack.js这个文件中webpack通过optimist将用户配置的webpack.config.js和shell脚本传过来的参数整合成options对象传到了下一个流程的控制对象中。\n\n#### optimist\noptimist实现了node命令行的解析，API调用也非常方便\n\n```\nvar optimist = require(\"optimist\");\n\noptimist\n  .boolean(\"json\").alias(\"json\", \"j\").describe(\"json\")\n  .boolean(\"colors\").alias(\"colors\", \"c\").describe(\"colors\")\n  .boolean(\"watch\").alias(\"watch\", \"w\").describe(\"watch\")\n  ...\n```\n获取到后缀参数之后，optimist分析参数并以键值对的形式把参数对象保存在optimist.argv中，argv中是这些东东：\n\n```\n// webpack --hot -w\n{\n    hot: true,\n    profile: false,\n    watch: true,\n    ...\n}\n```\n\n#### config合并与插件加载\n> 加载插件之前，webpack会将webpack.config.js中的各个配置项拷贝到options对象中，并加载用户配置在webpack.config.js的plugins。接着optimist.argv会被传入到./node_modules/webpack/bin/convert-argv.js中，通过判断argv中参数的值决定是否去加载对应插件\n\n```\nifBooleanArg(\"hot\", function() {\n    ensureArray(options, \"plugins\");\n    var HotModuleReplacementPlugin = require(\"../lib/HotModuleReplacementPlugin\");\n    options.plugins.push(new HotModuleReplacementPlugin());\n});\n...\nreturn options;\n```\noptions作为最后的返回值，包含了之后构建阶段所需要的重要信息\n\n```\n{ \n    entry: {},//入口配置\n    output: {}, //输出配置\n    plugins: [], //插件集合(配置文件 + shell指令) \n    module: { loaders: [ [Object] ] }, //模块配置\n    context: //工程路径\n    ... \n}\n```\n可以看到这或许和你自己的webpack.config.js有些相似，只是多传入了一些经shell传入的插件对象。插件对象初始化完毕之后，options也就传入到了下个流程。\n\n```\nvar webpack = require('../lib/webpack.js');\nvar compiler = webpack(options);\n```\n\n#### 编译与构建流程\n> 在加载配置文件和 shell 后缀参数申明的插件，并传入构建信息 options 对象后，开始整个 webpack 打包最漫长的一步。而这个时候，真正的 webpack 对象才刚被初始化。\n\ncompiler.run() 是webpack的实际入口，会启动自动编译，然后在不同的生命周期调用对应的插件（的回调函数），可以在 lib/webpack.js 中看到主要有以下的生命周期：\n>- beforeRun\n>- run\n>- emit // 把各个chunk输出到结果文件\n>- afterEmit // 完成输出\n>- beforeCompile\n>- compile // 开始进入编译环境\n>- make // 这里执行代码编译\n>- afterCompile // 这里根据编译结果合并出我们最终生成的文件名和文件内容\n>- watchRun // 这里控制台监听编译过程\n\n##### 1. 核心对象 Compilation\n> compiler.run后首先会触发compile，这一步会构建出Compilation对象，它是一个编译对象。\n\n> 一般都会有两个Compilation对象，一个负责组织打包过程，包含了每个构建环节以及输出环节所对应的方法，比如一些关键步骤：addEntry()，_addModuleChain()，buildMoudle()，seal()，createChunkAssets()（在每一个节点都会触发webpack事件去调用各插件）；另外一个包含了所有的module，chunk，生成的asset以及用来生成最后打包文件的template的信息。\n\n##### 2. 编译与构建主流程\n在创建 module 之前，Compiler 会触发 make，并调用 Compilation.addEntry 方法，通过 options 对象的 entry 字段找到我们的入口js文件。之后，addEntry 会调用 _addModuleChain 方法，最终经过几次调用后会进入到 NormalModule.js 中的 build 方法。而build又会先调用doBuild方法，对每一个require()用对应的loader进行加工，最后生成一个js module。\n\n```\ndoBuild(options, compilation, resolver, fs, callback) {\n\tconst loaderContext = this.createLoaderContext(\n\t\tresolver,\n\t\toptions,\n\t\tcompilation,\n\t\tfs\n\t);\n\n\trunLoaders({\n\t\tresource: this.resource,\n\t\tloaders: this.loaders,\n\t\tcontext: loaderContext,\n\t\treadResource: fs.readFile.bind(fs)\n\t},(err, result) => {\n\t\tif (result) {\n\t\t    // result是一个数组，数组的第一项就是编译后的代码，result的结果就是bable-loader返回的结果\n\t\t\tthis.buildInfo.cacheable = result.cacheable;\n\t\t\tthis.buildInfo.fileDependencies = new Set(result.fileDependencies);\n\t\t\tthis.buildInfo.contextDependencies = new Set(result.contextDependencies);\n\t\t}\n\n\t\tconst resourceBuffer = result.resourceBuffer;\n\t\tconst source = result.result[0]; // 这里是bable-loader编译后的代码\n\t\tconst sourceMap = result.result.length >= 1 ? result.result[1] : null;\n\t\tconst extraInfo = result.result.length >= 2 ? result.result[2] : null;\n\n        // this._source是一个对象，有name和value两个字段，name是文件路径，value是编译后的js代码\n\t\tthis._source = this.createSource(\n\t\t\tthis.binary ? asBuffer(source) : asString(source),\n\t\t\tresourceBuffer,\n\t\t\tsourceMap\n\t\t);\n\t\treturn callback();\n\t});\n}\n```\n可以看到，doBuild方法就是调用了相应的loader，把我们的模块转成标准的js模块，无论这个模块是js、css还是图片。也就是说，在webpack.config.js中配置的loader就是在这里调用的。不止是entry文件在这里调loader，它依赖的任何一个模块都会在这里调用，比如css模块，就会在这里调用对应的css-loader和style-loader把它转换成js对象。\n\n##### 3. 构建细节\n> 经过doBuild之后，我们的任何模块都转成了标准的js模块，下面就可以编译js了\n\n```\nbuild(options, compilation, resolver, fs, callback) {\n    // 变量初始化，省略\n    return this.doBuild(options, compilation, resolver, fs, err => {\n        this._cachedSources.clear();  // 清除缓存\n        // 由acorn解析生成ast\n        try {\n            // 源码经过loader编译已经成为标准的JS代码，下一步就是调用 parser.parse 对JS代码进行语法解析\n            const result = this.parser.parse(\n                this._ast || this._source.source(),\n                {\n                    current: this,\n                    module: this,\n                    compilation: compilation,\n                    options: options\n                },\n                (err, result) => {\n                    if (err) {\n                        handleParseError(err);\n                    } else {\n                        handleParseResult(result);\n                    }\n                }\n            );\n            if (result !== undefined) {\n                // parse is sync\n                handleParseResult(result);\n            }\n        } catch (e) {\n            handleParseError(e);\n        }\n    });\n}\n```\n那么再来看看parse.parse的代码：\n\n```\nparse(source, initialState) {\n    let ast = acorn.parse(source); // 调用 acorn 对JS进行语法解析，acorn 就是一个JS的 parser\n\n    const oldState = this.state;\n    const state = (this.state = initialState || {});\n    if (this.hooks.program.call(ast, comments) === undefined) {\n        this.prewalkStatements(ast.body);\n        this.walkStatements(ast.body);\n    }\n    this.state = oldState;\n    return state;\n}\n```\n解析完成之后接着会收集依赖，最终这些依赖都会被放到module.dependencies中。\n\n#### 打包输出\n在所有模块以及依赖模块build完成，收集完素有的依赖之后，最终又会回到compiler.js中的compile方法里，它会调用compilation.seal方法，seal方法会把所有依赖的模块都通过调用各插件对构建后的结果进行封装，要逐次对每个module和chunk进行整理，生成编译后的源码，合并、拆分、生成hash。\n\n> 封装过程中，webpack会调用Compilation中的createChunkAssets方法进行打包后代码的生成，流程如下： \n\n![](https://note.youdao.com/yws/public/resource/5f715a67310521eccbb0c9b4f0b22331/xmlnote/2559AC36AF3042C09B212C1EFB06EC8A/4517)\n\n从上图可以看到是通过判断是入口js还是需要异步加载js来选择不同的模板对象进行封装，入口js会采用webpack事件流的render事件来触发Template类中的renderChunkModules()（异步记载的js会调用chunkTemplate中的render方法）\n\n```\nif(chunk.entry) {\n    source = this.mainTemplate.render(this.hash, chunk, this.moduleTemplate, this.dependencyTemplates);\n} else {\n    source = this.chunkTemplate.render(chunk, this.moduleTemplate, this.dependencyTemplates);\n}\n```\n> 模块在封装的时候和它在构建时一样，都是调用各模块类中的方法。封装通过调用module.source()来进行各种操作，比如reuqire()的替换。\n\n```\nMainTemplate.prototype.requireFn = \"__webpack_require__\";\nMainTemplate.prototype.render = function(hash, chunk, moduleTemplate, dependencyTemplates) {\n    var buf = [];\n    // 每一个module都有一个moduleId,在最后会替换。\n    buf.push(\"function \" + this.requireFn + \"(moduleId) {\");\n    buf.push(this.indent(this.applyPluginsWaterfall(\"require\", \"\", chunk, hash)));\n    buf.push(\"}\");\n    buf.push(\"\");\n    ... // 其余封装操作\n};\n```\n> 各模块进行 doBlock 后，把 module 的最终代码循环添加到 source 中。一个 source 对应着一个 asset 对象，该对象保存了单个文件的文件名( name )和最终代码( value )。\n\n最后一步，webpack调用Compiler中的emitAssets()，按照output中的配置项将文件输出到了对应的path中，从而webpack整个打包过程结束。如果想对结果处理，需要对emit触发后对自定义插件进行扩展。\n\n## 流程总结\n1. 根据webpack.config.js的配置文件注册对应的插件\n2. 调用comiple.run进入编译阶段\n3. 在编译的第一阶段是Compilation，它会注册好不同类型的module对应的factory\n4. 进入make阶段，从entry开始两步走\n5. 第一步：调用loaders对模块的原始代码进行编译，转换成标准的js代码\n6. 第二步：调用acorn对js代码进行语法分析，然后收集其中的依赖关系。每个模块都会记录自己的依赖关系，从而形成一颗关系树\n7. 最后调用compilation.seal进入render阶段，根据之前收集的依赖，决定生成多少文件，每个文件的内容是什么","slug":"浅谈Webpack工作流程","published":1,"updated":"2019-02-22T08:37:33.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjsfugrpd002nvrie7qgpgoy3","content":"<h3 id=\"Webpack-loader的设计原则\"><a href=\"#Webpack-loader的设计原则\" class=\"headerlink\" title=\"Webpack loader的设计原则\"></a>Webpack loader的设计原则</h3><blockquote>\n<p>所有模块都是js模块，其他类型的模块比如图片、css等都需要通过对应的loader转成js模块。所以，webpack中所有资源本质上都被当成js模块处理。<br>所有的loader都是一个管道，入口是一个字符串，出口是另一个字符串，多个loader像水管一样串联起来。<br><a id=\"more\"></a></p>\n</blockquote>\n<h3 id=\"webpack的工作流程\"><a href=\"#webpack的工作流程\" class=\"headerlink\" title=\"webpack的工作流程\"></a>webpack的工作流程</h3><p><img src=\"https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg\" alt=\"image\"></p>\n<p>在webpack的源码里面，有两个webpack.js文件，一个在lib目录下，一个在bin目录下，bin目录下的是处理命令行相关的参数的，也就是我们通过命令行直接启动的入口，lib目录下的是webpack的逻辑入口。</p>\n<p>每次在命令行输入webpack后，操作系统都会去调用  ./node_modules/.bin/webpack 这个shell脚本。这个脚本会去调用 ./node_modules/webpack/bin/webpack.js  并追加输入的参数，如-p,-w。</p>\n<p>在webpack.js这个文件中webpack通过optimist将用户配置的webpack.config.js和shell脚本传过来的参数整合成options对象传到了下一个流程的控制对象中。</p>\n<h4 id=\"optimist\"><a href=\"#optimist\" class=\"headerlink\" title=\"optimist\"></a>optimist</h4><p>optimist实现了node命令行的解析，API调用也非常方便</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var optimist = require(&quot;optimist&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">optimist</span><br><span class=\"line\">  .boolean(&quot;json&quot;).alias(&quot;json&quot;, &quot;j&quot;).describe(&quot;json&quot;)</span><br><span class=\"line\">  .boolean(&quot;colors&quot;).alias(&quot;colors&quot;, &quot;c&quot;).describe(&quot;colors&quot;)</span><br><span class=\"line\">  .boolean(&quot;watch&quot;).alias(&quot;watch&quot;, &quot;w&quot;).describe(&quot;watch&quot;)</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n<p>获取到后缀参数之后，optimist分析参数并以键值对的形式把参数对象保存在optimist.argv中，argv中是这些东东：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// webpack --hot -w</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    hot: true,</span><br><span class=\"line\">    profile: false,</span><br><span class=\"line\">    watch: true,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"config合并与插件加载\"><a href=\"#config合并与插件加载\" class=\"headerlink\" title=\"config合并与插件加载\"></a>config合并与插件加载</h4><blockquote>\n<p>加载插件之前，webpack会将webpack.config.js中的各个配置项拷贝到options对象中，并加载用户配置在webpack.config.js的plugins。接着optimist.argv会被传入到./node_modules/webpack/bin/convert-argv.js中，通过判断argv中参数的值决定是否去加载对应插件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifBooleanArg(&quot;hot&quot;, function() &#123;</span><br><span class=\"line\">    ensureArray(options, &quot;plugins&quot;);</span><br><span class=\"line\">    var HotModuleReplacementPlugin = require(&quot;../lib/HotModuleReplacementPlugin&quot;);</span><br><span class=\"line\">    options.plugins.push(new HotModuleReplacementPlugin());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">...</span><br><span class=\"line\">return options;</span><br></pre></td></tr></table></figure>\n<p>options作为最后的返回值，包含了之后构建阶段所需要的重要信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    entry: &#123;&#125;,//入口配置</span><br><span class=\"line\">    output: &#123;&#125;, //输出配置</span><br><span class=\"line\">    plugins: [], //插件集合(配置文件 + shell指令) </span><br><span class=\"line\">    module: &#123; loaders: [ [Object] ] &#125;, //模块配置</span><br><span class=\"line\">    context: //工程路径</span><br><span class=\"line\">    ... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这或许和你自己的webpack.config.js有些相似，只是多传入了一些经shell传入的插件对象。插件对象初始化完毕之后，options也就传入到了下个流程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var webpack = require(&apos;../lib/webpack.js&apos;);</span><br><span class=\"line\">var compiler = webpack(options);</span><br></pre></td></tr></table></figure>\n<h4 id=\"编译与构建流程\"><a href=\"#编译与构建流程\" class=\"headerlink\" title=\"编译与构建流程\"></a>编译与构建流程</h4><blockquote>\n<p>在加载配置文件和 shell 后缀参数申明的插件，并传入构建信息 options 对象后，开始整个 webpack 打包最漫长的一步。而这个时候，真正的 webpack 对象才刚被初始化。</p>\n</blockquote>\n<p>compiler.run() 是webpack的实际入口，会启动自动编译，然后在不同的生命周期调用对应的插件（的回调函数），可以在 lib/webpack.js 中看到主要有以下的生命周期：</p>\n<blockquote>\n<ul>\n<li>beforeRun</li>\n<li>run</li>\n<li>emit // 把各个chunk输出到结果文件</li>\n<li>afterEmit // 完成输出</li>\n<li>beforeCompile</li>\n<li>compile // 开始进入编译环境</li>\n<li>make // 这里执行代码编译</li>\n<li>afterCompile // 这里根据编译结果合并出我们最终生成的文件名和文件内容</li>\n<li>watchRun // 这里控制台监听编译过程</li>\n</ul>\n</blockquote>\n<h5 id=\"1-核心对象-Compilation\"><a href=\"#1-核心对象-Compilation\" class=\"headerlink\" title=\"1. 核心对象 Compilation\"></a>1. 核心对象 Compilation</h5><blockquote>\n<p>compiler.run后首先会触发compile，这一步会构建出Compilation对象，它是一个编译对象。</p>\n</blockquote>\n<blockquote>\n<p>一般都会有两个Compilation对象，一个负责组织打包过程，包含了每个构建环节以及输出环节所对应的方法，比如一些关键步骤：addEntry()，_addModuleChain()，buildMoudle()，seal()，createChunkAssets()（在每一个节点都会触发webpack事件去调用各插件）；另外一个包含了所有的module，chunk，生成的asset以及用来生成最后打包文件的template的信息。</p>\n</blockquote>\n<h5 id=\"2-编译与构建主流程\"><a href=\"#2-编译与构建主流程\" class=\"headerlink\" title=\"2. 编译与构建主流程\"></a>2. 编译与构建主流程</h5><p>在创建 module 之前，Compiler 会触发 make，并调用 Compilation.addEntry 方法，通过 options 对象的 entry 字段找到我们的入口js文件。之后，addEntry 会调用 _addModuleChain 方法，最终经过几次调用后会进入到 NormalModule.js 中的 build 方法。而build又会先调用doBuild方法，对每一个require()用对应的loader进行加工，最后生成一个js module。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doBuild(options, compilation, resolver, fs, callback) &#123;</span><br><span class=\"line\">\tconst loaderContext = this.createLoaderContext(</span><br><span class=\"line\">\t\tresolver,</span><br><span class=\"line\">\t\toptions,</span><br><span class=\"line\">\t\tcompilation,</span><br><span class=\"line\">\t\tfs</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\trunLoaders(&#123;</span><br><span class=\"line\">\t\tresource: this.resource,</span><br><span class=\"line\">\t\tloaders: this.loaders,</span><br><span class=\"line\">\t\tcontext: loaderContext,</span><br><span class=\"line\">\t\treadResource: fs.readFile.bind(fs)</span><br><span class=\"line\">\t&#125;,(err, result) =&gt; &#123;</span><br><span class=\"line\">\t\tif (result) &#123;</span><br><span class=\"line\">\t\t    // result是一个数组，数组的第一项就是编译后的代码，result的结果就是bable-loader返回的结果</span><br><span class=\"line\">\t\t\tthis.buildInfo.cacheable = result.cacheable;</span><br><span class=\"line\">\t\t\tthis.buildInfo.fileDependencies = new Set(result.fileDependencies);</span><br><span class=\"line\">\t\t\tthis.buildInfo.contextDependencies = new Set(result.contextDependencies);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tconst resourceBuffer = result.resourceBuffer;</span><br><span class=\"line\">\t\tconst source = result.result[0]; // 这里是bable-loader编译后的代码</span><br><span class=\"line\">\t\tconst sourceMap = result.result.length &gt;= 1 ? result.result[1] : null;</span><br><span class=\"line\">\t\tconst extraInfo = result.result.length &gt;= 2 ? result.result[2] : null;</span><br><span class=\"line\"></span><br><span class=\"line\">        // this._source是一个对象，有name和value两个字段，name是文件路径，value是编译后的js代码</span><br><span class=\"line\">\t\tthis._source = this.createSource(</span><br><span class=\"line\">\t\t\tthis.binary ? asBuffer(source) : asString(source),</span><br><span class=\"line\">\t\t\tresourceBuffer,</span><br><span class=\"line\">\t\t\tsourceMap</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t\treturn callback();</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，doBuild方法就是调用了相应的loader，把我们的模块转成标准的js模块，无论这个模块是js、css还是图片。也就是说，在webpack.config.js中配置的loader就是在这里调用的。不止是entry文件在这里调loader，它依赖的任何一个模块都会在这里调用，比如css模块，就会在这里调用对应的css-loader和style-loader把它转换成js对象。</p>\n<h5 id=\"3-构建细节\"><a href=\"#3-构建细节\" class=\"headerlink\" title=\"3. 构建细节\"></a>3. 构建细节</h5><blockquote>\n<p>经过doBuild之后，我们的任何模块都转成了标准的js模块，下面就可以编译js了</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build(options, compilation, resolver, fs, callback) &#123;</span><br><span class=\"line\">    // 变量初始化，省略</span><br><span class=\"line\">    return this.doBuild(options, compilation, resolver, fs, err =&gt; &#123;</span><br><span class=\"line\">        this._cachedSources.clear();  // 清除缓存</span><br><span class=\"line\">        // 由acorn解析生成ast</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // 源码经过loader编译已经成为标准的JS代码，下一步就是调用 parser.parse 对JS代码进行语法解析</span><br><span class=\"line\">            const result = this.parser.parse(</span><br><span class=\"line\">                this._ast || this._source.source(),</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    current: this,</span><br><span class=\"line\">                    module: this,</span><br><span class=\"line\">                    compilation: compilation,</span><br><span class=\"line\">                    options: options</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                (err, result) =&gt; &#123;</span><br><span class=\"line\">                    if (err) &#123;</span><br><span class=\"line\">                        handleParseError(err);</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        handleParseResult(result);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            );</span><br><span class=\"line\">            if (result !== undefined) &#123;</span><br><span class=\"line\">                // parse is sync</span><br><span class=\"line\">                handleParseResult(result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (e) &#123;</span><br><span class=\"line\">            handleParseError(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么再来看看parse.parse的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parse(source, initialState) &#123;</span><br><span class=\"line\">    let ast = acorn.parse(source); // 调用 acorn 对JS进行语法解析，acorn 就是一个JS的 parser</span><br><span class=\"line\"></span><br><span class=\"line\">    const oldState = this.state;</span><br><span class=\"line\">    const state = (this.state = initialState || &#123;&#125;);</span><br><span class=\"line\">    if (this.hooks.program.call(ast, comments) === undefined) &#123;</span><br><span class=\"line\">        this.prewalkStatements(ast.body);</span><br><span class=\"line\">        this.walkStatements(ast.body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.state = oldState;</span><br><span class=\"line\">    return state;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解析完成之后接着会收集依赖，最终这些依赖都会被放到module.dependencies中。</p>\n<h4 id=\"打包输出\"><a href=\"#打包输出\" class=\"headerlink\" title=\"打包输出\"></a>打包输出</h4><p>在所有模块以及依赖模块build完成，收集完素有的依赖之后，最终又会回到compiler.js中的compile方法里，它会调用compilation.seal方法，seal方法会把所有依赖的模块都通过调用各插件对构建后的结果进行封装，要逐次对每个module和chunk进行整理，生成编译后的源码，合并、拆分、生成hash。</p>\n<blockquote>\n<p>封装过程中，webpack会调用Compilation中的createChunkAssets方法进行打包后代码的生成，流程如下： </p>\n</blockquote>\n<p><img src=\"https://note.youdao.com/yws/public/resource/5f715a67310521eccbb0c9b4f0b22331/xmlnote/2559AC36AF3042C09B212C1EFB06EC8A/4517\" alt></p>\n<p>从上图可以看到是通过判断是入口js还是需要异步加载js来选择不同的模板对象进行封装，入口js会采用webpack事件流的render事件来触发Template类中的renderChunkModules()（异步记载的js会调用chunkTemplate中的render方法）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(chunk.entry) &#123;</span><br><span class=\"line\">    source = this.mainTemplate.render(this.hash, chunk, this.moduleTemplate, this.dependencyTemplates);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    source = this.chunkTemplate.render(chunk, this.moduleTemplate, this.dependencyTemplates);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>模块在封装的时候和它在构建时一样，都是调用各模块类中的方法。封装通过调用module.source()来进行各种操作，比如reuqire()的替换。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MainTemplate.prototype.requireFn = &quot;__webpack_require__&quot;;</span><br><span class=\"line\">MainTemplate.prototype.render = function(hash, chunk, moduleTemplate, dependencyTemplates) &#123;</span><br><span class=\"line\">    var buf = [];</span><br><span class=\"line\">    // 每一个module都有一个moduleId,在最后会替换。</span><br><span class=\"line\">    buf.push(&quot;function &quot; + this.requireFn + &quot;(moduleId) &#123;&quot;);</span><br><span class=\"line\">    buf.push(this.indent(this.applyPluginsWaterfall(&quot;require&quot;, &quot;&quot;, chunk, hash)));</span><br><span class=\"line\">    buf.push(&quot;&#125;&quot;);</span><br><span class=\"line\">    buf.push(&quot;&quot;);</span><br><span class=\"line\">    ... // 其余封装操作</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>各模块进行 doBlock 后，把 module 的最终代码循环添加到 source 中。一个 source 对应着一个 asset 对象，该对象保存了单个文件的文件名( name )和最终代码( value )。</p>\n</blockquote>\n<p>最后一步，webpack调用Compiler中的emitAssets()，按照output中的配置项将文件输出到了对应的path中，从而webpack整个打包过程结束。如果想对结果处理，需要对emit触发后对自定义插件进行扩展。</p>\n<h2 id=\"流程总结\"><a href=\"#流程总结\" class=\"headerlink\" title=\"流程总结\"></a>流程总结</h2><ol>\n<li>根据webpack.config.js的配置文件注册对应的插件</li>\n<li>调用comiple.run进入编译阶段</li>\n<li>在编译的第一阶段是Compilation，它会注册好不同类型的module对应的factory</li>\n<li>进入make阶段，从entry开始两步走</li>\n<li>第一步：调用loaders对模块的原始代码进行编译，转换成标准的js代码</li>\n<li>第二步：调用acorn对js代码进行语法分析，然后收集其中的依赖关系。每个模块都会记录自己的依赖关系，从而形成一颗关系树</li>\n<li>最后调用compilation.seal进入render阶段，根据之前收集的依赖，决定生成多少文件，每个文件的内容是什么</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"Webpack-loader的设计原则\"><a href=\"#Webpack-loader的设计原则\" class=\"headerlink\" title=\"Webpack loader的设计原则\"></a>Webpack loader的设计原则</h3><blockquote>\n<p>所有模块都是js模块，其他类型的模块比如图片、css等都需要通过对应的loader转成js模块。所以，webpack中所有资源本质上都被当成js模块处理。<br>所有的loader都是一个管道，入口是一个字符串，出口是另一个字符串，多个loader像水管一样串联起来。<br>","more":"</p>\n</blockquote>\n<h3 id=\"webpack的工作流程\"><a href=\"#webpack的工作流程\" class=\"headerlink\" title=\"webpack的工作流程\"></a>webpack的工作流程</h3><p><img src=\"https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg\" alt=\"image\"></p>\n<p>在webpack的源码里面，有两个webpack.js文件，一个在lib目录下，一个在bin目录下，bin目录下的是处理命令行相关的参数的，也就是我们通过命令行直接启动的入口，lib目录下的是webpack的逻辑入口。</p>\n<p>每次在命令行输入webpack后，操作系统都会去调用  ./node_modules/.bin/webpack 这个shell脚本。这个脚本会去调用 ./node_modules/webpack/bin/webpack.js  并追加输入的参数，如-p,-w。</p>\n<p>在webpack.js这个文件中webpack通过optimist将用户配置的webpack.config.js和shell脚本传过来的参数整合成options对象传到了下一个流程的控制对象中。</p>\n<h4 id=\"optimist\"><a href=\"#optimist\" class=\"headerlink\" title=\"optimist\"></a>optimist</h4><p>optimist实现了node命令行的解析，API调用也非常方便</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var optimist = require(&quot;optimist&quot;);</span><br><span class=\"line\"></span><br><span class=\"line\">optimist</span><br><span class=\"line\">  .boolean(&quot;json&quot;).alias(&quot;json&quot;, &quot;j&quot;).describe(&quot;json&quot;)</span><br><span class=\"line\">  .boolean(&quot;colors&quot;).alias(&quot;colors&quot;, &quot;c&quot;).describe(&quot;colors&quot;)</span><br><span class=\"line\">  .boolean(&quot;watch&quot;).alias(&quot;watch&quot;, &quot;w&quot;).describe(&quot;watch&quot;)</span><br><span class=\"line\">  ...</span><br></pre></td></tr></table></figure>\n<p>获取到后缀参数之后，optimist分析参数并以键值对的形式把参数对象保存在optimist.argv中，argv中是这些东东：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// webpack --hot -w</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    hot: true,</span><br><span class=\"line\">    profile: false,</span><br><span class=\"line\">    watch: true,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"config合并与插件加载\"><a href=\"#config合并与插件加载\" class=\"headerlink\" title=\"config合并与插件加载\"></a>config合并与插件加载</h4><blockquote>\n<p>加载插件之前，webpack会将webpack.config.js中的各个配置项拷贝到options对象中，并加载用户配置在webpack.config.js的plugins。接着optimist.argv会被传入到./node_modules/webpack/bin/convert-argv.js中，通过判断argv中参数的值决定是否去加载对应插件</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ifBooleanArg(&quot;hot&quot;, function() &#123;</span><br><span class=\"line\">    ensureArray(options, &quot;plugins&quot;);</span><br><span class=\"line\">    var HotModuleReplacementPlugin = require(&quot;../lib/HotModuleReplacementPlugin&quot;);</span><br><span class=\"line\">    options.plugins.push(new HotModuleReplacementPlugin());</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">...</span><br><span class=\"line\">return options;</span><br></pre></td></tr></table></figure>\n<p>options作为最后的返回值，包含了之后构建阶段所需要的重要信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123; </span><br><span class=\"line\">    entry: &#123;&#125;,//入口配置</span><br><span class=\"line\">    output: &#123;&#125;, //输出配置</span><br><span class=\"line\">    plugins: [], //插件集合(配置文件 + shell指令) </span><br><span class=\"line\">    module: &#123; loaders: [ [Object] ] &#125;, //模块配置</span><br><span class=\"line\">    context: //工程路径</span><br><span class=\"line\">    ... </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到这或许和你自己的webpack.config.js有些相似，只是多传入了一些经shell传入的插件对象。插件对象初始化完毕之后，options也就传入到了下个流程。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var webpack = require(&apos;../lib/webpack.js&apos;);</span><br><span class=\"line\">var compiler = webpack(options);</span><br></pre></td></tr></table></figure>\n<h4 id=\"编译与构建流程\"><a href=\"#编译与构建流程\" class=\"headerlink\" title=\"编译与构建流程\"></a>编译与构建流程</h4><blockquote>\n<p>在加载配置文件和 shell 后缀参数申明的插件，并传入构建信息 options 对象后，开始整个 webpack 打包最漫长的一步。而这个时候，真正的 webpack 对象才刚被初始化。</p>\n</blockquote>\n<p>compiler.run() 是webpack的实际入口，会启动自动编译，然后在不同的生命周期调用对应的插件（的回调函数），可以在 lib/webpack.js 中看到主要有以下的生命周期：</p>\n<blockquote>\n<ul>\n<li>beforeRun</li>\n<li>run</li>\n<li>emit // 把各个chunk输出到结果文件</li>\n<li>afterEmit // 完成输出</li>\n<li>beforeCompile</li>\n<li>compile // 开始进入编译环境</li>\n<li>make // 这里执行代码编译</li>\n<li>afterCompile // 这里根据编译结果合并出我们最终生成的文件名和文件内容</li>\n<li>watchRun // 这里控制台监听编译过程</li>\n</ul>\n</blockquote>\n<h5 id=\"1-核心对象-Compilation\"><a href=\"#1-核心对象-Compilation\" class=\"headerlink\" title=\"1. 核心对象 Compilation\"></a>1. 核心对象 Compilation</h5><blockquote>\n<p>compiler.run后首先会触发compile，这一步会构建出Compilation对象，它是一个编译对象。</p>\n</blockquote>\n<blockquote>\n<p>一般都会有两个Compilation对象，一个负责组织打包过程，包含了每个构建环节以及输出环节所对应的方法，比如一些关键步骤：addEntry()，_addModuleChain()，buildMoudle()，seal()，createChunkAssets()（在每一个节点都会触发webpack事件去调用各插件）；另外一个包含了所有的module，chunk，生成的asset以及用来生成最后打包文件的template的信息。</p>\n</blockquote>\n<h5 id=\"2-编译与构建主流程\"><a href=\"#2-编译与构建主流程\" class=\"headerlink\" title=\"2. 编译与构建主流程\"></a>2. 编译与构建主流程</h5><p>在创建 module 之前，Compiler 会触发 make，并调用 Compilation.addEntry 方法，通过 options 对象的 entry 字段找到我们的入口js文件。之后，addEntry 会调用 _addModuleChain 方法，最终经过几次调用后会进入到 NormalModule.js 中的 build 方法。而build又会先调用doBuild方法，对每一个require()用对应的loader进行加工，最后生成一个js module。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">doBuild(options, compilation, resolver, fs, callback) &#123;</span><br><span class=\"line\">\tconst loaderContext = this.createLoaderContext(</span><br><span class=\"line\">\t\tresolver,</span><br><span class=\"line\">\t\toptions,</span><br><span class=\"line\">\t\tcompilation,</span><br><span class=\"line\">\t\tfs</span><br><span class=\"line\">\t);</span><br><span class=\"line\"></span><br><span class=\"line\">\trunLoaders(&#123;</span><br><span class=\"line\">\t\tresource: this.resource,</span><br><span class=\"line\">\t\tloaders: this.loaders,</span><br><span class=\"line\">\t\tcontext: loaderContext,</span><br><span class=\"line\">\t\treadResource: fs.readFile.bind(fs)</span><br><span class=\"line\">\t&#125;,(err, result) =&gt; &#123;</span><br><span class=\"line\">\t\tif (result) &#123;</span><br><span class=\"line\">\t\t    // result是一个数组，数组的第一项就是编译后的代码，result的结果就是bable-loader返回的结果</span><br><span class=\"line\">\t\t\tthis.buildInfo.cacheable = result.cacheable;</span><br><span class=\"line\">\t\t\tthis.buildInfo.fileDependencies = new Set(result.fileDependencies);</span><br><span class=\"line\">\t\t\tthis.buildInfo.contextDependencies = new Set(result.contextDependencies);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tconst resourceBuffer = result.resourceBuffer;</span><br><span class=\"line\">\t\tconst source = result.result[0]; // 这里是bable-loader编译后的代码</span><br><span class=\"line\">\t\tconst sourceMap = result.result.length &gt;= 1 ? result.result[1] : null;</span><br><span class=\"line\">\t\tconst extraInfo = result.result.length &gt;= 2 ? result.result[2] : null;</span><br><span class=\"line\"></span><br><span class=\"line\">        // this._source是一个对象，有name和value两个字段，name是文件路径，value是编译后的js代码</span><br><span class=\"line\">\t\tthis._source = this.createSource(</span><br><span class=\"line\">\t\t\tthis.binary ? asBuffer(source) : asString(source),</span><br><span class=\"line\">\t\t\tresourceBuffer,</span><br><span class=\"line\">\t\t\tsourceMap</span><br><span class=\"line\">\t\t);</span><br><span class=\"line\">\t\treturn callback();</span><br><span class=\"line\">\t&#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>可以看到，doBuild方法就是调用了相应的loader，把我们的模块转成标准的js模块，无论这个模块是js、css还是图片。也就是说，在webpack.config.js中配置的loader就是在这里调用的。不止是entry文件在这里调loader，它依赖的任何一个模块都会在这里调用，比如css模块，就会在这里调用对应的css-loader和style-loader把它转换成js对象。</p>\n<h5 id=\"3-构建细节\"><a href=\"#3-构建细节\" class=\"headerlink\" title=\"3. 构建细节\"></a>3. 构建细节</h5><blockquote>\n<p>经过doBuild之后，我们的任何模块都转成了标准的js模块，下面就可以编译js了</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">build(options, compilation, resolver, fs, callback) &#123;</span><br><span class=\"line\">    // 变量初始化，省略</span><br><span class=\"line\">    return this.doBuild(options, compilation, resolver, fs, err =&gt; &#123;</span><br><span class=\"line\">        this._cachedSources.clear();  // 清除缓存</span><br><span class=\"line\">        // 由acorn解析生成ast</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            // 源码经过loader编译已经成为标准的JS代码，下一步就是调用 parser.parse 对JS代码进行语法解析</span><br><span class=\"line\">            const result = this.parser.parse(</span><br><span class=\"line\">                this._ast || this._source.source(),</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    current: this,</span><br><span class=\"line\">                    module: this,</span><br><span class=\"line\">                    compilation: compilation,</span><br><span class=\"line\">                    options: options</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                (err, result) =&gt; &#123;</span><br><span class=\"line\">                    if (err) &#123;</span><br><span class=\"line\">                        handleParseError(err);</span><br><span class=\"line\">                    &#125; else &#123;</span><br><span class=\"line\">                        handleParseResult(result);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            );</span><br><span class=\"line\">            if (result !== undefined) &#123;</span><br><span class=\"line\">                // parse is sync</span><br><span class=\"line\">                handleParseResult(result);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; catch (e) &#123;</span><br><span class=\"line\">            handleParseError(e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>那么再来看看parse.parse的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">parse(source, initialState) &#123;</span><br><span class=\"line\">    let ast = acorn.parse(source); // 调用 acorn 对JS进行语法解析，acorn 就是一个JS的 parser</span><br><span class=\"line\"></span><br><span class=\"line\">    const oldState = this.state;</span><br><span class=\"line\">    const state = (this.state = initialState || &#123;&#125;);</span><br><span class=\"line\">    if (this.hooks.program.call(ast, comments) === undefined) &#123;</span><br><span class=\"line\">        this.prewalkStatements(ast.body);</span><br><span class=\"line\">        this.walkStatements(ast.body);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    this.state = oldState;</span><br><span class=\"line\">    return state;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>解析完成之后接着会收集依赖，最终这些依赖都会被放到module.dependencies中。</p>\n<h4 id=\"打包输出\"><a href=\"#打包输出\" class=\"headerlink\" title=\"打包输出\"></a>打包输出</h4><p>在所有模块以及依赖模块build完成，收集完素有的依赖之后，最终又会回到compiler.js中的compile方法里，它会调用compilation.seal方法，seal方法会把所有依赖的模块都通过调用各插件对构建后的结果进行封装，要逐次对每个module和chunk进行整理，生成编译后的源码，合并、拆分、生成hash。</p>\n<blockquote>\n<p>封装过程中，webpack会调用Compilation中的createChunkAssets方法进行打包后代码的生成，流程如下： </p>\n</blockquote>\n<p><img src=\"https://note.youdao.com/yws/public/resource/5f715a67310521eccbb0c9b4f0b22331/xmlnote/2559AC36AF3042C09B212C1EFB06EC8A/4517\" alt></p>\n<p>从上图可以看到是通过判断是入口js还是需要异步加载js来选择不同的模板对象进行封装，入口js会采用webpack事件流的render事件来触发Template类中的renderChunkModules()（异步记载的js会调用chunkTemplate中的render方法）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(chunk.entry) &#123;</span><br><span class=\"line\">    source = this.mainTemplate.render(this.hash, chunk, this.moduleTemplate, this.dependencyTemplates);</span><br><span class=\"line\">&#125; else &#123;</span><br><span class=\"line\">    source = this.chunkTemplate.render(chunk, this.moduleTemplate, this.dependencyTemplates);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>模块在封装的时候和它在构建时一样，都是调用各模块类中的方法。封装通过调用module.source()来进行各种操作，比如reuqire()的替换。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MainTemplate.prototype.requireFn = &quot;__webpack_require__&quot;;</span><br><span class=\"line\">MainTemplate.prototype.render = function(hash, chunk, moduleTemplate, dependencyTemplates) &#123;</span><br><span class=\"line\">    var buf = [];</span><br><span class=\"line\">    // 每一个module都有一个moduleId,在最后会替换。</span><br><span class=\"line\">    buf.push(&quot;function &quot; + this.requireFn + &quot;(moduleId) &#123;&quot;);</span><br><span class=\"line\">    buf.push(this.indent(this.applyPluginsWaterfall(&quot;require&quot;, &quot;&quot;, chunk, hash)));</span><br><span class=\"line\">    buf.push(&quot;&#125;&quot;);</span><br><span class=\"line\">    buf.push(&quot;&quot;);</span><br><span class=\"line\">    ... // 其余封装操作</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>各模块进行 doBlock 后，把 module 的最终代码循环添加到 source 中。一个 source 对应着一个 asset 对象，该对象保存了单个文件的文件名( name )和最终代码( value )。</p>\n</blockquote>\n<p>最后一步，webpack调用Compiler中的emitAssets()，按照output中的配置项将文件输出到了对应的path中，从而webpack整个打包过程结束。如果想对结果处理，需要对emit触发后对自定义插件进行扩展。</p>\n<h2 id=\"流程总结\"><a href=\"#流程总结\" class=\"headerlink\" title=\"流程总结\"></a>流程总结</h2><ol>\n<li>根据webpack.config.js的配置文件注册对应的插件</li>\n<li>调用comiple.run进入编译阶段</li>\n<li>在编译的第一阶段是Compilation，它会注册好不同类型的module对应的factory</li>\n<li>进入make阶段，从entry开始两步走</li>\n<li>第一步：调用loaders对模块的原始代码进行编译，转换成标准的js代码</li>\n<li>第二步：调用acorn对js代码进行语法分析，然后收集其中的依赖关系。每个模块都会记录自己的依赖关系，从而形成一颗关系树</li>\n<li>最后调用compilation.seal进入render阶段，根据之前收集的依赖，决定生成多少文件，每个文件的内容是什么</li>\n</ol>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjsfugro90000vrie2xsd98if","category_id":"cjsfugroh0004vrie4v4qgc92","_id":"cjsfugrop000evrie7b4ar6ds"},{"post_id":"cjsfugrom000cvrie5vq7rnnt","category_id":"cjsfugroh0004vrie4v4qgc92","_id":"cjsfugrot000kvrie472vi094"},{"post_id":"cjsfugroe0002vriewyn6ubg7","category_id":"cjsfugrom000avriejr182f7t","_id":"cjsfugrou000pvrieoeldk8jx"},{"post_id":"cjsfugroi0006vriel1oii6kg","category_id":"cjsfugrom000avriejr182f7t","_id":"cjsfugrow000svrie81ckzj6x"},{"post_id":"cjsfugrok0008vrietsij4wt5","category_id":"cjsfugrot000mvriell3gla12","_id":"cjsfugrox000yvrie3o5pjbaf"},{"post_id":"cjsfugrov000rvriebv9mmrdw","category_id":"cjsfugroh0004vrie4v4qgc92","_id":"cjsfugroz0012vriey8w99ur0"},{"post_id":"cjsfugrow000vvriehbra3c5z","category_id":"cjsfugrow000tvrieisbvkf7y","_id":"cjsfugroz0015vriegdnh2ccy"},{"post_id":"cjsfugron000dvries9bfleea","category_id":"cjsfugrow000tvrieisbvkf7y","_id":"cjsfugrp10019vriefypaz2hz"},{"post_id":"cjsfugrox000xvrieicb1gk0p","category_id":"cjsfugrow000tvrieisbvkf7y","_id":"cjsfugrp1001bvrie8hxay90g"},{"post_id":"cjsfugror000hvrie2eer4p94","category_id":"cjsfugroy000zvriea44cszi3","_id":"cjsfugrp2001fvried321hu5f"},{"post_id":"cjsfugros000jvrievbpl0tch","category_id":"cjsfugroy000zvriea44cszi3","_id":"cjsfugrp2001hvriea9nwgsc7"},{"post_id":"cjsfugrou000ovrieniz0067f","category_id":"cjsfugrow000tvrieisbvkf7y","_id":"cjsfugrp3001kvriempbqvfue"},{"post_id":"cjsfugroy0011vrieccw47owi","category_id":"cjsfugroy000zvriea44cszi3","_id":"cjsfugrp4001nvrie7nb3ikld"},{"post_id":"cjsfugroz0014vrie7nkvgr3y","category_id":"cjsfugrp3001jvriebjsb6zbw","_id":"cjsfugrp4001svriee57f5na6"},{"post_id":"cjsfugrp00016vrieqg66vz0x","category_id":"cjsfugrp4001ovrieuuxxeglc","_id":"cjsfugrp5001vvrie36deyy1b"},{"post_id":"cjsfugrpb002kvriepzbn6zce","category_id":"cjsfugroh0004vrie4v4qgc92","_id":"cjsfugrpe002pvriekdw6neaj"},{"post_id":"cjsfugrpc002lvrieusimqixg","category_id":"cjsfugrp3001jvriebjsb6zbw","_id":"cjsfugrpe002rvrie2pxs6weu"},{"post_id":"cjsfugrpd002nvrie7qgpgoy3","category_id":"cjsfugroh0004vrie4v4qgc92","_id":"cjsfugrpf002svrie4ae7xrv4"}],"PostTag":[{"post_id":"cjsfugro90000vrie2xsd98if","tag_id":"cjsfugroi0005vrieha0vso04","_id":"cjsfugros000ivriebsv4f8zc"},{"post_id":"cjsfugro90000vrie2xsd98if","tag_id":"cjsfugrom000bvrie8dw0956o","_id":"cjsfugrot000lvrie0ycwryrm"},{"post_id":"cjsfugroe0002vriewyn6ubg7","tag_id":"cjsfugroq000gvriercvoj278","_id":"cjsfugrou000qvrieu80spsyd"},{"post_id":"cjsfugroi0006vriel1oii6kg","tag_id":"cjsfugroq000gvriercvoj278","_id":"cjsfugrox000wvrieujz9g9sl"},{"post_id":"cjsfugrok0008vrietsij4wt5","tag_id":"cjsfugrow000uvriel4m8rlnw","_id":"cjsfugroz0013vriekmgizft7"},{"post_id":"cjsfugrom000cvrie5vq7rnnt","tag_id":"cjsfugroi0005vrieha0vso04","_id":"cjsfugrp1001avrie5q3c0i9n"},{"post_id":"cjsfugrom000cvrie5vq7rnnt","tag_id":"cjsfugroy0010vriepv2d8d4f","_id":"cjsfugrp1001cvrier77gi9a0"},{"post_id":"cjsfugron000dvries9bfleea","tag_id":"cjsfugrp00018vriebd9o9cdv","_id":"cjsfugrp3001mvrie6gjkiske"},{"post_id":"cjsfugron000dvries9bfleea","tag_id":"cjsfugrp2001evrie61roerny","_id":"cjsfugrp4001pvriefrwrokqb"},{"post_id":"cjsfugron000dvries9bfleea","tag_id":"cjsfugrp2001ivrieonapkp3x","_id":"cjsfugrp4001rvriem8ubes67"},{"post_id":"cjsfugror000hvrie2eer4p94","tag_id":"cjsfugrp00018vriebd9o9cdv","_id":"cjsfugrp5001uvriegbp656y8"},{"post_id":"cjsfugror000hvrie2eer4p94","tag_id":"cjsfugrp2001ivrieonapkp3x","_id":"cjsfugrp5001wvrie86vo06wz"},{"post_id":"cjsfugros000jvrievbpl0tch","tag_id":"cjsfugrp4001tvrie1o39svd1","_id":"cjsfugrp5001yvrief2o9hm2x"},{"post_id":"cjsfugrou000ovrieniz0067f","tag_id":"cjsfugrp5001xvrie6wvhche7","_id":"cjsfugrp60021vriermunl3o4"},{"post_id":"cjsfugrou000ovrieniz0067f","tag_id":"cjsfugrp5001zvrie5v0rzpko","_id":"cjsfugrp60022vrie7nksr95y"},{"post_id":"cjsfugrov000rvriebv9mmrdw","tag_id":"cjsfugrp60020vrie00x84zyh","_id":"cjsfugrp60024vriezg2tq56w"},{"post_id":"cjsfugrow000vvriehbra3c5z","tag_id":"cjsfugrp60023vrie5wkoe6zf","_id":"cjsfugrp70027vrieiyv6t2dx"},{"post_id":"cjsfugrow000vvriehbra3c5z","tag_id":"cjsfugrp5001zvrie5v0rzpko","_id":"cjsfugrp70028vrie28rx01cj"},{"post_id":"cjsfugrox000xvrieicb1gk0p","tag_id":"cjsfugrp70026vrie6b3vfh7j","_id":"cjsfugrp8002avriec4jycodz"},{"post_id":"cjsfugroy0011vrieccw47owi","tag_id":"cjsfugrp70029vrie4nqjqkuj","_id":"cjsfugrp8002dvries8lssctp"},{"post_id":"cjsfugroy0011vrieccw47owi","tag_id":"cjsfugrp8002bvriep7auzffq","_id":"cjsfugrp8002evriengzabw22"},{"post_id":"cjsfugroz0014vrie7nkvgr3y","tag_id":"cjsfugrp8002cvriecuzixfws","_id":"cjsfugrp9002hvrie4s37jari"},{"post_id":"cjsfugroz0014vrie7nkvgr3y","tag_id":"cjsfugrp00018vriebd9o9cdv","_id":"cjsfugrp9002ivriewh5j301n"},{"post_id":"cjsfugrp00016vrieqg66vz0x","tag_id":"cjsfugrp9002gvriewsefe85i","_id":"cjsfugrp9002jvrie05qecxlm"},{"post_id":"cjsfugrpb002kvriepzbn6zce","tag_id":"cjsfugrom000bvrie8dw0956o","_id":"cjsfugrpd002mvrie0vkpk4hv"},{"post_id":"cjsfugrpd002nvrie7qgpgoy3","tag_id":"cjsfugroi0005vrieha0vso04","_id":"cjsfugrpe002qvriekalcbuxq"},{"post_id":"cjsfugrpc002lvrieusimqixg","tag_id":"cjsfugrpe002ovrieq5bz1umb","_id":"cjsfugrpf002tvriedjy3xzph"}],"Tag":[{"name":"webpack","_id":"cjsfugroi0005vrieha0vso04"},{"name":"fis3","_id":"cjsfugrom000bvrie8dw0956o"},{"name":"Vuex","_id":"cjsfugroq000gvriercvoj278"},{"name":"代码回滚","_id":"cjsfugrow000uvriel4m8rlnw"},{"name":"gulp","_id":"cjsfugroy0010vriepv2d8d4f"},{"name":"对象","_id":"cjsfugrp00018vriebd9o9cdv"},{"name":"原型","_id":"cjsfugrp2001evrie61roerny"},{"name":"继承","_id":"cjsfugrp2001ivrieonapkp3x"},{"name":"Class","_id":"cjsfugrp4001tvrie1o39svd1"},{"name":"作用域","_id":"cjsfugrp5001xvrie6wvhche7"},{"name":"执行上下文","_id":"cjsfugrp5001zvrie5v0rzpko"},{"name":"Webpack","_id":"cjsfugrp60020vrie00x84zyh"},{"name":"作用域链","_id":"cjsfugrp60023vrie5wkoe6zf"},{"name":"闭包","_id":"cjsfugrp70026vrie6b3vfh7j"},{"name":"Set","_id":"cjsfugrp70029vrie4nqjqkuj"},{"name":"Map","_id":"cjsfugrp8002bvriep7auzffq"},{"name":"类","_id":"cjsfugrp8002cvriecuzixfws"},{"name":"数组去重","_id":"cjsfugrp9002gvriewsefe85i"},{"name":"对象拷贝","_id":"cjsfugrpe002ovrieq5bz1umb"}]}}