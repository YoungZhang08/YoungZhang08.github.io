<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="虚拟dom,diff算法," />










<meta name="description" content="首先，Vue在1.0的时代还没有虚拟dom这个概念，1.0时候频繁操作dom使用的是fragment来做修改，当然和vdom是无法媲美了，但是和innerHTML来比它还是提高了很大程度的性能的，毕竟fragment是可以比innerHTML减少很多次重排的。而Vue的virtual-dom（后文简称vdom吧~打字好累的哦~_~）是借鉴了React的，因为virtual-dom是React中的一">
<meta name="keywords" content="虚拟dom,diff算法">
<meta property="og:type" content="article">
<meta property="og:title" content="聊聊Vue的virtual-dom实现原理">
<meta property="og:url" content="https://YoungZhang08.github.io/2018/07/31/聊聊Vue的virtual-dom实现原理/index.html">
<meta property="og:site_name" content="YoungZhang&#39;s Blog">
<meta property="og:description" content="首先，Vue在1.0的时代还没有虚拟dom这个概念，1.0时候频繁操作dom使用的是fragment来做修改，当然和vdom是无法媲美了，但是和innerHTML来比它还是提高了很大程度的性能的，毕竟fragment是可以比innerHTML减少很多次重排的。而Vue的virtual-dom（后文简称vdom吧~打字好累的哦~_~）是借鉴了React的，因为virtual-dom是React中的一">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://youngzhang08.github.io/2018/07/31/聊聊Vue的virtual-dom实现原理/0.png">
<meta property="og:image" content="https://youngzhang08.github.io/2018/07/31/聊聊Vue的virtual-dom实现原理/1.png">
<meta property="og:image" content="https://youngzhang08.github.io/2018/07/31/聊聊Vue的virtual-dom实现原理/2.png">
<meta property="og:image" content="https://youngzhang08.github.io/2018/07/31/聊聊Vue的virtual-dom实现原理/3.png">
<meta property="og:image" content="https://youngzhang08.github.io/2018/07/31/聊聊Vue的virtual-dom实现原理/4.png">
<meta property="og:image" content="https://youngzhang08.github.io/2018/07/31/聊聊Vue的virtual-dom实现原理/5.png">
<meta property="og:updated_time" content="2018-08-06T11:38:09.506Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="聊聊Vue的virtual-dom实现原理">
<meta name="twitter:description" content="首先，Vue在1.0的时代还没有虚拟dom这个概念，1.0时候频繁操作dom使用的是fragment来做修改，当然和vdom是无法媲美了，但是和innerHTML来比它还是提高了很大程度的性能的，毕竟fragment是可以比innerHTML减少很多次重排的。而Vue的virtual-dom（后文简称vdom吧~打字好累的哦~_~）是借鉴了React的，因为virtual-dom是React中的一">
<meta name="twitter:image" content="https://youngzhang08.github.io/2018/07/31/聊聊Vue的virtual-dom实现原理/0.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://YoungZhang08.github.io/2018/07/31/聊聊Vue的virtual-dom实现原理/"/>





  <title>聊聊Vue的virtual-dom实现原理 | YoungZhang's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YoungZhang's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://YoungZhang08.github.io/2018/07/31/聊聊Vue的virtual-dom实现原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="YoungZhang">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YoungZhang's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">聊聊Vue的virtual-dom实现原理</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-31T09:30:03+08:00">
                2018-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/前端框架/" itemprop="url" rel="index">
                    <span itemprop="name">前端框架</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/07/31/聊聊Vue的virtual-dom实现原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/07/31/聊聊Vue的virtual-dom实现原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
      
      </div>
    </header>
  

          

          

        

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="首先，Vue在1-0的时代还没有虚拟dom这个概念，1-0时候频繁操作dom使用的是fragment来做修改，当然和vdom是无法媲美了，但是和innerHTML来比它还是提高了很大程度的性能的，毕竟fragment是可以比innerHTML减少很多次重排的。而Vue的virtual-dom（后文简称vdom吧-打字好累的哦-）是借鉴了React的，因为virtual-dom是React中的一个重要特性，而React是先于Vue发行问世的。所以很大程度上，Vue也是作为后来者吸取了React和Angular的经验，并在其上做了改进，才得以发展至今天的成果。"><a href="#首先，Vue在1-0的时代还没有虚拟dom这个概念，1-0时候频繁操作dom使用的是fragment来做修改，当然和vdom是无法媲美了，但是和innerHTML来比它还是提高了很大程度的性能的，毕竟fragment是可以比innerHTML减少很多次重排的。而Vue的virtual-dom（后文简称vdom吧-打字好累的哦-）是借鉴了React的，因为virtual-dom是React中的一个重要特性，而React是先于Vue发行问世的。所以很大程度上，Vue也是作为后来者吸取了React和Angular的经验，并在其上做了改进，才得以发展至今天的成果。" class="headerlink" title="首先，Vue在1.0的时代还没有虚拟dom这个概念，1.0时候频繁操作dom使用的是fragment来做修改，当然和vdom是无法媲美了，但是和innerHTML来比它还是提高了很大程度的性能的，毕竟fragment是可以比innerHTML减少很多次重排的。而Vue的virtual-dom（后文简称vdom吧~打字好累的哦~_~）是借鉴了React的，因为virtual-dom是React中的一个重要特性，而React是先于Vue发行问世的。所以很大程度上，Vue也是作为后来者吸取了React和Angular的经验，并在其上做了改进，才得以发展至今天的成果。"></a>首先，Vue在1.0的时代还没有虚拟dom这个概念，1.0时候频繁操作dom使用的是fragment来做修改，当然和vdom是无法媲美了，但是和innerHTML来比它还是提高了很大程度的性能的，毕竟fragment是可以比innerHTML减少很多次重排的。而Vue的virtual-dom（后文简称vdom吧~打字好累的哦~_~）是借鉴了React的，因为virtual-dom是React中的一个重要特性，而React是先于Vue发行问世的。所以很大程度上，Vue也是作为后来者吸取了React和Angular的经验，并在其上做了改进，才得以发展至今天的成果。</h3><a id="more"></a>
<h3 id="1-为什么会有vdom的出现？"><a href="#1-为什么会有vdom的出现？" class="headerlink" title="1. 为什么会有vdom的出现？"></a>1. 为什么会有vdom的出现？</h3><blockquote>
<p>假设如果没有vdom，那么我们在事件绑定的方法中需要频繁地操作真实的dom来达到视图更新的目的，但是一旦我们这个应用变得非常大，那么由于频繁的dom操作带来的性能降级是非常大的，而且非常难以维护。所以，有了vdom的概念。具体是什么呢？就是将我们真实的dom抽象成一个以js对象构成的抽象树，然后在抽象树上做修改，将差异更新到真实的视图层。酱紫不仅减少了很多不必要的操作，还大大提高了性能，不得不说，大牛还是大牛~</p>
</blockquote>
<h3 id="2-关于VNode"><a href="#2-关于VNode" class="headerlink" title="2. 关于VNode"></a>2. 关于VNode</h3><h4 id="先看一眼vue源码中对于vnode的定义，目录：-src-core-vdom-vnode-js"><a href="#先看一眼vue源码中对于vnode的定义，目录：-src-core-vdom-vnode-js" class="headerlink" title="先看一眼vue源码中对于vnode的定义，目录：/src/core/vdom/vnode.js"></a>先看一眼vue源码中对于vnode的定义，目录：/src/core/vdom/vnode.js</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export default class VNode &#123;</span><br><span class="line">  tag: string | void; // 当前节点的标签名</span><br><span class="line">  data: VNodeData | void; // 当前节点的data值，包括attrs，style，hook以及绑定的事件</span><br><span class="line">  children: ?Array&lt;VNode&gt;; // 当前节点的子节点，是一个数组</span><br><span class="line">  text: string | void; // 当前节点的文本内容</span><br><span class="line">  elm: Node | void; // 新旧虚拟节点对应的真实dom节点</span><br><span class="line">  ns: string | void; // 当前节点的名字空间</span><br><span class="line">  context: Component | void; // rendered in this component&apos;s scope 创建这个节点的上下文</span><br><span class="line">  key: string | number | void; // vnode的标记，在diff过程中可以提高diff的效率</span><br><span class="line">  componentOptions: VNodeComponentOptions | void; // 组件的option选项</span><br><span class="line">  componentInstance: Component | void; // component instance 当前节点对应的组件实例</span><br><span class="line">  parent: VNode | void; // component placeholder node 当前节点的父节点</span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打个比方，现在定义一个vnode的数据结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    tag: &apos;div&apos;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        class: &apos;app&apos;,</span><br><span class="line">    &#125;,</span><br><span class="line">    children: [</span><br><span class="line">        &#123;</span><br><span class="line">            tag: &apos;div&apos;,</span><br><span class="line">            data: &#123;</span><br><span class="line">                class: &apos;say&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            text: &apos;hello world!&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在真实的dom中渲染是酱紫的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;app&quot;&gt;</span><br><span class="line">    &lt;div class=&quot;say&quot;&gt;hello world!&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>vnode的源码中还有一些createEmptyVNode（创建一个空VNode节点）、createTextVNode（创建一个文本节点）、createComponent（创建一个组件节点）、cloneVNode（克隆一个VNode节点）以及createElement（创建一个虚拟节点）等方法的定义，在此不多做赘述，回到更新视图。</p>
<h3 id="3-更新视图"><a href="#3-更新视图" class="headerlink" title="3. 更新视图"></a>3. 更新视图</h3><p><a href="https://youngzhang08.github.io/2018/07/28/聊聊Vue的双向数据绑定/">聊聊Vue的双向数据绑定</a> 中已经总结过，当数据发生改变的时候，会触发该数据的setter，而setter会触发Observer的Dep调用notify函数来通知对应的Watcher调用update方法来更新视图。接下来就看看update方法的定义，源码目录：src/core/instance/lifycycle.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; // 接收的第一个参数就是vnode，在这里会将新旧vnode对象做__patch__</span><br><span class="line">    const vm: Component = this</span><br><span class="line">    const prevEl = vm.$el</span><br><span class="line">    const prevVnode = vm._vnode</span><br><span class="line">    const prevActiveInstance = activeInstance</span><br><span class="line">    activeInstance = vm</span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    </span><br><span class="line">    if (!prevVnode) &#123; // 如果需要diff的prevVnode不存在，那么就用新的vnode创建一个真实dom节点</span><br><span class="line">      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 如果需要diff的prevVnode存在，那么首先对oldvnode（在这里的参数是prevVnode，代表旧vnode）和vnode进行diff,并将需要更新的dom操作以patch的形式打到oldvnode上，并完成真实dom的更新工作</span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里可以看到最为核心的diff过程，是通过vm.<strong>patch</strong>来完成的，这也是vdom的核心方法，主要完成了prevVnode和vnode的diff过程并根据需要操作的vdom节点打patch，最后新生成的真实dom节点并完成视图的更新工作。</p>
<h3 id="4-diff过程-——-patch"><a href="#4-diff过程-——-patch" class="headerlink" title="4. diff过程 —— patch"></a>4. diff过程 —— patch</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// src/core/vdom/patch.js</span><br><span class="line">function patch (oldVnode, vnode, hydrating, removeOnly) &#123;</span><br><span class="line">    if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; </span><br><span class="line">        // 当两个虚拟节点是同一个节点的时候（sameVnode），对oldVnode和vnode的children进行diff，并对oldVnode打patch</span><br><span class="line">        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 如果新旧虚拟节点不一样，就说明vnode完全被改变了，则删除旧虚拟节点对应的真实dom并替换为新虚拟节点对应的真实dom</span><br><span class="line">        elm = oldVnode.elm as Node;</span><br><span class="line">        parent = api.parentNode(elm);</span><br><span class="line"></span><br><span class="line">        createElm(vnode, insertedVnodeQueue);</span><br><span class="line"></span><br><span class="line">        if (parent !== null) &#123;</span><br><span class="line">            api.insertBefore(parent, vnode.elm as Node, api.nextSibling(elm));</span><br><span class="line">            removeVnodes(parent, [oldVnode], 0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面可以看到只有在对oldVnode和vnode进行类型判断时有个sameVnode方法，这个方法决定了是否需要对oldVnode和vnode进行diff及patch的过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// src/core/vdom/patch.js</span><br><span class="line">function sameVnode (a, b) &#123;</span><br><span class="line">  return (</span><br><span class="line">    a.key === b.key &amp;&amp; (</span><br><span class="line">      (</span><br><span class="line">        a.tag === b.tag &amp;&amp;</span><br><span class="line">        a.isComment === b.isComment &amp;&amp;</span><br><span class="line">        isDef(a.data) === isDef(b.data) &amp;&amp;</span><br><span class="line">        sameInputType(a, b)</span><br><span class="line">      ) || (</span><br><span class="line">        isTrue(a.isAsyncPlaceholder) &amp;&amp;</span><br><span class="line">        a.asyncFactory === b.asyncFactory &amp;&amp;</span><br><span class="line">        isUndef(b.asyncFactory.error)</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它需要传入两个vnode进行基本属性的比较，只有当两个VNode的tag、key、isComment都相同，并且同时定义或未定义data的时候，且如果标签为input则type必须相同的情况下才认为这2个vnode只是局部发生了更新，然后才会对这2个vnode进行diff的patchVnode操作，如果这2个vnode的基本属性存在不一致的情况，那么就会直接跳过diff过程，然后根据vnode创建一个真实的dom，同时删除旧的dom节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function patchVnode (oldVnode, vnode, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">    if (oldVnode === vnode) &#123; // 两个vnode节点相同则直接返回</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    const oldCh = oldVnode.children</span><br><span class="line">    const ch = vnode.children</span><br><span class="line"></span><br><span class="line">    if (isUndef(vnode.text)) &#123; // 如果vnode没有文本节点</span><br><span class="line">        if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; // 如果新老虚拟节点的子节点存在，则对两个虚拟节点的子节点进行diff操作，调用updateChildren方法</span><br><span class="line">            if (oldCh !== ch) updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly)</span><br><span class="line">        &#125; else if (isDef(ch)) &#123;</span><br><span class="line">            // 如果只有新虚拟节点存在子节点，老虚拟节点不存在子节点，假如旧虚拟节点的text属性有定义，说明旧的虚拟节点对应的真实节点有且仅有文本子节点，需要先清除文本节点，然后将新虚拟节点子节点对应的真实节点添加到当前真实节点的子节点。</span><br><span class="line">            if (isDef(oldVnode.text)) nodeOps.setTextContent(elm, &apos;&apos;)</span><br><span class="line">            addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue)</span><br><span class="line">        &#125; else if (isDef(oldCh)) &#123;</span><br><span class="line">            // 如果新虚拟节点没有子节点，老虚拟节点有子节点的时候，则移除老虚拟节点对应的真实dom节点的子节点</span><br><span class="line">            removeVnodes(elm, oldCh, 0, oldCh.length - 1)</span><br><span class="line">        &#125; else if (isDef(oldVnode.text)) &#123;</span><br><span class="line">            // 当新老节点都无子节点的时候，只是文本的替换，因为这个逻辑中新节点text不存在，所以直接去除ele的文本</span><br><span class="line">            nodeOps.setTextContent(elm, &apos;&apos;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else if (oldVnode.text !== vnode.text) &#123;</span><br><span class="line">        // 当新老节点text不一样时，直接替换这段文本</span><br><span class="line">        nodeOps.setTextContent(elm, vnode.text)</span><br><span class="line">    &#125;</span><br><span class="line">    if (isDef(data)) &#123;</span><br><span class="line">        if (isDef(i = data.hook) &amp;&amp; isDef(i = i.postpatch)) i(oldVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="这里主要捋一下patchVnode的规则："><a href="#这里主要捋一下patchVnode的规则：" class="headerlink" title="这里主要捋一下patchVnode的规则："></a>这里主要捋一下patchVnode的规则：</h4><ul>
<li>首先进行文本节点判断，如果新老节点文本内容不同，则直接进行文本的替换</li>
<li>在新虚拟节点没有文本节点的情况下进入其子节点的diff</li>
<li>当新老节点都存在子节点且不相同的情况下，调用updateChildren方法对其子节点进行diff</li>
<li>如果新虚拟节点存在子节点，老虚拟节点没有子节点，假设老虚拟节点有文本内容那就得先清除老节点的文本内容，然后调用addVnode方法将新的虚拟子节点添加到真实父节点中</li>
<li>如果老节点有子节点而新节点没有子节点，则删除真实节点的老节点下的子节点</li>
<li>如果新老节点都没有子节点，那就只做文本的替换</li>
</ul>
<h3 id="5-更新子节点——updateChildren"><a href="#5-更新子节点——updateChildren" class="headerlink" title="5. 更新子节点——updateChildren"></a>5. 更新子节点——updateChildren</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123;</span><br><span class="line">    let oldStartIdx = 0</span><br><span class="line">    let newStartIdx = 0</span><br><span class="line">    let oldEndIdx = oldCh.length - 1</span><br><span class="line">    let oldStartVnode = oldCh[0]</span><br><span class="line">    let oldEndVnode = oldCh[oldEndIdx]</span><br><span class="line">    let newEndIdx = newCh.length - 1</span><br><span class="line">    let newStartVnode = newCh[0]</span><br><span class="line">    let newEndVnode = newCh[newEndIdx]</span><br><span class="line">    let oldKeyToIdx, idxInOld, vnodeToMove, refElm</span><br><span class="line"></span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos;) &#123;</span><br><span class="line">        checkDuplicateKeys(newCh)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123;</span><br><span class="line">        if (isUndef(oldStartVnode)) &#123;</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">        &#125; else if (isUndef(oldEndVnode)) &#123;</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">        &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; </span><br><span class="line">            patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue)</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))</span><br><span class="line">            oldStartVnode = oldCh[++oldStartIdx]</span><br><span class="line">            newEndVnode = newCh[--newEndIdx]</span><br><span class="line">        &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123;</span><br><span class="line">            patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue)</span><br><span class="line">            canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)</span><br><span class="line">            oldEndVnode = oldCh[--oldEndIdx]</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">                idxInOld = isDef(newStartVnode.key)</span><br><span class="line">                    ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">                    : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">            if (isUndef(idxInOld)) &#123;</span><br><span class="line">                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                vnodeToMove = oldCh[idxInOld]</span><br><span class="line">                if (sameVnode(vnodeToMove, newStartVnode)) &#123;</span><br><span class="line">                    patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue)</span><br><span class="line">                    oldCh[idxInOld] = undefined</span><br><span class="line">                    canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            newStartVnode = newCh[++newStartIdx]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (oldStartIdx &gt; oldEndIdx) &#123;</span><br><span class="line">        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm</span><br><span class="line">        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)</span><br><span class="line">    &#125; else if (newStartIdx &gt; newEndIdx) &#123;</span><br><span class="line">        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="有没有觉得长的吐血？？？嗯，我难产了一个周的vdom源码分析，就是卡在这里，头大······所以换种思考分析方式，不一行一行分析了，先来说下这部分代码做了什么——"><a href="#有没有觉得长的吐血？？？嗯，我难产了一个周的vdom源码分析，就是卡在这里，头大······所以换种思考分析方式，不一行一行分析了，先来说下这部分代码做了什么——" class="headerlink" title="有没有觉得长的吐血？？？嗯，我难产了一个周的vdom源码分析，就是卡在这里，头大······所以换种思考分析方式，不一行一行分析了，先来说下这部分代码做了什么——"></a>有没有觉得长的吐血？？？嗯，我难产了一个周的vdom源码分析，就是卡在这里，头大······所以换种思考分析方式，不一行一行分析了，先来说下这部分代码做了什么——</h4><ul>
<li>首先，它给新旧孩子节点的队列头和尾均设置了变量标记，oldCh的为oldStartIdx和oldEndIdx，newCh的为newStartIdx和newEndIdx。</li>
<li>接着对应索引和vnode间的关系：oldStartIdx =&gt; oldStartVnode，oldEndIdx =&gt; oldEndVnode，newSatrtIdx =&gt; newSatrtVnode，newEndIdx =&gt; newEndVnode</li>
<li>对上述对应的四个变量两两做比较，2*2种情况：   <ol>
<li>如果oldStartVnode和newSatrtVnode或者如果oldEndtVnode和newEndVnode是同一个节点，则直接将该oldVnode节点进行patchVnode即可，完了变量指针向中间靠拢</li>
<li>如果oldStartVnode和newEndVnode是同一个节点，则说明原来的第一个节点跑到了最后一个位置，则进行patchvnode<br>的同时还需要将对应的真实dom节点移动到oldEndVnode后面</li>
<li>如果oldEndVnode和newStartVnode是同一个节点，则说明原来的最后一个节点跑到了第一个位置，则进行patchvnode<br>的同时还需要将对应的真实dom节点移动到oldStartVnode前面</li>
<li>如果上述的四种如果都不匹配——<ul>
<li>则会通过createKeyToOldIdx函数根据oldCh的key得到oldKeyToIdx，oldKeyToIdx是个map，其内部存放的是key为oldCh的Vnode，value为对应的index。用newStartVnode的key与map表做匹配，如果存在有一致的key并且同时满足sameVnode，那么patchVnode的同时会将成功匹配的节点移动到真实dom节点的前面；否则的话，就将newCh的指针后移并将指向的节点赋为newStartVnode</li>
<li>如果newStartVnode的key在map中匹配不到一致的key或者匹配到了一致的key但是sameVnode结果为false，这时候就调用createElm方法创建一个新的节点插入到真实的dom节点    </li>
</ul>
</li>
</ol>
</li>
<li>当oldStartIdx &gt; oldEndIdx或者 newStartIdx &gt; newEndIdx时结束循环，这个时候说明至少有一个已经遍历完了就会结束比较，但是也需要处理多余或者不够的真实dom节点：<ol>
<li>当结束时oldStartIdx &gt; oldEndIdx，这个时候说明旧的vnode已经遍历完了，但是新的还没有，说明新的vnode节点比老的vnode多，也就是比真实的dom多，需要将剩下的vnode节点调用addVnodes（批量调用createElm方法）将这些节点根据自己的index插入到真实的dom中去</li>
<li>当结束时newSatrtIdx &gt; newEndIdx，这个时候说明新的vnode已经遍历完了，但是老的节点还有剩余，需要将真实dom节点中多余的节点调用removeVnodes将多余的真实dom节点删除</li>
</ol>
</li>
</ul>
<h3 id="我觉得上面的规则好多呀，有没有很头大，比刘智林的头还大的感觉？emmmm，那我来举几个图示的例子，你就懂了"><a href="#我觉得上面的规则好多呀，有没有很头大，比刘智林的头还大的感觉？emmmm，那我来举几个图示的例子，你就懂了" class="headerlink" title="我觉得上面的规则好多呀，有没有很头大，比刘智林的头还大的感觉？emmmm，那我来举几个图示的例子，你就懂了~"></a>我觉得上面的规则好多呀，有没有很头大，比刘智林的头还大的感觉？emmmm，那我来举几个图示的例子，你就懂了~</h3><p><img src="./0.png" alt="image"></p>
<p>接下来开始第一次比较：</p>
<p><img src="./1.png" alt="image"></p>
<p>第二次比较：</p>
<p><img src="./2.png" alt="image"></p>
<p>第三次比较</p>
<p><img src="./3.png" alt="image"></p>
<p>第四次比较</p>
<p><img src="4.png" alt="image"></p>
<p>最后一次比较！！！</p>
<p><img src="5.png" alt="image"></p>
<p>我觉得我懂了，你懂了没。。。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/虚拟dom/" rel="tag"># 虚拟dom</a>
          
            <a href="/tags/diff算法/" rel="tag"># diff算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/07/30/为什么defineProperty不能检测到数组长度的变化/" rel="next" title="为什么defineProperty不能检测到数组长度的变化">
                <i class="fa fa-chevron-left"></i> 为什么defineProperty不能检测到数组长度的变化
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/08/06/瞅瞅五个最新的CSS特性/" rel="prev" title="瞅瞅五个最新的CSS特性">
                瞅瞅五个最新的CSS特性 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">YoungZhang</p>
              <p class="site-description motion-element" itemprop="description">越努力越幸运~</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/YoungZhang08" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zhangyangyang@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://plus.google.com/zhangyangyang" target="_blank" title="Google">
                      
                        <i class="fa fa-fw fa-google"></i>Google</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://instagram.com/youngzhang1001" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#首先，Vue在1-0的时代还没有虚拟dom这个概念，1-0时候频繁操作dom使用的是fragment来做修改，当然和vdom是无法媲美了，但是和innerHTML来比它还是提高了很大程度的性能的，毕竟fragment是可以比innerHTML减少很多次重排的。而Vue的virtual-dom（后文简称vdom吧-打字好累的哦-）是借鉴了React的，因为virtual-dom是React中的一个重要特性，而React是先于Vue发行问世的。所以很大程度上，Vue也是作为后来者吸取了React和Angular的经验，并在其上做了改进，才得以发展至今天的成果。"><span class="nav-number">1.</span> <span class="nav-text">首先，Vue在1.0的时代还没有虚拟dom这个概念，1.0时候频繁操作dom使用的是fragment来做修改，当然和vdom是无法媲美了，但是和innerHTML来比它还是提高了很大程度的性能的，毕竟fragment是可以比innerHTML减少很多次重排的。而Vue的virtual-dom（后文简称vdom吧~打字好累的哦~_~）是借鉴了React的，因为virtual-dom是React中的一个重要特性，而React是先于Vue发行问世的。所以很大程度上，Vue也是作为后来者吸取了React和Angular的经验，并在其上做了改进，才得以发展至今天的成果。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-为什么会有vdom的出现？"><span class="nav-number">2.</span> <span class="nav-text">1. 为什么会有vdom的出现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-关于VNode"><span class="nav-number">3.</span> <span class="nav-text">2. 关于VNode</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#先看一眼vue源码中对于vnode的定义，目录：-src-core-vdom-vnode-js"><span class="nav-number">3.1.</span> <span class="nav-text">先看一眼vue源码中对于vnode的定义，目录：/src/core/vdom/vnode.js</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-更新视图"><span class="nav-number">4.</span> <span class="nav-text">3. 更新视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-diff过程-——-patch"><span class="nav-number">5.</span> <span class="nav-text">4. diff过程 —— patch</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#这里主要捋一下patchVnode的规则："><span class="nav-number">5.1.</span> <span class="nav-text">这里主要捋一下patchVnode的规则：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-更新子节点——updateChildren"><span class="nav-number">6.</span> <span class="nav-text">5. 更新子节点——updateChildren</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#有没有觉得长的吐血？？？嗯，我难产了一个周的vdom源码分析，就是卡在这里，头大······所以换种思考分析方式，不一行一行分析了，先来说下这部分代码做了什么——"><span class="nav-number">6.1.</span> <span class="nav-text">有没有觉得长的吐血？？？嗯，我难产了一个周的vdom源码分析，就是卡在这里，头大······所以换种思考分析方式，不一行一行分析了，先来说下这部分代码做了什么——</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#我觉得上面的规则好多呀，有没有很头大，比刘智林的头还大的感觉？emmmm，那我来举几个图示的例子，你就懂了"><span class="nav-number">7.</span> <span class="nav-text">我觉得上面的规则好多呀，有没有很头大，比刘智林的头还大的感觉？emmmm，那我来举几个图示的例子，你就懂了~</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">YoungZhang</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://YoungZhang08.github.io/2018/07/31/聊聊Vue的virtual-dom实现原理/';
          this.page.identifier = '2018/07/31/聊聊Vue的virtual-dom实现原理/';
          this.page.title = '聊聊Vue的virtual-dom实现原理';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  





  












  





  

  

  

  
  

  

  

  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
  
</body>
</html>
